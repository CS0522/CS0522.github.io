{"meta":{"title":"诚实同学的博客","subtitle":"","description":"Patience is key in life.","author":"Chen Shi","url":"https://CS0522.github.io","root":"/"},"pages":[{"title":"","date":"2025-01-18T04:16:10.399Z","updated":"2025-01-17T18:57:47.085Z","comments":true,"path":"404.html","permalink":"https://cs0522.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2025-01-18T04:16:10.399Z","updated":"2025-01-17T18:57:47.141Z","comments":true,"path":"googlee2f7ebf4d04c0ee5.html","permalink":"https://cs0522.github.io/googlee2f7ebf4d04c0ee5.html","excerpt":"","text":"google-site-verification: googlee2f7ebf4d04c0ee5.html"},{"title":"所有分类","date":"2025-01-18T04:16:10.399Z","updated":"2025-01-17T18:57:47.141Z","comments":true,"path":"categories/index.html","permalink":"https://cs0522.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2025-01-18T04:16:10.399Z","updated":"2025-01-17T18:57:47.141Z","comments":true,"path":"about/index.html","permalink":"https://cs0522.github.io/about/index.html","excerpt":"","text":"Chen Shi Email: chenshi020522@outlook.com Blog: https://CS0522.github.io 教育经历 table { width: 100%; } table th:first-of-type { width: 20%; } table th:nth-of-type(2) { width: 30%; } table th:nth-of-type(3) { width: 20%; } td, th { border: none!important; } 时间 学校 专业 2020.09 - 2024.07 大连理工大学 软件工程 2024.09 - 至今 华中科技大学 计算机技术"},{"title":"","date":"2025-01-18T04:16:10.399Z","updated":"2025-01-17T18:57:47.177Z","comments":true,"path":"mylist/index.html","permalink":"https://cs0522.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2025-01-18T04:16:10.399Z","updated":"2025-01-17T18:57:47.177Z","comments":true,"path":"tags/index.html","permalink":"https://cs0522.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【学习笔记】gRPC（一）：编译与安装","slug":"n-grpc-01","date":"2025-01-20T17:45:05.000Z","updated":"2025-01-20T17:55:14.162Z","comments":false,"path":"notes/n-grpc-01/","link":"","permalink":"https://cs0522.github.io/notes/n-grpc-01/","excerpt":"gRPC 编译与安装。","text":"gRPC 编译与安装。 系统环境 Ubuntu 20.04 gRPC v1.34.0 gRPC 该版本在 Ubuntu 22.04 下编译出错。 安装依赖、Clone 仓库 123456789sudo apt install -y build-essential autoconf libtool \\ pkg-config cmake make git vimgit clone --recurse-submodules -b v1.34.0 --depth 1 \\ --shallow-submodules https://github.com/grpc/grpc.git# 获取已经打包好的wget https://github.com/CS0522/CSBlog/releases/download/coroutine_kvdb_files/grpc-1.34.0.zipunzip grpc-1.34.0.zip 编译 一起编译其他依赖库，不需要额外安装。 123456789101112131415161718192021cd grpc# 建议不安装在 /usr/localexport MY_INSTALL_DIR=$HOME/.localmkdir -p $MY_INSTALL_DIRexport PATH=&quot;$MY_INSTALL_DIR/bin:$PATH&quot;mkdir -p cmake/buildpushd cmake/buildcmake -DgRPC_INSTALL=ON \\ -DgRPC_BUILD_TESTS=OFF \\ -DCMAKE_INSTALL_PREFIX=$MY_INSTALL_DIR \\ ../..make -j16sudo make installpopd# 再将 PATH 写入 /etc/profile 或 ~/.bashrcvim ~/.bashrcexport export PATH=&quot;$HOME/.local/bin:$PATH&quot;source ~/.bashrc proto 文件生成命令 1protoc --cpp_out=./include --grpc_out=./include --plugin=protoc-gen-grpc=`which grpc_cpp_plugin` -I./proto db.proto","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"}],"tags":[{"name":"存储","slug":"存储","permalink":"https://cs0522.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"RPC","slug":"RPC","permalink":"https://cs0522.github.io/tags/RPC/"}]},{"title":"【学习笔记】CPU 利用率、绑核","slug":"n-cpu-monitor-bind-core","date":"2025-01-20T17:43:48.000Z","updated":"2025-01-20T17:48:45.007Z","comments":false,"path":"notes/n-cpu-monitor-bind-core/","link":"","permalink":"https://cs0522.github.io/notes/n-cpu-monitor-bind-core/","excerpt":"CPU 利用率，以及绑核操作示例代码。","text":"CPU 利用率，以及绑核操作示例代码。 CPU 利用率统计 与 top 命令结果一致。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162inline double calculate_cpu_utilization(uint64_t &amp;last_total_time, uint64_t &amp;last_process_time)&#123; std::ifstream proc_stat(&quot;/proc/stat&quot;); std::ifstream self_stat(&quot;/proc/self/stat&quot;); if (!proc_stat.is_open() || !self_stat.is_open()) &#123; return -1.0; // Error opening files &#125; proc_stat.seekg(0); self_stat.seekg(0); std::string line; uint64_t user, nice, system, idle, iowait, irq, softirq, steal; uint64_t utime, stime; if (std::getline(proc_stat, line)) &#123; std::istringstream iss(line); iss.ignore(5, &#x27; &#x27;); // Skip &quot;cpu&quot; iss &gt;&gt; user &gt;&gt; nice &gt;&gt; system &gt;&gt; idle &gt;&gt; iowait &gt;&gt; irq &gt;&gt; softirq &gt;&gt; steal; &#125; else &#123; return -1.0; // Error reading /proc/stat &#125; if (std::getline(self_stat, line)) &#123; std::istringstream iss(line); for (int i = 0; i &lt; 13; ++i) &#123; iss.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#x27; &#x27;); &#125; iss &gt;&gt; utime &gt;&gt; stime; &#125; else &#123; return -1.0; // Error reading /proc/self/stat &#125; uint64_t total_time = user + nice + system + idle + iowait + irq + softirq + steal; uint64_t process_time = utime + stime; double utilization = 0.0; if (last_total_time &gt; 0 &amp;&amp; last_process_time &gt; 0) &#123; uint64_t total_delta = total_time - last_total_time; uint64_t process_delta = process_time - last_process_time; if (total_delta &gt; 0) &#123; int num_cores = std::thread::hardware_concurrency(); utilization = 100.0 * process_delta / (total_delta / num_cores); &#125; &#125; last_total_time = total_time; last_process_time = process_time; return utilization;&#125; 绑核 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void BindThreadToCore(int thread_id)&#123; cpu_set_t cpu_set; CPU_ZERO(&amp;cpu_set); // Get the core from the CPU mask by checking the bit at the thread_id position int core_id = GetCoreIdFromMask(thread_id); CPU_SET(core_id, &amp;cpu_set); if (pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &amp;cpu_set) != 0) &#123; std::cerr &lt;&lt; &quot;Error binding thread to CPU core &quot; &lt;&lt; core_id &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;Server thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; bound to core &quot; &lt;&lt; core_id &lt;&lt; std::endl; &#125;&#125;// Function to get the core ID from the mask, rotating through available coresint GetCoreIdFromMask(int thread_id)&#123; int available_core_count = cpu_mask_.count(); if (available_core_count == 0) &#123; throw std::runtime_error(&quot;No available CPU cores in the mask&quot;); &#125; // Find the core by checking the bits in the CPU mask int core_id = -1; int count = 0; for (int i = 0; i &lt; 128; ++i) &#123; if (cpu_mask_.test(i)) &#123; if (count == thread_id) &#123; core_id = i; break; &#125; ++count; &#125; &#125; // Not enough cores if (core_id == -1) &#123; throw std::runtime_error(&quot;The allocated cpu cores are less than the number of threads&quot;); &#125; return core_id;&#125;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"}]},{"title":"【学习笔记】bRPC（一）：编译与安装","slug":"n-brpc-01","date":"2024-12-03T07:12:28.000Z","updated":"2025-01-20T17:50:05.145Z","comments":false,"path":"notes/n-brpc-01/","link":"","permalink":"https://cs0522.github.io/notes/n-brpc-01/","excerpt":"bRPC 编译、安装与样例测试。","text":"bRPC 编译、安装与样例测试。 系统环境 Ubuntu 18.04 以上 gcc 4.x ~ 11.x brpc-1.5.0 3 个特定版本的关键依赖： gflags-2.2.2 protobuf-3.20.0 glog-0.4.0 后文的依赖和项目的路径： /users/CS0522/bthread-dep/gflags-2.2.2/ /users/CS0522/bthread-dep/protobuf/ /users/CS0522/bthread-dep/glog-0.4.0/ /users/CS0522/custom-brpc/brpc/ 安装依赖 安装其他依赖 openssl、leveldb、ibverbs，以及静态链接 leveldb 的依赖： 1sudo apt install -y libssl-dev libleveldb-dev libibverbs-dev librdmacm-dev libsnappy-dev 安装关键依赖 按顺序安装！ 安装 gflags： 1234567# /users/CS0522/bthread-dep/gflags-2.2.2mkdir build &amp;&amp; cd buildcmake -DCMAKE_INSTALL_PREFIX=/usr/local -DBUILD_SHARED_LIBS=ON -DGFLAGS_NAMESPACE=google -DCMAKE_HAVE_LIBC_PTHREAD=ON -G &quot;Unix Makefiles&quot; -DBUILD_SHARED_LIBS=1 -DBUILD_STATIC_LIBS=1 ../make -j16sudo make installsudo systemctl daemon-reloadsudo ldconfig 安装 protobuf： 1234567# /users/CS0522/bthread-dep/protobuf/make clean &amp;&amp; make distclean./configure --prefix=/usr/localmake -j16sudo make installsudo systemctl daemon-reloadsudo ldconfig 安装 glog： 12345# /users/CS0522/bthread-dep/glog-0.4.0/./autogen.sh./configure CXXFLAGS=&quot;-std=c++11&quot;make -j16sudo make install 编译 brpc 123456# /users/CS0522/custom-brpc/brpc/sudo chmod 777 ./tools/*.shmkdir build &amp;&amp; cd buildcmake ..make -j16sudo make install echo 样例测试 修改 CMakeLists.txt 新的压缩包 custom-bprc.zip 中已经修改好： 1234567891011121314151617181920# /users/CS0522/custom-brpc/brpc/example/echo_c++/vim CMakeLists.txt# 添加 glogfind_library(GLOG_LIB NAMES glog/logging.h)find_path(GLOG_INCLUDE_PATH NAMES glog)if (NOT GLOG_LIB) set(GLOG_LIB &quot;&quot;) set(GLOG_INCLUDE_PATH &quot;&quot;)endif()include_directories($&#123;GLOG_INCLUDE_PATH&#125;)# set DYNAMIC_LIB 中添加 GLOG_LIBset(DYNAMIC_LIB ... $&#123;GLOG_LIB&#125; dl )# 保存退出 编译 1234# /users/CS0522/custom-brpc/brpc/example/echo_c++/mkdir build &amp;&amp; cd buildcmake ..make -j16 运行 123# /users/CS0522/custom-brpc/brpc/example/echo_c++/build/./echo_server &amp;./echo_client","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"}],"tags":[{"name":"存储","slug":"存储","permalink":"https://cs0522.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"RPC","slug":"RPC","permalink":"https://cs0522.github.io/tags/RPC/"}]},{"title":"【学习笔记】设计模式（二十四）解释器","slug":"n-pattern-24","date":"2024-11-09T11:24:15.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/设计模式/n-pattern-24/","link":"","permalink":"https://cs0522.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/n-pattern-24/","excerpt":"领域规则：解释器","text":"领域规则：解释器 模式类型 领域规则 解释器 某些变化虽然频繁，但可以抽象为某种规则。提供了评估语言的语法或表达式的方式。 解释器模式给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 关键在于 Terminal Expression 和 Non-Terminal Expression，定义语言的文法结构。 使用场景 编译器 正则表达式 SQL 解析 举例 使用解释器模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// 抽象表达式类class Expression&#123;public: virtual int interpreter(map&lt;char, int&gt; var_map) = 0;&#125;;// 变量表达式// 终端表达式class VarExpression : public Expression&#123;private: char var;public: VarExpression(const char &amp;var) &#123; this-&gt;var = var; &#125; int interpreter(map&lt;char, int&gt; var_map) override &#123; return var_map[var]; &#125;&#125;;// 符号表达式// 非终端表达式class SymbolExpression : public Expression&#123;protected: // 两个操作数 Expression *left; Expression *right;public: SymbolExpression(Expression *left, Expression *right) : left(left), right(right) &#123; &#125;&#125;;class AddExpression : public SymbolExpression&#123;public: AddExpression(Expression *left, Expression *right) : SymbolExpression(left, right) &#123; &#125; int interpreter(map&lt;char, int&gt; var_map) override &#123; return (left-&gt;interpreter(var_map) + right-&gt;interpreter(var_map)); &#125;&#125;;class SubExpression : public SymbolExpression&#123;public: AddExpression(Expression *left, Expression *right) : SymbolExpression(left, right) &#123; &#125; int interpreter(map&lt;char, int&gt; var_map) override &#123; return (left-&gt;interpreter(var_map) - right-&gt;interpreter(var_map)); &#125;&#125;;Expression *analyize(map&lt;char, int&gt; var_map, string expr)&#123; int expr_len = expr.length(); Expression *left = nullptr, *right = nullptr; stack&lt;Expression*&gt; st; for (int i = 0; i &lt; expr_len; ++i) &#123; switch (expr[i]) &#123; case &#x27;+&#x27;: left = st.top(); right = new VarExpression(expr[++i]); st.push(new AddExpression(left, right)); break; case &#x27;-&#x27;; left = st.top(); right = new VarExpression(expr[++i]); st.push(new SubExpression(left, right)); break; default: st.push(new VarExpression(expr[i])); break; &#125; &#125; Expression* expr_final = st.top(); return expr_final;&#125;int main()&#123; string expr = &quot;a+b-c+d&quot;; map&lt;char, int&gt; var_map; var_map.insert(make_pair&lt;&gt;(&#x27;a&#x27;, 5)); var_map.insert(make_pair&lt;&gt;(&#x27;b&#x27;, 6)); var_map.insert(make_pair&lt;&gt;(&#x27;c&#x27;, 7)); var_map.insert(make_pair&lt;&gt;(&#x27;d&#x27;, 8)); Expression *expr_final = analyize(expr, var_map); int res = expr_final-&gt;interpreter(var_map); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【学习笔记】设计模式（二十二）命令模式","slug":"n-pattern-22","date":"2024-11-09T09:04:02.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/设计模式/n-pattern-22/","link":"","permalink":"https://cs0522.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/n-pattern-22/","excerpt":"行为变化：命令模式","text":"行为变化：命令模式 模式类型 行为变化 命令模式 将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。 使用场景 通过操作来参数化对象 用于代替包含行为的参数化 UI 元素的回调函数，此外还被用于对任务进行排序和记录操作历史记录等。 举例 使用命令模式 12345678910111213141516171819202122232425262728293031323334353637383940414243class Command &#123;public: virtual void execute() = 0;&#125;;class ConcreteCommand1 : public Command &#123;private: string arg;public: void execute() override &#123; // ... &#125;&#125;;class ConcreteCommand2 : public Command &#123;private: string arg;public: void execute() override &#123; // ... &#125;&#125;;class ConcreteCommands : public Command &#123;private: vector&lt;Command&gt; commands;public: void addCommand() &#123; ... &#125; void execute() override &#123; for command in commands: // ... &#125;&#125;class Invoker &#123;private: Command *comm;public: void Invoker(const Command *comm_) : comm(comm) &#123; &#125; void doSomething() &#123; this-&gt;comm-&gt;execute(); &#125;&#125;;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【学习笔记】设计模式（二十一）责任链","slug":"n-pattern-21","date":"2024-11-09T08:01:17.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/设计模式/n-pattern-21/","link":"","permalink":"https://cs0522.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/n-pattern-21/","excerpt":"数据结构：责任链","text":"数据结构：责任链 模式类型 数据结构 责任链 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。 每个检查步骤都可被抽取为仅有单个方法的类，并执行检查操作。请求及其数据则会被作为参数传递给该方法。 将这些处理者连成一条链。链上的每个处理者都有一个成员变量来保存对于下一处理者的引用。除了处理请求外，处理者还负责沿着链传递请求。请求会在链上移动，直至所有处理者都有机会对其进行处理。 处理者可以决定不再沿着链传递请求，这可高效地取消所有后续处理步骤。 使用场景 使用不同方式处理不同种类请求，请求顺序和类型预先未知 按顺序处理请求 举例 使用责任链 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Request &#123;&#125;;// ChainHandler 基类class ChainHandler &#123;private: // 成员变量，保存了责任链 ChainHandler *nextChain; void sendRequestToNextHandler(const Request &amp;req) &#123; if (!nextChain) nextChain-&gt;handle(req); &#125;protected: virtual bool canHandleRequest(const Request &amp;req) = 0; virtual void processRequest(const Request &amp;req) = 0;public: ChainHandler() &#123; nextChain = nullptr; &#125; void setNextChain(ChainHandler *next) &#123; nextChain = next; &#125; void handle(const Request &amp;req) &#123; if (canHandleRequest(req)) processRequest(req); else sendRequestToNextHandler(req); &#125;&#125;;// 具体 Handler 类class Handler1 : public ChainHandler &#123; // 重写虚函数 bool canHandleRequest() override &#123; ... &#125; void processRequest() override &#123; ... &#125;&#125;;class Handler2 : public ChainHandler &#123; // 重写虚函数 bool canHandleRequest() override &#123; ... &#125; void processRequest() override &#123; ... &#125;&#125;;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【学习笔记】设计模式（二十）迭代器","slug":"n-pattern-20","date":"2024-11-09T07:36:43.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/设计模式/n-pattern-20/","link":"","permalink":"https://cs0522.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/n-pattern-20/","excerpt":"数据结构：迭代器","text":"数据结构：迭代器 模式类型 数据结构 迭代器模式 将特定的数据结构封装在内部，在外部提供统一的接口，来实现与数据结构无关的访问。 数据结构内部变化各异，但希望在不暴露内部结构的同时，让外部客户“透明遍历”访问其中的元素。 使用场景 C++ STL 迭代器 举例 面向对象的迭代器 运行时多态： 12345678910111213141516171819202122232425262728293031323334353637383940414243template&lt;typename T&gt;class Iterator &#123;public: virtual void first() = 0; virtual void next() = 0; virtual T&amp; current() = 0;&#125;;template&lt;typename T&gt;class MyCollection &#123;public: Iterator&lt;T&gt; createIterator() &#123; return (new CollectionIterator&lt;T&gt;(this)) &#125;&#125;;template&lt;typenmae T&gt;class CollectionIterator : public Iterator&lt;T&gt; &#123; MyCollection&lt;T&gt; mc;public: CollectionIterator(const MyCollection&lt;T&gt; &amp;c): mc(c) &#123; &#125; void first() override &#123; &#125; void next() override &#123; &#125; T&amp; current() override &#123; &#125;&#125;;void MyAlgorithm() &#123; MyCollection&lt;int&gt; mc; Iterator&lt;int&gt; iter = mc.createIterator(); for (iter.first(); ...) &#123; // ... &#125;&#125;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【学习笔记】设计模式（十九）组合模式","slug":"n-pattern-19","date":"2024-11-09T03:47:09.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/设计模式/n-pattern-19/","link":"","permalink":"https://cs0522.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/n-pattern-19/","excerpt":"数据结构：组合模式","text":"数据结构：组合模式 模式类型 数据结构 组合模式 将对象组合成树形结构以表示&quot;部分-整体&quot;的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 简化树形结构中对象的处理，无论它们是单个对象还是组合对象。 解耦客户端代码与复杂元素的内部结构，使得客户端可以统一处理所有类型的节点。 使用场景 需要表示对象的层次结构，如文件系统或组织结构 图形界面 举例 使用组合模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Component &#123;protected: Component *parent_;public: virtual ~Component() &#123;&#125; void SetParent(Component *parent) &#123; this-&gt;parent_ = parent; &#125; Component *GetParent() const &#123; return this-&gt;parent_; &#125; virtual void Add(Component *component) &#123;&#125; virtual void Remove(Component *component) &#123;&#125; virtual bool IsComposite() const &#123; return false; &#125; virtual std::string Operation() const = 0;&#125;;// 树叶// 执行具体操作class Leaf : public Component &#123;public: std::string Operation() const override &#123; return &quot;Leaf&quot;; &#125;&#125;;// 树枝class Composite : public Component &#123;protected: std::list&lt;Component *&gt; children_;public: void Add(Component *component) override &#123; this-&gt;children_.push_back(component); component-&gt;SetParent(this); &#125; void Remove(Component *component) override &#123; children_.remove(component); component-&gt;SetParent(nullptr); &#125; bool IsComposite() const override &#123; return true; &#125; std::string Operation() const override &#123; std::string result; for (const Component *c : children_) &#123; if (c == children_.back()) &#123; result += c-&gt;Operation(); &#125; else &#123; result += c-&gt;Operation() + &quot;+&quot;; &#125; &#125; return &quot;Branch(&quot; + result + &quot;)&quot;; &#125;&#125;;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【学习笔记】设计模式（十四）代理模式","slug":"n-pattern-14","date":"2024-11-09T03:07:21.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/设计模式/n-pattern-14/","link":"","permalink":"https://cs0522.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/n-pattern-14/","excerpt":"接口隔离：代理模式","text":"接口隔离：代理模式 模式类型 接口隔离 代理模式 为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。 在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。 代理必须和真实对象使用相同接口，才能伪装成服务对象。 代理模式建议新建一个与原服务对象接口相同的代理类， 然后更新应用以将代理对象传递给所有原始对象客户端。 代理类接收到客户端请求后会创建实际的服务对象， 并将所有工作委派给它。 如果需要在类的主要业务逻辑前后执行一些工作， 你无需修改类就能完成这项工作。 由于代理实现的接口与原类相同， 因此你可将其传递给任何一个使用实际服务对象的客户端。 使用场景 想在访问一个类时做一些控制 延迟初始化 远程代理 缓存代理 记录日志请求 举例 使用代理模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 抽象接口class Subject &#123;public: virtual void Request() const = 0;&#125;;// 真实对象class RealSubject : public Subject &#123;public: void Request() const override &#123; std::cout &lt;&lt; &quot;RealSubject: Handling request.\\n&quot;; &#125;&#125;;// 代理类class Proxy : public Subject &#123;private: RealSubject *real_subject_; bool CheckAccess() const &#123; // Some real checks should go here. std::cout &lt;&lt; &quot;Proxy: Checking access prior to firing a real request.\\n&quot;; return true; &#125; void LogAccess() const &#123; std::cout &lt;&lt; &quot;Proxy: Logging the time of request.\\n&quot;; &#125;public: Proxy(RealSubject *real_subject) : real_subject_(new RealSubject(*real_subject)) &#123; &#125; // 与真实对象实现相同的接口 void Request() const override &#123; if (this-&gt;CheckAccess()) &#123; this-&gt;real_subject_-&gt;Request(); this-&gt;LogAccess(); &#125; &#125;&#125;;// client 端执行void ClientCode(const Subject &amp;subject) &#123; // ... subject.Request(); // ...&#125;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【学习笔记】设计模式（十三）门面模式","slug":"n-pattern-13","date":"2024-11-08T12:36:11.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/设计模式/n-pattern-13/","link":"","permalink":"https://cs0522.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/n-pattern-13/","excerpt":"接口隔离：门面模式","text":"接口隔离：门面模式 模式类型 接口隔离 门面模式 某些接口之间添加一层间接（稳定）接口，隔离本来紧密相互关联的接口。 简化外部程序与内部系统间的交互接口，将外部程序与内部系统的依赖相互解耦。 内部组件应该是“相互耦合关系较大的一系列组件”。 使用场景 为子系统中的一组接口提供一个一致（稳定）的界面。定义一个高层接口，使得子系统更加容易使用（复用）。 举例 电脑","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【学习笔记】设计模式（十一）单例模式","slug":"n-pattern-11","date":"2024-11-08T11:48:22.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/设计模式/n-pattern-11/","link":"","permalink":"https://cs0522.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/n-pattern-11/","excerpt":"对象性能：单例模式。","text":"对象性能：单例模式。 模式类型 对象性能 单例模式 可能会存在一种特殊的类，需要保证他们在系统中只能存在一个实例，才能确保逻辑的正确性。 单例模式确保一个类只有一个实例，并提供了一个全局访问点来访问该实例。 单例类只能有一个实例，必须自己创建自己的唯一实例，且必须给所有其他对象提供这一实例。 使用场景 多线程多进程 生成唯一序列号 WEB 中的计数器，避免每次刷新都在数据库中增加计数，先缓存起来 创建消耗资源过多的对象，如 I/O 与数据库连接等 举例 单例模式 构造函数私有化； 静态成员指针变量； 提供 static 公有的 getInstance() 函数； 12345678910111213141516171819202122232425262728293031323334353637383940414243class Singleton &#123;private: // 构造函数私有化 Singleton() &#123;&#125;public: // 静态成员指针变量 static Singleton* m_instance; // 公有 get 函数 static Singleton* getInstance();&#125;;Singleton::m_instance = nullptr;// 单线程版Singleton* Singleton::getInstance() &#123; if (!m_instance) m_instance = new Singleton(); return m_instance;&#125;// 多线程锁Singleton* Singleton::getInstance() &#123; Lock lock; if (!m_instance) m_instance = new Singleton(); return m_instance;&#125;// 多线程双检查锁// 注意 C++ 内存序问题// memory reorder// 编译器的优化，导致指令乱序执行Singleton* Singleton::getInstance() &#123; if (!m_instance) &#123; Lock lock; if (!m_instance) m_instance = new Singleton(); &#125; return m_instance;&#125;// 变量添加 volatile 关键字","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【学习笔记】一图弄懂各种协议、总线、接口的关系","slug":"n-express-bus-interface","date":"2024-11-03T04:02:05.000Z","updated":"2025-01-17T18:57:47.125Z","comments":true,"path":"notes/存储/n-express-bus-interface/","link":"","permalink":"https://cs0522.github.io/notes/%E5%AD%98%E5%82%A8/n-express-bus-interface/","excerpt":"一图弄懂各种协议、总线、接口的关系。","text":"一图弄懂各种协议、总线、接口的关系。 协议、总线、接口 SSD 协议、接口的变迁","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"存储","slug":"notes/存储","permalink":"https://cs0522.github.io/categories/notes/%E5%AD%98%E5%82%A8/"}],"tags":[{"name":"存储","slug":"存储","permalink":"https://cs0522.github.io/tags/%E5%AD%98%E5%82%A8/"}]},{"title":"【刷题日记】二叉树-从前序与中序遍历序列构造二叉树-L105-Medium","slug":"p-tree-constructInPre-L105","date":"2024-11-02T12:10:44.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/二叉树/p-tree-constructInPre-L105/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-constructInPre-L105/","excerpt":"给定两个整数数组 preorder 和 inorder，其中 preorder 是二叉树的先序遍历，inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。","text":"给定两个整数数组 preorder 和 inorder，其中 preorder 是二叉树的先序遍历，inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。 思路 思路 1 同 L106。 学习点 前序遍历第一个节点为根节点；以此来分割中序遍历。 代码 思路 1： 12345678910111213141516171819202122232425class Solution &#123;public: TreeNode* build_tree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder, int inorder_start, int inorder_end) &#123; if ((inorder_end - inorder_start) == 0) return nullptr; // 前序遍历的最后一个节点为当前的根节点 int root_val = preorder[0]; preorder.erase(preorder.begin()); TreeNode* root = new TreeNode(root_val); // 前序遍历顺序：根左右，反构造时先构造左节点 // 分割中序遍历 vector&lt;int&gt;::iterator root_iter = find(inorder.begin() + inorder_start, inorder.begin() + inorder_end, root_val); int root_index = root_iter - inorder.begin(); root-&gt;left = build_tree(preorder, inorder, inorder_start, root_index); root-&gt;right = build_tree(preorder, inorder, root_index + 1, inorder_end); return root; &#125; TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; return build_tree(preorder, inorder, 0, inorder.size()); &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-从中序与后序遍历序列构造二叉树-L106-Medium","slug":"p-tree-constructInPost-L106","date":"2024-11-02T11:16:47.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/二叉树/p-tree-constructInPost-L106/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-constructInPost-L106/","excerpt":"给定两个整数数组 inorder 和 postorder，其中 inorder 是二叉树的中序遍历，postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。","text":"给定两个整数数组 inorder 和 postorder，其中 inorder 是二叉树的中序遍历，postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 思路 思路 1 递归构建树，每层递归返回构建的根节点，递归中构建根节点的左右子节点。后序遍历中最后一个节点为当前递归层的根节点，在中序遍历中找到这个根节点（给定条件 树中没有重复元素），然后中序遍历中这个根节点的左边都为根节点的左子树，根节点的右边都为根节点的右子树，因此在准备递归构造左子树和右子树前，删除后序遍历的最后一个节点（为当前根节点，已经用过），将中序遍历分割为左右两部分，然后两部分分别作为参数、和后序遍历一起传入到下一层递归中。递归终止条件即为中序遍历已经空了（不判断后序遍历，因为左子树构造完但右子树可能没构造完）。 学习点 后序遍历最后一个节点为根节点；以此来分割中序遍历。 代码 思路 1： 123456789101112131415161718192021class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; // 空节点 if (!inorder.size()) return nullptr; // 后序遍历的最后一个节点为当前的根节点 int root_val = postorder[postorder.size() - 1]; postorder.pop_back(); TreeNode* root = new TreeNode(root_val); // 后序遍历顺序：左右根，反构造时先构造右节点 vector&lt;int&gt;::iterator root_iter = find(inorder.begin(), inorder.end(), root_val); vector&lt;int&gt; left_inorder(inorder.begin(), root_iter); vector&lt;int&gt; right_inorder(root_iter + 1, inorder.end()); root-&gt;right = buildTree(right_inorder, postorder); root-&gt;left = buildTree(left_inorder, postorder); return root; &#125;&#125;; 思路 1 优化版： 不需要每次新构建 vectors，直接传入分割的下标。 1234567891011121314151617181920212223242526class Solution &#123;public: TreeNode * build_tree(vector&lt;int&gt; &amp;inorder, vector&lt;int&gt; &amp;postorder, int inorder_start, int inorder_end) &#123; // 空节点 if ((inorder_end - inorder_start) == 0) return nullptr; // 后序遍历的最后一个节点为当前的根节点 int root_val = postorder[postorder.size() - 1]; postorder.pop_back(); TreeNode *root = new TreeNode(root_val); // 分割中序遍历 vector&lt;int&gt;::iterator root_iter = find(inorder.begin() + inorder_start, inorder.begin() + inorder_end, root_val); int root_index = (root_iter - inorder.begin()); root-&gt;right = build_tree(inorder, postorder, root_index + 1, inorder_end); root-&gt;left = build_tree(inorder, postorder, inorder_start, root_index); return root; &#125; TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; return build_tree(inorder, postorder, 0, inorder.size()); &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-路径总和-L112-Easy","slug":"p-tree-pathSum-L112","date":"2024-11-02T09:14:40.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/二叉树/p-tree-pathSum-L112/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-pathSum-L112/","excerpt":"给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。","text":"给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 思路 思路 1 不需要记录每个路径的总和，只需要判断即可。因此在递归的时候，targetSum - current_node-&gt;val。路径结束的节点为叶子节点，而只有左孩子或右孩子的节点不是路径结束的节点，因此要注意这里的处理：只有左右节点都为空时，返回节点值和路径和的判断；若有一个不为空，则继续递归，其中节点为空的路径会返回 false。而在递归左右节点的时候，采用 ||，只要有一个路径满足即可返回 true。 学习点 代码 123456789101112class Solution &#123;public: bool hasPathSum(TreeNode* root, int targetSum) &#123; if (!root) return false; // 必须是叶子节点 if (!root-&gt;left &amp;&amp; !root-&gt;right) return (root-&gt;val == targetSum); return (hasPathSum(root-&gt;left, targetSum - root-&gt;val) || hasPathSum(root-&gt;right, targetSum - root-&gt;val)); &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-找树左下角的值-L513-Medium","slug":"p-tree-bottomLeft-L513","date":"2024-10-31T08:38:04.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/p-tree-bottomLeft-L513/","link":"","permalink":"https://cs0522.github.io/practices/p-tree-bottomLeft-L513/","excerpt":"给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。","text":"给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 思路 思路 1 层序遍历，最后一层的第一个节点即为最后一层的最左边节点，因此记录遍历每层时的第一个节点。 学习点 代码 123456789101112131415161718192021222324252627282930class Solution &#123;public: int findBottomLeftValue(TreeNode* root) &#123; // 层序遍历 // 记录遍历的每层的第一个 queue&lt;TreeNode*&gt; qe; qe.push(root); int first_of_layer = root-&gt;val; while (!qe.empty()) &#123; int node_num = qe.size(); for (int i = 0; i &lt; node_num; ++i) &#123; TreeNode *tmp = qe.front(); qe.pop(); if (tmp-&gt;left) qe.push(tmp-&gt;left); if (tmp-&gt;right) qe.push(tmp-&gt;right); // 记录每层第一个 if (i == 0) first_of_layer = tmp-&gt;val; &#125; &#125; return first_of_layer; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"【刷题日记】二叉树-左叶子之和-L404-Easy","slug":"p-tree-sumOfLeftLeaves-L404","date":"2024-10-31T07:34:56.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/p-tree-sumOfLeftLeaves-L404/","link":"","permalink":"https://cs0522.github.io/practices/p-tree-sumOfLeftLeaves-L404/","excerpt":"给定二叉树的根节点 root ，返回所有左叶子之和。","text":"给定二叉树的根节点 root ，返回所有左叶子之和。 思路 思路 1 用一个标记来标识当前节点是否为左子节点（通过上一个父节点传递标记参数）。如果为左子节点且已经没有了左右子节点，则该左子节点为左叶子节点。 思路 2 不使用标记。通过父节点来判断父节点的左子节点是否为叶子节点。 学习点 使用标记来标识。 代码 思路 1： 1234567891011121314151617181920class Solution &#123;public: void cal_left_leaves(TreeNode *root, int &amp;res, bool is_left) &#123; if (!root) return; cal_left_leaves(root-&gt;left, res, true); cal_left_leaves(root-&gt;right, res, false); // 叶子节点且为左 if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; is_left) res += root-&gt;val; &#125; int sumOfLeftLeaves(TreeNode* root) &#123; int res = 0; cal_left_leaves(root, res, false); return res; &#125;&#125;; 思路 2： 12345678910111213141516class Solution &#123;public: int sumOfLeftLeaves(TreeNode* root) &#123; if (root == NULL) return 0; if (root-&gt;left == NULL &amp;&amp; root-&gt;right== NULL) return 0; int leftValue = sumOfLeftLeaves(root-&gt;left); // 左 if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; // 左子树就是一个左叶子的情况 leftValue = root-&gt;left-&gt;val; &#125; int rightValue = sumOfLeftLeaves(root-&gt;right); // 右 int sum = leftValue + rightValue; // 中 return sum; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"【刷题日记】二叉树-二叉树的所有路径-L257-Easy","slug":"p-tree-treePaths-L257","date":"2024-10-31T02:51:08.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/p-tree-treePaths-L257/","link":"","permalink":"https://cs0522.github.io/practices/p-tree-treePaths-L257/","excerpt":"给你一个二叉树的根节点 root ，按任意顺序，返回所有从根节点到叶子节点的路径。 叶子节点 是指没有子节点的节点。","text":"给你一个二叉树的根节点 root ，按任意顺序，返回所有从根节点到叶子节点的路径。 叶子节点 是指没有子节点的节点。 思路 思路 1 通过结果集来获取当前的遍历路径。按照深度优先遍历方法，当遍历到一个节点后，就弹出队列尾部的路径，然后加上当前节点的路径。队列尾部最后一个路径就是当前正在遍历的路径。之后如果左分支或右分支存在，则将当前路径压入队列；如果左右分支都不存在，也需要将当前路径压入队列。 问题在于存在多次的 vector 的 push_back 和 pop_back 操作。 思路 2 通过函数参数传递当前的遍历路径。将回溯隐藏在函数参数 path + &quot;-&gt;&quot; 中，这样可以使左子树遍历完毕后，path 回溯到当前节点，然后继续遍历右子树。 学习点 代码 思路 1： 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: void getPaths(TreeNode* root, vector&lt;string&gt; &amp;res) &#123; // 递归终止条件 if (!root) return; string curr_path; // 取出当前路径 if (!res.size()) curr_path = to_string(root-&gt;val); else &#123; curr_path = res[res.size() - 1] + &quot;-&gt;&quot; + to_string(root-&gt;val); res.pop_back(); &#125; // 压入当前路径 if (root-&gt;left) &#123; res.push_back(curr_path); getPaths(root-&gt;left, res); &#125; if (root-&gt;right) &#123; res.push_back(curr_path); getPaths(root-&gt;right, res); &#125; if (!root-&gt;left &amp;&amp; !root-&gt;right) res.push_back(curr_path); &#125; vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; res; getPaths(root, res); return res; &#125;&#125;; 思路 2： 1234567891011121314151617181920212223242526class Solution &#123;private: void traversal(TreeNode* cur, string path, vector&lt;string&gt;&amp; result) &#123; path += to_string(cur-&gt;val); // 中 if (cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL) &#123; result.push_back(path); return; &#125; // 回溯隐藏在 path + &quot;-&gt;&quot; 中 if (cur-&gt;left) traversal(cur-&gt;left, path + &quot;-&gt;&quot;, result); // 左 if (cur-&gt;right) traversal(cur-&gt;right, path + &quot;-&gt;&quot;, result); // 右 &#125;public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; result; string path; if (root == NULL) return result; traversal(root, path, result); return result; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"【刷题日记】二叉树-平衡二叉树-L110-Easy","slug":"p-tree-judgeBalancedTree-L110","date":"2024-10-30T07:12:53.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/二叉树/p-tree-judgeBalancedTree-L110/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-judgeBalancedTree-L110/","excerpt":"给定一个二叉树，判断它是否是平衡二叉树","text":"给定一个二叉树，判断它是否是平衡二叉树 思路 思路 1 直接递归判断左子树和右子树是否是平衡二叉树，然后再判断以当前节点为根节点的树是否平衡 问题在于时间复杂度高，存在子树的高度多次计算的情况 思路 2 将判断的逻辑加入到 calHight() 函数中，当计算得到非平衡时，设置特殊返回值，从而进行剪枝。 学习点 当其中一个子树为非平衡时，设置特殊返回值，进行剪枝从而减少计算开销。 代码 思路 1： 12345678910111213141516171819class Solution &#123;public: int calHight(TreeNode* root) &#123; if (!root) return 0; return (max(calHight(root-&gt;left), calHight(root-&gt;right)) + 1); &#125; bool isBalanced(TreeNode* root) &#123; if (!root) return true; // 分别递归判断左子树和右子树是否平衡，然后判断当前树是否平衡 if (isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right)) &#123; return (fabs(calHight(root-&gt;left) - calHight(root-&gt;right)) &lt;= 1); &#125; return false; &#125;&#125;; 思路 2： 123456789101112131415161718class Solution &#123;public: int calHight(TreeNode* root) &#123; if (!root) return 0; int left_hight = calHight(root-&gt;left); int right_hight = calHight(root-&gt;right); if (left_hight == -1 || right_hight == -1) return -1; return (fabs(left_hight - right_hight) &lt;= 1 ? max(left_hight, right_hight) + 1 : -1); &#125; bool isBalanced(TreeNode* root) &#123; return (calHight(root) != -1); &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-完全二叉树的节点个数-L222-Easy","slug":"p-tree-countNodes-L222","date":"2024-10-30T07:10:45.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/二叉树/p-tree-countNodes-L222/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-countNodes-L222/","excerpt":"给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。","text":"给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 思路 层序遍历。 学习点 代码 123456789101112131415161718192021222324252627class Solution &#123;public: int countNodes(TreeNode* root) &#123; queue&lt;TreeNode*&gt; qe; if (root) qe.push(root); // 计数 int node_cnt = 0; while (!qe.empty()) &#123; int node_num = qe.size(); for (int i = 0; i &lt; node_num; ++i) &#123; TreeNode *tmp = qe.front(); qe.pop(); // 计数 ++node_cnt; if (tmp-&gt;left) qe.push(tmp-&gt;left); if (tmp-&gt;right) qe.push(tmp-&gt;right); &#125; &#125; return node_cnt; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-N叉树的最大深度-L559-Easy","slug":"p-tree-maxLengthofN-L559","date":"2024-10-30T06:57:44.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/二叉树/p-tree-maxLengthofN-L559/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-maxLengthofN-L559/","excerpt":"给定一个 N 叉树，找到其最大深度。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。 N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。","text":"给定一个 N 叉树，找到其最大深度。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。 N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。 思路 同 L104。 学习点 代码 123456789101112131415161718192021222324252627class Solution &#123;public: int maxDepth(Node* root) &#123; int depth = 0; queue&lt;Node*&gt; qe; if (root) qe.push(root); while (!qe.empty()) &#123; int node_num = qe.size(); for (int i = 0; i &lt; node_num; i++) &#123; auto tmp = qe.front(); qe.pop(); for (int j = 0; j &lt; tmp-&gt;children.size(); ++j) &#123; if (tmp-&gt;children[j]) qe.push(tmp-&gt;children[j]); &#125; &#125; ++depth; &#125; return depth; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-对称二叉树-L101-Easy","slug":"p-tree-symmetric-L101","date":"2024-10-30T06:32:52.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/p-tree-symmetric-L101/","link":"","permalink":"https://cs0522.github.io/practices/p-tree-symmetric-L101/","excerpt":"给你一个二叉树的根节点 root ，检查它是否轴对称。（关于根节点轴对称）","text":"给你一个二叉树的根节点 root ，检查它是否轴对称。（关于根节点轴对称） 思路 思路 1 利用 L226 的翻转二叉树，将根节点的左子树翻转后与右子树一一比较节点，如果一样，则是关于根节点轴对称。根节点为空则不是轴对称。 思路 2 不需要考虑翻转，直接一个遍历左边，一个遍历右边，然后比较是否相等。 学习点 代码 思路 1： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: // 比较两个树是否相同 bool compareTree(TreeNode *tree1, TreeNode *tree2) &#123; if (!tree1 &amp;&amp; !tree2) return true; if (!tree1 || !tree2) return false; if (tree1-&gt;val != tree2-&gt;val) return false; return (compareTree(tree1-&gt;left, tree2-&gt;left) &amp;&amp; compareTree(tree1-&gt;right, tree2-&gt;right)); &#125; TreeNode *invertTree(TreeNode *root) &#123; // 递归终止条件 if (!root) return root; // 递归子树 invertTree(root-&gt;left); invertTree(root-&gt;right); TreeNode *tmp_node = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = tmp_node; return root; &#125; bool isSymmetric(TreeNode* root) &#123; if (!root) return false; // 先反转左子树 TreeNode *invertLeft = invertTree(root-&gt;left); // 比较左右子树是否一致 bool res = compareTree(invertLeft, root-&gt;right); return res; &#125;&#125;; 思路 2： 12345678910111213141516171819202122class Solution &#123;public: // 比较两个树是否相同 bool compareTree(TreeNode *tree1, TreeNode *tree2) &#123; if (!tree1 &amp;&amp; !tree2) return true; if (!tree1 || !tree2) return false; if (tree1-&gt;val != tree2-&gt;val) return false; return (compareTree(tree1-&gt;left, tree2-&gt;right) &amp;&amp; compareTree(tree1-&gt;right, tree2-&gt;left)); &#125; bool isSymmetric(TreeNode* root) &#123; if (!root) return false; // 比较两个树是否一致 return compareTree(root-&gt;left, root-&gt;right); &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"【刷题日记】二叉树-翻转二叉树-L226-Easy","slug":"p-tree-invertTree-L226","date":"2024-10-30T02:26:03.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/p-tree-invertTree-L226/","link":"","permalink":"https://cs0522.github.io/practices/p-tree-invertTree-L226/","excerpt":"给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。","text":"给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 思路 肯定是用递归。刚开始考虑到左右子树存在 nullptr 的情况，不过发现这种情况也包含在正常情况中了，无需特殊考虑。 学习点 代码 12345678910111213141516171819class Solution&#123;public: TreeNode *invertTree(TreeNode *root) &#123; // 递归终止条件 if (!root) return root; // 递归子树 invertTree(root-&gt;left); invertTree(root-&gt;right); TreeNode *tmp_node = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = tmp_node; return root; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"【学习笔记】Make、CMake 基本使用","slug":"n-make-cmake","date":"2024-10-17T11:18:51.000Z","updated":"2025-01-17T18:57:47.125Z","comments":false,"path":"notes/C/n-make-cmake/","link":"","permalink":"https://cs0522.github.io/notes/C/n-make-cmake/","excerpt":"Make、CMake 基本使用，到能看懂项目中的 Makefile 和 CMakeLists.txt，并按需修改代码。","text":"Make、CMake 基本使用，到能看懂项目中的 Makefile 和 CMakeLists.txt，并按需修改代码。","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"C++","slug":"notes/C","permalink":"https://cs0522.github.io/categories/notes/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://cs0522.github.io/tags/Linux/"},{"name":"CMake","slug":"CMake","permalink":"https://cs0522.github.io/tags/CMake/"}]},{"title":"【学习笔记】SPDK（六）：CloudLab 脚本自动化部署 SPDK","slug":"n-spdk-06","date":"2024-10-17T02:22:09.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"notes/存储/n-spdk-06/","link":"","permalink":"https://cs0522.github.io/notes/%E5%AD%98%E5%82%A8/n-spdk-06/","excerpt":"记录在 CloudLab 上通过 sh 脚本自动化部署 SPDK with latency_test。","text":"记录在 CloudLab 上通过 sh 脚本自动化部署 SPDK with latency_test。 1. 脚本介绍 名称 使用位置 作用 setup_all_nodes.sh 本地 整合所有功能脚本；遍历所有节点并配置 setup_rdma.sh 远程 配置 RDMA 环境 setup_spdk_with_latency_test.sh 远程 搭建添加了 latency_test 的 SPDK 环境 configure_host.sh 远程 配置 Host 端 configure_target.sh 远程 配置 Target 端 run_perf_test.sh 本地 / 远程 运行 perf、perf_rep get_run_output.sh 本地 / 远程 获取所有节点的输出结果 2. 脚本使用方法 2.1. 工作路径 由于 CloudLab 服务器要求，需要持久化存储的文件要保存在 /opt或 /usr/local文件夹下，这里选择 /opt。 远程机器的 SPDK 根目录：/opt/Workspace/spdk-24.05.x 远程机器的输出文件目录：/opt/Workspace/output 本地机器的脚本存放目录：./setup 本地机器运行脚本后的输出文件目录： ./setup/run_output，存放获取远程机器的输出文件； ./setup/setup_output，存放 setup 过程中的文件和输出，包括 nodes_local_ip.txt、setup_all_nodes.log等。 2.2. 脚本参数 setup_all_nodes.sh ./setup/setup_all_nodes.sh &lt;is_mlnx&gt; &lt;is_100g&gt; &lt;cloudlab_username&gt; &lt;node_num&gt; [hostnames...] is_mlnx 值为 0 或 1。 是否为 Mellanox 网卡。CloudLab 环境上满足实验要求的 NIC 均为 Mellanox 网卡。 is_100g 值为 0 或 1。 网速是否为 100 Gbps，是为 1，mtu = 9000；否为 0，mtu = 1500；通过 mtu 的大小来获取目标网口的 IP。 cloudlab_username 用户名：CS0522，需要大写。 node_num 节点个数，1 Host + 多 Target。 hostnames... 节点的主机名。值如 amd263.utah.cloudlab.us，多值中间空格分隔，在 CloudLab 实验界面获取。其中输入的第一个节点默认为 Host，其他为 Target。 setup_rdma.sh ./setup/setup_rdma.sh &lt;is_mlnx&gt; &lt;is_100g&gt; is_mlnx 值为 0 或 1。 是否为 Mellanox 网卡。CloudLab 环境上满足实验要求的 NIC 均为 Mellanox 网卡。 is_100g 值为 0 或 1。 网速是否为 100 Gbps，是为 1，mtu = 9000；否为 0，mtu = 1500；通过 mtu 的大小来获取目标网口的 IP。 setup_spdk_with_latency_test.sh ./setup/setup_spdk_with_latency_test.sh &lt;skip_verify&gt; skip_verify 值为 0 或 1。 是否跳过第一次编译和单元测试，在没有开启 LATENCY_LOG 宏的情况下。开启可以验证克隆的 SPDK 版本是否正确、能否正常运行。 configure_host.sh ./setup/configure_host.sh 配置 Host 端。 configure_target.sh ./setup/configure_target.sh &lt;is_100g&gt; is_100g 值为 0 或 1。 网速是否为 100 Gbps，是为 1，mtu = 9000；否为 0，mtu = 1500；通过 mtu 的大小来获取目标网口的 IP。 run_perf_test.sh ./setup/run_perf_test.sh &lt;cloudlab_username&gt; &lt;hostname&gt; &lt;run_app&gt; &lt;node_num&gt; &lt;file_path&gt; &lt;io_queue_depth&gt; &lt;io_size&gt; &lt;workload&gt; &lt;run_time&gt; cloudlab_username CS0522。 hostname Host 的主机名。值如 amd263.utah.cloudlab.us。 run_app 值为 perf或 perf_rep。 node_num 所有节点个数。 file_path 保存 Target 节点的 local IP 文件，即建立 RDMA 连接的网口。 io_queue_depth perf 参数，值可为 256。 io_size perf 参数，值可为 4096。 workload perf 参数，值可为 randread、randwrite、randrw，randrw 会自动添加 -M 50。 run_time perf 参数，值的单位为秒。 get_run_output.sh ./setup/get_run_output.sh &lt;cloudlab_username&gt; &lt;node_num&gt; [hostnames...] cloudlab_username CS0522。 node_num 所有节点个数。 hostnames... 所有节点主机名。 2.3. 全自动配置运行 本地机器运行 ./setup/setup_all_nodes.sh。 12# example./setup/setup_all_nodes.sh 1 1 CS0522 2 amd263.utah.cloudlab.us amd250.utah.cloudlab.us 运行 perf 和 perf_rep，通过本地机器运行 run_perf_test.sh 并通过 get_run_output.sh 获取结果。 12# example./setup/run_perf_test.sh CS0522 amd263.utah.cloudlab.us perf 2 ./setup/setup_output/nodes_local_ip.txt 256 4096 randwrite 5 2.4. 半自动配置运行 远程机器分别运行 ./setup/*.sh。 远程机器 clone SPDK v24.05.x 至目录 /opt/Workspace 下； 按照 SPDK 说明更新子模块； 删除原有 .git 仓库，新建仓库，并将仓库与 nof-rep 仓库关联； git fetch 并切换 git checkout 至 latency_test 分支； 运行 ./setup/setup_rdma.sh 1 1； 运行 ./setup/setup_spdk_with_latency_test.sh 1； Host 端运行 ./setup/configure_host.sh； Target 端运行 ./setup/configure_target.sh； 运行 perf 和 perf_rep。","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"存储","slug":"notes/存储","permalink":"https://cs0522.github.io/categories/notes/%E5%AD%98%E5%82%A8/"}],"tags":[{"name":"存储","slug":"存储","permalink":"https://cs0522.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"SPDK","slug":"SPDK","permalink":"https://cs0522.github.io/tags/SPDK/"}]},{"title":"【学习笔记】Linux Shell 脚本编程","slug":"n-shell","date":"2024-10-16T11:56:02.000Z","updated":"2025-01-17T18:57:47.133Z","comments":false,"path":"notes/Shell/n-shell/","link":"","permalink":"https://cs0522.github.io/notes/Shell/n-shell/","excerpt":"项目中用到 Shell 脚本的编写，边学边用。","text":"项目中用到 Shell 脚本的编写，边学边用。 基本语法 详见 Shell 教程 | 菜鸟教程 使用小结 运行 123456# 1. 调用 sh 命令（不推荐）sh ./setup_rdma.sh# 2. 修改权限为可执行sudo chmod 777 ./setup_rdma.sh./setup_rdma.sh 多行注释 123:&lt;&lt;EOF这是多行注释EOF 特殊变量 特殊变量名 作用 $0 脚本的名称 $1, $2, ..., $&#123;10&#125;, ... 传递给脚本的参数 $# 传递给脚本的参数数量 $? 上一个命令的退出状态 $* 以一个单字符串显示所有向脚本传递的参数。如 &quot;$*&quot;，输出 &quot;$1 $2 … $n&quot;的形式输出所有参数。 拼接字符串 1234your_name=&quot;runoob&quot;# 使用双引号拼接greeting=&quot;hello, &quot;$your_name&quot; !&quot;greeting_1=&quot;hello, $&#123;your_name&#125; !&quot; 获取字符串长度 123string=&quot;abcd&quot;echo $&#123;#string&#125; # 输出 4echo $&#123;#string[0]&#125; # 输出 4 提取子字符串 12string=&quot;runoob is a great site&quot;echo $&#123;string:1:4&#125; # 输出 unoo 查找子字符串 12string=&quot;runoob is a great site&quot;echo `expr index &quot;$string&quot; io` # 输出 4 关联数组（类似于 map） 1234567declare -A sitesite[&quot;google&quot;]=&quot;www.google.com&quot;site[&quot;runoob&quot;]=&quot;www.runoob.com&quot;site[&quot;taobao&quot;]=&quot;www.taobao.com&quot;# 使用echo $&#123;site[&quot;runoob&quot;]&#125; 获取数组所有元素和键 123456789# @ 或 * 号获取所有元素# ! 获取所有键my_array[0]=Amy_array[1]=Bmy_array[2]=Cmy_array[3]=Decho &quot;数组的元素为: $&#123;my_array[@]&#125;&quot;echo &quot;数组的键为: $&#123;!my_array[@]&#125;&quot; 获取数组长度 1echo &quot;数组元素个数为: $&#123;#my_array[@]&#125;&quot; 算数运算 expr 命令。 表达式和运算符之间要有空格，完整的表达式要被 ` ` 包含。 1234567num=5# 自增num=`expr $&#123;num&#125; + 1`# 自减num=`expr $&#123;num&#125; - 1` echo 开启转义 12345echo -e &quot;OK! \\n&quot; # -e 开启转义echo &quot;It is a test&quot;echo -e &quot;OK! \\c&quot; # -e 开启转义 \\c 不换行echo &quot;It is a test&quot; if...else...fi 判断 括号和里面的条件之间一定要有空格。 1234567891011# -gt, -lt, -ne, -eq# -z: 是否等于 0if [ $a -eq $b ]; then echo &quot;a 等于 b&quot;elif [ $a -gt $b ]; then echo &quot;a 大于 b&quot;elif [ $a -lt $b ]; then echo &quot;a 小于 b&quot;else echo &quot;没有符合的条件&quot;fi 遇到逻辑运算符或 ==, !=, &gt;, &lt;, &lt;=, &gt;= 时，需要双括号。 12345if [[ $a -eq $b ]] &amp;&amp; [[ -z $b ]]; then ...elif [[ ... ]] || [[ ... ]]; then ...fi while 循环 123while(( $&#123;curr_node&#125;&lt;=$&#123;node_num&#125; )); do ...done 函数内局部变量 local 关键字。 123function func() &#123; local var1=1&#125; Here 文档 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。比如 ssh 等。 ENDSSH 分隔符可以自定义，分隔符之间的命令则是需要执行的部分。可以传入参数。 12345678910111213141516ssh $&#123;ssh_arg&#125; $&#123;cloudlab_username&#125;@$&#123;hostname&#125; &lt;&lt; ENDSSH sudo su cd $&#123;workspace_dir&#125; git clone --branch v$&#123;spdk_version&#125; $&#123;spdk_repo&#125; ./spdk-$&#123;spdk_version&#125; &amp;&amp; cd ./spdk-$&#123;spdk_version&#125; git submodule update --init rm -rf ./.git &amp;&amp; git init exitENDSSH# 这里 res 获取 ssh 执行后的输出结果# 其中命令中的 $（不是需要传入外部参数）需要转义res=$( ssh $&#123;ssh_arg&#125; $&#123;cloudlab_username&#125;@$&#123;hostname&#125; &lt;&lt; ENDSSH ifconfig | grep -A 1 &#x27;$&#123;mtu&#125;&#x27; | grep &#x27;inet&#x27; | awk &#x27;&#123;print \\$2&#125;&#x27;ENDSSH ) awk 截取参数 -F 参数可以指定分隔符。 12# 指定分隔符为 &#x27;:&#x27;awk -F: &#x27;&#123;print $2&#125;&#x27;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"Shell","slug":"notes/Shell","permalink":"https://cs0522.github.io/categories/notes/Shell/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cs0522.github.io/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://cs0522.github.io/tags/Shell/"}]},{"title":"【学习笔记】SPDK（五）：实现监控逻辑和功能测试","slug":"n-spdk-05","date":"2024-09-25T02:04:41.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"notes/存储/n-spdk-05/","link":"","permalink":"https://cs0522.github.io/notes/%E5%AD%98%E5%82%A8/n-spdk-05/","excerpt":"修改 perf 中的监控功能，进行功能测试，分析存在的问题。","text":"修改 perf 中的监控功能，进行功能测试，分析存在的问题。 环境准备 Ubuntu 22.04 虚拟机 x4 dev1，作为 Host 端，ip：192.168.246.129 dev2，作为 Target0，ip：192.168.246.130 dev3，作为 Target1，ip：192.168.246.131 dev4，作为 Target2，ip：192.168.246.132 8 块虚拟硬盘： SATA x4：用于安装 Ubuntu NVMe x4：用于绑定 SPDK perf 同时测试多个 Target、设置指定数目 QP 建立环境的操作见 【学习笔记】SPDK（二）：SPDK NVMe over RDMA 部署。 Host 端： 123456789101112131415161718./build/bin/spdk_nvme_perf -r &#x27;trtype:rdma adrfam:IPv4 traddr:192.168.246.130 trsvcid:4420&#x27; -r &#x27;trtype:rdma adrfam:IPv4 traddr:192.168.246.131 trsvcid:4420&#x27; -r &#x27;trtype:rdma adrfam:IPv4 traddr:192.168.246.132 trsvcid:4420&#x27; -q 256 -o 4096 -w randrw -M 50 -t 5 -P 1 -G -LL -l --transport-stats# 一些参数含义# -r, --transport &lt;fmt&gt; Transport ID for local PCIe NVMe or NVMeoF# 对于同时测试多块盘，只需要添加多个 -r 指定设备地址即可# -q, --io-depth &lt;val&gt; io depth# -o, --io-size &lt;val&gt; io size in bytes# -w, --io-pattern &lt;pattern&gt; io pattern type, must be one of: # (read, write, randread, randwrite, rw, randrw)# -M, --rwmixread &lt;0-100&gt; rwmixread (100 for reads, 0 for writes)# -t, --time &lt;sec&gt; time in seconds# -P, --num-qpairs &lt;val&gt; number of io queues per namespace. default: 1# -L, --enable-sw-latency-tracking enable latency tracking via sw, -LL for detailed histogram, default: disabled# -l, --enable-ssd-latency-tracking enable latency tracking via ssd (if supported), default: disabled# -G, --enable-debug enable debug logging# --transport-stats dump transport statistics# 更多参数含义可以见 --help 或源代码中的 usage() 函数 每个 QP 映射一个 Target 本身就是，每个 NS 建立 1 个 QP，而每个 Target 只有 1 个 NS。 perf 当前 IO 任务下发、回收逻辑 简洁版： 12345678910111213141516171819202122232425/*** 下发 ***/foreach (ns_ctx) &#123; while (queue_depth-- &gt; 0) &#123; ... // 创建一个 task ... // 发送 task ... // 经过多层调用、每层都会对 task 某些字段进行配置 submit_single_io(task): // 这一层设置了 random offset 和 random read/write nvme_submit_io(task): ... // 通过 io_complete callback 关联 req 与 task ... // 创建 nvme_req、rdma_req、ibv_send_wr 等 qp_send_wrs(send_wr); // 最终发送 send_wr &#125;&#125;/*** 回收 ***/...process_recv_completion(...): ... // rdma_req 打上 RECV_COMPLETED 标记 ... // 因为是同一个 rdma_req，所以在发送成功后已经有 SEND_COMPLETED 标记 ... // 如果同时有 RECV 和 SEND 完成标记，则会进行下一步 io_complete(task): task_complete(task): if (ns_ctx-&gt;is_draining): free(task); // 如果超过时间，则开始释放 IO 任务 else: submit_single_io(task): ... // 没有超过时间，则会重新利用 task、设置 random offset 和 random read/write 重要的点在于如果没有超过时间，接收到的 req 对应的 task 会被重新利用，buffer 的地址不变、但 random offset 和 random read/write 的值会发生随机改变。 各层的 req 与 task 关联以及互相关联 请求之间转换关系图： 疑问： wc-&gt;wr_id 字段是如何赋值的？ send_wr-&gt;imm_data、wc-&gt;imm_data 如何使用？ rsp-&gt;cpl 字段是如何赋值的？ 修改 perf IO 任务逻辑 - 初版 需要考虑兼容单 worker 和多 worker 的情形。 同一个 IO 任务复制多份 为 perf_task 添加索引序号 io_id 字段； 由 main_worker 创建 g_queue_depth 个 tasks，每个 task 中关联的 ns_ctx 指针暂时指向某个 ns_ctx； 这些 tasks 保存在 g_tasks 指针数组中，这样所有 worker_thread (ns) 都可以通过复制得到相同的 task； 在分发 task 时，需要深拷贝一份新的 task 然后修改关联的 ns_ctx、iovs 等指针。 task 一致性 由 perf 下发和回收逻辑看出，下发到多个 qpairs 的 task 之间，会发生改变的主要是 task-&gt;io_id、task-&gt;iovs (buffer)、task-&gt;md_iovs、offset_in_ios、task-&gt;is_read 等字段和变量。因此控制当 task-&gt;io_id 相等时，其他的字段和变量也对应一致就可以满足 task 复制的要求。 不需要要求多个 IO 同时发送，因此可以采取任务队列的类似思路。 由 main_worker： 创建 g_queue_depth 个 g_tasks； g_random_num = 2 * g_queue_depth； 创建 g_random_num 长度的 g_offset_in_ios 数组； 创建 g_random_num 长度的 g_is_read 数组。 提前通过 srand(time(NULL)) 和 rand() 初始化好 g_offset_in_ios 和 g_is_read； 每提交一个 task 时，从 g_offset_in_ios 和 g_is_read 中取出下标为 task-&gt;io_id % (q_random_num) 的随机值，这样就可以保证提交的下标相同的 task 的随机偏移量和 r/w 是一致的。 这样的思路理论上可以保证提交的下标相同的 task 的随机偏移量和 r/w 是一致的；而 task 的其他字段则在创建 g_tasks 时就已经配置好。 接收请求后重新利用 task 并提交 原 task 回收逻辑中，是将之前发送过的 task 重新利用，其中的字段都不变，仅修改 offset_in_ios 和 is_read 的值，然后创建新的 req。 多副本的情况下，需要保证 offset_in_ios 和 is_read 一致，同时能够跟踪到 task_io_id，所以修改的思路为： task-&gt;io_id 在每次收到后都 += g_queue_depth，这样不会导致 task-&gt;io_id 的重复（同一个 ns 提交多次 task-&gt;io_id = n 的请求）； 重新利用 task-&gt;io_id 并提交时，会进入到 nvme_submit_io() 函数中，在这个函数里为 offset_in_ios 和 is_read 进行了赋值，修改为直接获取下标为 task-&gt;io_id % (g_random_num) 的已经保存在数组中的随机值。 多副本 IO 同步 暂未考虑。 多个 task 内存回收 在 cleanup 阶段统一清理 g_tasks 数组。 修改后 IO 任务下发、回收逻辑 简洁版图示： 修改 perf IO 任务逻辑 - 优化后 假设在单 worker 情形。 同一个 IO 任务复制多份 分主从副本 main_task 和 rep_task，其中 main_task 维护了一个副本队列，包括自己在内的所有副本； 每个副本都有指向主副本 main_task 的指针字段； 每个 worker 都可以感知到所有 ns_ctx； worker 遍历其所有 ns_ctx，第一个对应的副本为主副本；当创建主副本后，其他的 ns_ctx 对应的副本都为从副本。 task 一致性 当主副本设置完 io 偏移量以及随机读写后，遍历其副本队列，同步给所有从副本； 然后执行提交 IO 任务的逻辑。 接收请求后重新利用 task 并提交 task-&gt;io_id 在每次收到后都 += g_queue_depth，这样不会导致 task-&gt;io_id 的重复（同一个 ns 提交多次 task-&gt;io_id = n 的请求）； 重新利用 task-&gt;io_id 并提交时，会进入到 nvme_submit_io() 函数中，在这个函数里为 offset_in_ios 和 is_read 进行了重新随机赋值，之后主副本再次同步给所有从副本。 多副本 IO 同步 存在两次同步： 下发同一个 IO 任务时，提交主副本。在主副本提交前遍历其副本队列，将他们都提交到相应 NS 的队列； 任务完成后，主副本的计数器满足要求才代表该 IO 任务完成。即当所有副本均完成后，该 IO 任务才算完成，然后才对主副本重新设置。 因此可能会造成某个 IO 任务的某个副本还没有完成，从而导致下一个 IO 无法下发的情况，但理论上这与实际不符。 多个 task 内存回收 达到运行时间后，回收主副本； 每个副本指向的 iovs 内存地址只释放一次，而每个副本都要被回收释放。 修改后 IO 任务下发、回收逻辑 简洁版图示：","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"存储","slug":"notes/存储","permalink":"https://cs0522.github.io/categories/notes/%E5%AD%98%E5%82%A8/"}],"tags":[{"name":"存储","slug":"存储","permalink":"https://cs0522.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"SPDK","slug":"SPDK","permalink":"https://cs0522.github.io/tags/SPDK/"}]},{"title":"【学习笔记】SPDK（四）：补充知识记录","slug":"n-spdk-04","date":"2024-09-18T11:23:39.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"notes/存储/n-spdk-04/","link":"","permalink":"https://cs0522.github.io/notes/%E5%AD%98%E5%82%A8/n-spdk-04/","excerpt":"记录在看 perf 代码中学习到的 NVMe、NVMe-oF、RDMA、SPDK 相关知识点。","text":"记录在看 perf 代码中学习到的 NVMe、NVMe-oF、RDMA、SPDK 相关知识点。 NVMe 参考介绍 NVMe 参考NVMe 结构理论 参考NVMe 控制器架构模型 参考NVMe 队列模型 参考NVMe SQ &amp; CQ NVMe Specifications NVM Express Base Specification 定义了主机软件通过各种基于内存的传输和基于消息的传输与非易失性内存子系统通信的协议。 NVM Express Management Interface Specification 为所有 NVM Express 子系统定义了一个可选的管理接口。 NVM Express I/O Command Set Specification 定义了扩展 NVM Express Base Specification 的数据结构、features、log pages、commands 和 status 值。 NVM Express Transport Specification 定义了 NVMe 协议（包括控制器属性）与特定传输的绑定。 NVMe 控制器类型 所有控制器都实现了一个 Admin Submission Queue 和一个 Admin Completion Queue。Identify Controller data structure 中的 Controller Type (CNTRLTYPE) 字段指示控制器的类型。(cdata-&gt;cntrltype) I/O controllers 实现 I/O 队列的控制器，旨在用于访问非易失性内存存储介质。 Discovery controllers 公开允许主机检索 Discovery Log Page 的 capabilities 的控制器。Discovery controller 不实现 I/O 队列、I/O 命令或公开命名空间。 Administrative controllers 公开允许主机管理 NVM 子系统的 capabilities 的控制器。Administrative 控制器不实现 I/O 队列，不提供对与非易失性内存存储介质上的用户数据相关的数据或元数据的访问，也不支持命名空间（即，从来没有任何 active NSID）附加到 Administrative 控制器。 Identify data structure Identify Controller data structures 能够通过 identify 命令检索的所有控制器数据结构：Identify Controller data structure （即，CNS 01h）和每个 I/O Command Set 特定的 Identify Controller data structure（即，CNS 06h）。 Identify Namespace data structures 能够通过 Identify 命令检索的所有命名空间数据结构：Identify Namespace data structure（即，CNS 00h）、I/O Command Set Independent Identify Namespace data structure（即，CNS 08h）和每个 I/O Command Set 特定的 Identify Namespace data structures（即 05h）。 SQ、CQ Admin SQ、CQ 之间始终存在 1 : 1 映射，都必须运行在管理 ctrlr 的核上。 提交队列（Submission Queues，SQ） 用于发送命令到 NVMe 驱动器。主机将命令放入提交队列后，驱动器会从中取出并执行这些命令。 完成队列（Completion Queues，CQ） 用于接收来自 NVMe 驱动器的命令完成通知。当命令在驱动器中完成时，相关的信息会被放入完成队列。 NVMe 中这两个队列为 qpair。每个命名空间可以有多个队列（通常最大为 64K）。 SGL/SGE SGL 和 SGE NVMe 传输模型 元素 基于内存的传输模型 基于消息的传输模型 Admin SQ、CQ 始终为 1:1 映射、且都建立在 ctrlr mgmt 核上 同 IO SQ、CQ 可以 1:1 或 n:1 映射 只能 1:1 映射 IO SQ 按任何顺序执行 SQ Entry、Entry 大小为 64B、物理内存位置由 PRP 或 SGL 指定 只支持 SGL IO CQ 用于发布已完成命令的状态 同 RDMA SQ、RQ、CQ 发送队列（Send Queue，SQ） 用于存放待发送的消息或数据请求。当应用程序准备发送数据时，会将其放入发送队列。 接收队列（Receive Queue，RQ） 用于存放接收数据的请求。应用程序在接收数据前，会将接收请求放入接收队列。 完成队列（Completion Queue，CQ） 用于存放已完成操作的信息。当一个发送或接收操作完成时，相关的信息会被放入完成队列，应用程序可以通过检查完成队列来了解操作的状态。 RDMA 中 SQ 和 RQ 为 qpair，CQ 不属于 qpair。 通信机制 参考 基本操作类型 Send/Recv、Write、Read 机制和通信过程 参考 初识 RDMA 技术 RDMA 分为 基于 Memory 和 基于 Messaging 两种操作： 基于 Memory RDMA Read：从远程主机读取部分内存。调用者指定远程虚拟地址，像本地内存地址一样用来拷贝。在执行 RDMA 读操作之前，远程主机必须提供适当的权限来访问它的内存。一旦权限设置完成， RDMA 读操作就可以在对远程主机没有任何通知的条件下执行。不管是 RDMA 读还是 RDMA 写，远程主机都不会意识到操作正在执行（除了权限和相关资源的准备操作）。 RDMA Write：与 RDMA Read 类似，只是数据写到远端主机中。RDMA 写操作在执行时不通知远程主机。然而带即时数的 RDMA 写操作会将即时数通知给远程主机。 RDMA Atomic：包括原子取、原子加、原子比较和原子交换，属于 RDMA 原子操作的扩展。 基于 Messaging RDMA Send：发送操作允许把数据发送到远程 QP 的接收队列里。接收端必须已经事先注册好了用来接收数据的缓冲区。发送者无法控制数据在远程主机中的放置位置。可选择是否使用即时数，一个 4 位的即时数可以和数据缓冲一起被传送。这个即时数发送到接收端是作为接收的通知，不包含在数据缓冲之中。 RDMA Receive：这是与发送操作相对应的操作。接收主机被告知接收到数据缓冲，还可能附带一个即时数。接收端应用程序负责接收缓冲区的维护和发布。 通信过程见参考文章。 NVMe over RDMA 参考NVMe-RDMA-Transport-Specification-1.0d","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"存储","slug":"notes/存储","permalink":"https://cs0522.github.io/categories/notes/%E5%AD%98%E5%82%A8/"}],"tags":[{"name":"存储","slug":"存储","permalink":"https://cs0522.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"SPDK","slug":"SPDK","permalink":"https://cs0522.github.io/tags/SPDK/"}]},{"title":"【学习笔记】SPDK（三）：spdk_nvme_perf 代码浅析","slug":"n-spdk-03","date":"2024-09-01T11:35:45.000Z","updated":"2025-01-17T18:57:47.133Z","comments":false,"path":"notes/存储/n-spdk-03/","link":"","permalink":"https://cs0522.github.io/notes/%E5%AD%98%E5%82%A8/n-spdk-03/","excerpt":"SPDK 自带的性能测试应用 spdk_nvme_perf 的源代码 perf.c 的粗浅分析，进一步熟悉 SPDK 用户态驱动的主要工作流程和方式。","text":"SPDK 自带的性能测试应用 spdk_nvme_perf 的源代码 perf.c 的粗浅分析，进一步熟悉 SPDK 用户态驱动的主要工作流程和方式。 在看代码的过程中有些不懂的地方在网上查资料后学习了，记录在了 【学习笔记】SPDK（四）：补充知识记录 中。 简介 perf 是 SPDK 用来测试 NVMe SSD 性能的工具，最新版本的 SPDK 中 perf 源代码在 spdk/app/spdk_nvme_perf/ 路径下。perf 主要用来测试 NVMe SSD 的 IOPS，Bandwidth 和 Latency，它既可以测本地的 target，也可以测远端的 target。 perf 主流程 perf 资源关系图 函数调用栈说明： 相同缩进表示同一层的函数执行；不同缩进表示存在函数内调用另一个函数。 花括号表示循环体。 函数结尾 ; 表示该函数结束；: 表示进入该函数，接下来存在函数调用。 所有函数的调用可以利用 SPDK 的 debug，通过 -G 参数开启，不过没有函数的调用层次。 （一）控制流（初始化） 流程图： 函数调用栈： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051spdk_env_opts_init(&amp;opts);parse_args(...): while &#123; getopt_long(..., g_perf_cmdline_opts, ...); add_trid(...); ... // 创建了 trid 和 trid_entry &#125;spdk_env_init(&amp;opts);register_workers(): SPDK_ENV_FOREACH_CORE(i) &#123; worker = calloc(...); &#125; TAILQ_INIT(&amp;worker-&gt;ns_ctx); TAILQ_INSERT_TAIL(&amp;g_workers, worker, link);register_controllers(): TAILQ_FOREACH(trid_entry, &amp;g_trid_list, tailq) &#123; spdk_nvme_probe(&amp;trid_entry-&gt;trid, trid_entry, probe_cb, attach_cb, NULL): probe_ctx = spdk_nvme_probe_async(...): // 注意异步执行 nvme_driver_init(); probe_ctx = calloc(...); nvme_probe_ctx_init(probe_ctx, ...): TAILQ_INIT(&amp;probe_ctx-&gt;init_ctrlrs); nvme_probe_internal(probe_ctx, false): nvme_rdma.c: nvme_fabric_ctrlr_scan(probe_ctx, ...): // 该函数调用见后文、构造 ctrlr 函数 nvme_init_controllers(probe_ctx): while (true) &#123; // 注意这里有一个无限 while 循环，意味着 nvme_ctrlr_process_init() 在一直循环执行 spdk_nvme_probe_poll_async(probe_ctx): // 注意异步执行 TAILQ_FOREACH_SAFE(ctrlr, &amp;probe_ctx-&gt;init_ctrlrs, ...) &#123; nvme_ctrlr_poll_internal(ctrlr, probe_ctx): /** 处理 ctrlr 状态转移 **/ nvme_ctrlr_process_init(ctrlr): // 该函数调用见后文、处理状态转移函数 TAILQ_REMOVE(&amp;probe_ctx-&gt;init_ctrlrs, ctrlr, ...); TAILQ_INSERT_TAIL(&amp;g_nvme_attached_ctrlrs, ctrlr, tailq); perf.c: attach_cb(...): register_ctrlr(ctrlr, trid_entry): build_nvme_name(ctrlr_entry-&gt;name, ..., ctrlr); TAILQ_INSERT_TAIL(&amp;g_controllers, ctrlr_entry, ...); foreach (nsid) &#123; ns = spdk_nvme_ctrlr_get_ns(ctrlr, nsid); register_ns(ctrlr, ns); ... // 进行一系列 io 检查和验证，保证可以正常进行 io 操作 ns_entry-&gt;u.nvme.ctrlr = ctrlr; ns_entry-&gt;u.nvme.ns = ns; build_nvme_ns_name(ns_entry-&gt;name, ..., ctrlr, ...); TAILQ_INSERT_TAIL(&amp;g_namespaces, entry, link); &#125; &#125; &#125; &#125; 初始化大体步骤： 解析输入参数，初始化 SPDK、DPDK 环境； 创建、注册 SPDK 工作线程； 通过解析参数得到的 transport id、进行异步设备探测、通过状态机获取设备（控制器、NS 等）信息、注册设备（创建 entry 通过尾队列维护）等。 注意异步以及控制器设备注册时的状态机。这一部分也会发送少量请求。 并且刚开始的 trid 并不包含任何真正信息，作用就是给程序指明参数提供了有哪些 trid 需要去探测。 （二）控制流（初始化 - fabric_ctrlr_scan） 流程图： 函数调用栈： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879nvme_rdma.c: nvme_fabric_ctrlr_scan(probe_ctx, ...): spdk_nvme_ctrlr_get_default_ctrlr_opts(&amp;discovery_opts, ...): SET_FIELD(...); /** discovery_ctrlr 识别过程、没有获得 ns、subnqn 等过程 **/ discovery_ctrlr = nvme_rdma_ctrlr_construct(&amp;probe_ctx-&gt;trid, &amp;discovery_opts, ...): ... // 构造 rdma_ctrlr 设置部分字段、建立事件通道等 nvme_ctrlr_construct(&amp;rctrlr-&gt;ctrlr): nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_INIT, NVME_TIMEOUT_INFINITE); ... // 设置 discovery_ctrlr 部分字段 TAILQ_INIT(&amp;ctrlr-&gt;active_io_qpairs); TAILQ_INIT(&amp;ctrlr-&gt;active_procs); RB_INIT(&amp;ctrlr-&gt;ns); rctrlr-&gt;ctrlr.adminq = nvme_rdma_ctrlr_create_qpair(&amp;rctrlr-&gt;ctrlr, ..., async = true): rqpair-&gt;state = NVME_RDMA_QPAIR_STATE_INVALID; // 创建了 rqpair、设置状态为 INVALID qpair = &amp;rqpair-&gt;qpair; nvme_qpair_init(qpair, qid, ctrlr, qprio, num_requests, async): ... // 设置 qpair 部分字段 qpair-&gt;ctrlr = ctrlr; qpair-&gt;trtype = ctrlr-&gt;trid.trtype; qpair-&gt;async = async; STAILQ_INIT(&amp;qpair-&gt;free_req); for &#123; STAILQ_INSERT_HEAD(&amp;qpair-&gt;free_req, req, stailq); &#125; nvme_ctrlr_add_process(&amp;rctrlr-&gt;ctrlr, 0): ... // 设置 discovery ctrlr_proc 字段 TAILQ_INSERT_TAIL(&amp;ctrlr-&gt;active_procs, ctrlr_proc, tailq); while (discovery_ctrlr-&gt;state != NVME_CTRLR_STATE_READY) &#123; nvme_ctrlr_process_init(discovery_ctrlr): // 该函数调用见后文、处理状态转移函数 &#125; nvme_ctrlr_cmd_identify(discovery_ctrlr, ..., &amp;discovery_ctrlr-&gt;cdata, ...); nvme_wait_for_completion(discovery_ctrlr-&gt;adminq, ...); /** io ctrlr 识别过程、完整流程 **/ nvme_fabric_ctrlr_discover(discovery_ctrlr, probe_ctx): while &#123; nvme_fabric_get_discovery_log_page(discovery_ctrlr, buffer, ...): spdk_nvme_ctrlr_cmd_get_log_page(...); nvme_wait_for_completion(discovery_ctrlr-&gt;adminq, status); for &#123; nvme_fabric_discover_probe(log_page_entry++, probe_ctx, discovery_ctrlr-&gt;trid.priority): ... // 通过 log_page_entry 设置 trid nvme_ctrlr_probe(&amp;trid, probe_ctx, NULL): spdk_nvme_ctrlr_get_default_ctrlr_opts(&amp;discovery_opts, ...): SET_FIELD(...); /** 这里构建了 io ctrlr **/ ctrlr = nvme_rdma_ctrlr_construct(trid, &amp;opts, devhandle = NULL): rctrlr = spdk_zmalloc(...); ... // 获取 rdma 设备、设备属性等，设置 rctrlr 部分字段 nvme_ctrlr_construct(&amp;rctrlr-&gt;ctrlr): nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_INIT, NVME_TIMEOUT_INFINITE); ... // 设置 ctrlr 部分字段 TAILQ_INIT(&amp;ctrlr-&gt;active_io_qpairs); TAILQ_INIT(&amp;ctrlr-&gt;active_procs); RB_INIT(&amp;ctrlr-&gt;ns); ... // rctrlr 初始化 cm_events 队列 // 以下两步在建立 rdma cm 通道，在后面建立 rdma qpairs 连接时用到 rctrlr-&gt;cm_channel = rdma_create_event_channel(); flag = fcntl(rctrlr-&gt;cm_channel-&gt;fd, F_GETFL); // 创建 admin qpair，qid = 0 为 admin queue rctrlr-&gt;ctrlr.adminq = nvme_rdma_ctrlr_create_qpair(&amp;rctrlr-&gt;ctrlr, qid = 0, ..., async = true): rqpair-&gt;state = NVME_RDMA_QPAIR_STATE_INVALID; // 创建了 rqpair、设置状态为 INVALID qpair = &amp;rqpair-&gt;qpair; nvme_qpair_init(qpair, qid, ctrlr, qprio, num_requests, async): ... // 设置 qpair 部分字段 qpair-&gt;ctrlr = ctrlr; qpair-&gt;trtype = ctrlr-&gt;trid.trtype; qpair-&gt;async = async; STAILQ_INIT(&amp;qpair-&gt;free_req); for &#123; STAILQ_INSERT_HEAD(&amp;qpair-&gt;free_req, req, stailq); &#125; nvme_ctrlr_add_process(&amp;rctrlr-&gt;ctrlr, 0): ... // 设置 ctrlr_proc 字段 TAILQ_INSERT_TAIL(&amp;ctrlr-&gt;active_procs, ctrlr_proc, tailq); &#125; nvme_qpair_set_state(ctrlr-&gt;adminq, NVME_QPAIR_ENABLED); TAILQ_INSERT_TAIL(&amp;probe_ctx-&gt;init_ctrlrs, ctrlr, tailq); &#125; 这部分是扫描创建 ctrlr 核心函数。大体步骤： 创建 discovery_ctrlr 和其 Admin QP，通过不完全状态机，作用是获取 discovery_log_page； discovery_log_page 其中包含了 ctrlr 真正有用的信息如 trid、subnqn 等，用来构建 io_ctrlr； io_ctrlr 经过完全状态机的状态转移，直到 READY 状态，加入到 init_ctrlrs 队列中。 注意 ctrlr 的状态机，不同的状态执行不同的函数，如识别 NS、获取 Data 等，会通过 Admin QP 发送 identify 请求。 （三）控制流（初始化 - ctrlr_process_init） Controller 状态转移过程。 流程图： 函数调用栈： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899 /** This function will be called repeatedly during initialization until the controller is ready. */nvme_ctrlr_process_init(ctrlr): // 状态 CONNECT_ADMINQ: nvme_transport_ctrlr_connect_qpair(ctrlr, ctrlr-&gt;adminq): nvme_qpair_set_state(qpair, NVME_QPAIR_CONNECTING); ... // 与建立 io qpairs 流程类似，见后文 // 状态 WAIT_FOR_CONNECT_ADMINQ: spdk_nvme_qpair_process_completions(ctrlr-&gt;adminq, 0): nvme_transport_qpair_process_completions(qpair, max_completions): nvme_rdma_qpair_process_completions(qpair, max_completions): TODO switch (ctrlr-&gt;adminq-&gt;state) &#123; // QPAIR_CONNECTING: break; // QPAIR_CONNECTED: nvme_qpair_set_state(ctrlr-&gt;adminq, NVME_QPAIR_ENABLED); // QPAIR_ENABLED: nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_READ_VS, NVME_TIMEOUT_INFINITE); nvme_qpair_abort_queued_reqs(ctrlr-&gt;adminq); &#125; ... // 状态 RESET_ADMIN_QUEUE: nvme_transport_qpair_reset(ctrlr-&gt;adminq): // do nothing nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_IDENTIFY, ...); // 状态 IDENTIFY: nvme_ctrlr_identify(ctrlr): nvme_ctrlr_cmd_identify(ctrlr, ..., &amp;ctrlr-&gt;cdata, nvme_ctrlr_identify_done, ctrlr); nvme_ctrlr_identify_done(ctrlr); ... // 状态 SET_KEEP_ALIVE_TIMEOUT: nvme_ctrlr_set_keep_alive_timeout(ctrlr): nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_WAIT_FOR_KEEP_ALIVE_TIMEOUT, ...); spdk_nvme_ctrlr_cmd_get_feature(ctrlr, ..., nvme_ctrlr_set_keep_alive_timeout_done, ctrlr); nvme_ctrlr_set_keep_alive_timeout_done(ctrlr): spdk_nvme_ctrlr_is_discovery(ctrlr); // 判断是否为 dicovery_ctrlr if (discovery_ctrlr): nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_READY, NVME_TIMEOUT_INFINITE); else if (io_ctrlr): nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_IDENTIFY_IOCS_SPECIFIC, ...); // 状态 IDENTIFY_IOCS_SPECIFIC: nvme_ctrlr_identify_iocs_specific(ctrlr): nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_WAIT_FOR_IDENTIFY_IOCS_SPECIFIC, ...); nvme_ctrlr_cmd_identify(ctrlr, ..., ctrlr-&gt;cdata_zns, nvme_ctrlr_identify_zns_specific_done, ctrlr); nvme_ctrlr_identify_zns_specific_done(ctrlr): nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_SET_NUM_QUEUES, ...); // 状态 SET_NUM_QUEUES: nvme_ctrlr_update_nvmf_ioccsz(ctrlr); nvme_ctrlr_set_num_queues(ctrlr): nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_WAIT_FOR_SET_NUM_QUEUES, ...); nvme_ctrlr_cmd_set_num_queues(ctrlr, ctrlr-&gt;opts.num_io_queues, nvme_ctrlr_set_num_queues_done, ctrlr); nvme_ctrlr_set_num_queues_done(ctrlr): for (i = 1; i &lt;= ctrlr-&gt;opts.num_io_queues) &#123; // 初始化 free io queue IDs 列表（bit array） // QID 0 是 admin queue，已经 implicitly allocated spdk_nvme_ctrlr_free_qid(ctrlr, i); &#125; nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_IDENTIFY_ACTIVE_NS, ...); // 状态 IDENTIFY_ACTIVE_NS: _nvme_ctrlr_identify_active_ns(ctrlr): active_ns_ctx = nvme_active_ns_ctx_create(ctrlr, _nvme_active_ns_ctx_deleter); // 绑定 deleter nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_WAIT_FOR_IDENTIFY_ACTIVE_NS, ...); nvme_ctrlr_identify_active_ns_async(active_ns_ctx): // 异步处理 nvme_ctrlr_cmd_identify(ctrlr, ..., &amp;active_ns_ctx-&gt;new_ns_list[1024 * (active_ns_ctx-&gt;page_count - 1)], nvme_ctrlr_identify_active_ns_async_done, active_ns_ctx); nvme_ctrlr_identify_active_ns_async_done(active_ns_ctx): _nvme_active_ns_ctx_deleter(): // 函数指针 nvme_ctrlr_identify_active_ns_swap(ctrlr, ctx-&gt;new_ns_list, ...): foreach (active_nsid) &#123; nvme_ctrlr_construct_namespace(ctrlr, nsid): ns = spdk_nvme_ctrlr_get_ns(ctrlr, nsid): RB_INSERT(nvme_ns_tree, &amp;ctrlr-&gt;ns, ns); &#125; nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_IDENTIFY_NS, ...); // 状态 IDENTIFY_NS: nvme_ctrlr_identify_namespaces(ctrlr): ... // 获取 nsid、active_ns、active_ns 绑定 ctrlr nvme_ctrlr_identify_ns_async(ns): nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_WAIT_FOR_IDENTIFY_NS, ...); nvme_ctrlr_cmd_identify(ns-&gt;ctrlr, ..., &amp;ns-&gt;nsdata, nvme_ctrlr_identify_ns_async_done, ns); nvme_ctrlr_identify_ns_async_done(ns): nvme_ns_set_identify_data(ns); ... // 获取下一个 nsid、active_ns、active_ns 绑定 ctrlr if (ns == NULL): nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_IDENTIFY_ID_DESCS, ...); else: nvme_ctrlr_identify_ns_async(ns): ... // 循环执行直到 ns == NULL // 状态 IDENTIFY_ID_DESCS: nvme_ctrlr_identify_id_desc_namespaces(ctrlr); ... // 状态 IDENTIFY_NS_IOCS_SPECIFIC: nvme_ctrlr_identify_namespaces_iocs_specific(ctrlr); ... // 状态 TRANSPORT_READY: nvme_transport_ctrlr_ready(ctrlr); // 没有找到实现函数 nvme_ctrlr_set_state(ctrlr, NVME_CTRLR_STATE_READY, NVME_TIMEOUT_INFINITE); // 状态 NVME_CTRLR_STATE_READY. // 状态 WAIT_FOR_XXX 统一处理：（通过 callback 执行转换下一个状态操作） spdk_nvme_qpair_process_completions(ctrlr-&gt;adminq, 0): nvme_transport_qpair_process_completions(qpair, max_completions): nvme_rdma_qpair_process_completions(qpair, max_completions): TODO 不同状态执行不同的函数，函数执行完毕后会手动改变 ctrlr 的状态，从而使 ctrlr 进入下一个状态。 （四）控制流（任务执行） 流程图： 函数调用栈： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188/** 创建轮询线程执行任务 **/pthread_create(&amp;thread_id, NULL, &amp;nvme_poll_ctrlrs, NULL);// 进入轮询线程：nvme_poll_ctrlrs(): while (true) &#123; foreach (entry, &amp;g_controllers, link) &#123; spdk_nvme_ctrlr_process_admin_completions(entry-&gt;ctrlr): nvme_ctrlr_keep_alive(ctrlr); // 发送 keep alive 指令 nvme_io_msg_process(ctrlr): // 处理 ctrlr io 消息 if (ctrlr-&gt;needs_io_msg_update): nvme_io_msg_ctrlr_update(ctrlr): STAILQ_FOREACH(io_msg_producer, &amp;ctrlr-&gt;io_producers, link) &#123; io_msg_producer-&gt;update(ctrlr); &#125; spdk_nvme_qpair_process_completions(ctrlr-&gt;external_io_msgs_qpair, 0): nvme_transport_qpair_process_completions(qpair, max_completions): nvme_rdma_qpair_process_completions(qpair, max_completions): TODO count = spdk_ring_dequeue(ctrlr-&gt;external_io_msgs, requests, ...); // 从外部 I/O 消息环中按需排队获取消息，存储在 requests 数组中 for (i &lt; count) &#123; spdk_nvme_io_msg *io = requests[i]; io-&gt;fn(io-&gt;ctrlr, io-&gt;nsid, io-&gt;arg); // 调用 io 消息处理函数 &#125; spdk_nvme_qpair_process_completions(ctrlr-&gt;adminq, 0): nvme_transport_qpair_process_completions(qpair, max_completions): nvme_rdma_qpair_process_completions(qpair, max_completions): TODO if (active_proc): nvme_ctrlr_complete_queued_async_events(ctrlr); // 如果当前进程在 ctrlr-&gt;active_procs 中，则处理 async_events &#125; &#125;// 回到主线程 main()：associate_workers_with_ns(): for (max(g_num_namespaces, g_num_workers)) &#123; allocate_ns_worker(ns_entry, worker): ns_ctx-&gt;entry = entry; TAILQ_INSERT_TAIL(&amp;worker-&gt;ns_ctx, ns_ctx, link); // worker_ns_ctx 加入 worker-&gt;ns_ctx 队列中 &#125;pthread_barrier_init(&amp;g_worker_sync_barrier, NULL, g_num_workers); // barrier 线程同步，当所有 thread 都执行到 barrier_wait() 后，才继续执行后续代码TAILQ_FOREACH(worker, &amp;g_workers, link) &#123; if (worker-&gt;lcore != g_main_core): spdk_env_thread_launch_pinned(worker-&gt;lcore, work_fn, worker); // worker thread 一一对应到 core、每个 core 绑定一个 work_fn&#125;work_fn(main_worker);// 每个 core 执行 work_fnwork_fn(worker): TAILQ_FOREACH(ns_ctx, &amp;worker-&gt;ns_ctx, link) &#123; nvme_init_ns_worker_ctx(ns_ctx): // 为每个 ns 分配 io_qpairs spdk_nvme_ctrlr_get_default_io_qpair_opts(ns_entry-&gt;u.nvme.ctrlr, &amp;opts, sizeof(opts)); ctrlr_opts = spdk_nvme_ctrlr_get_opts(ns_entry-&gt;u.nvme.ctrlr); ns_ctx-&gt;u.nvme.group = spdk_nvme_poll_group_create(ns_ctx, NULL): // 创建 nvme_poll_group group-&gt;ctx = ns_ctx; STAILQ_INIT(&amp;group-&gt;tgroups); // tgroup: transport_poll_group for (i &lt; ns_ctx-&gt;u.nvme.num_all_qpairs) &#123; // u.nvme.qpair 是二维指针 // 1. 创建 io qpair ns_ctx-&gt;u.nvme.qpair[i] = spdk_nvme_ctrlr_alloc_io_qpair(ns_entry-&gt;u.nvme.ctrlr, &amp;opts, ...): qpair = nvme_ctrlr_create_io_qpair(ctrlr, &amp;opts): qid = spdk_nvme_ctrlr_alloc_qid(ctrlr); qpair = nvme_rdma_ctrlr_create_io_qpair(ctrlr, qid, opts): // 函数指针 nvme_rdma_ctrlr_create_qpair(ctrlr, qid, ..., opts-&gt;async_mode = true): // 与前文 fabric_ctrlr_scan 创建 adminq 类似 rqpair-&gt;state = NVME_RDMA_QPAIR_STATE_INVALID; // 创建了 rqpair、设置状态为 INVALID qpair = &amp;rqpair-&gt;qpair; nvme_qpair_init(qpair, qid, ctrlr, qprio, num_requests, async): ... // 设置 qpair 部分字段 qpair-&gt;ctrlr = ctrlr; qpair-&gt;trtype = ctrlr-&gt;trid.trtype; qpair-&gt;async = async; STAILQ_INIT(&amp;qpair-&gt;free_req); for &#123; STAILQ_INSERT_HEAD(&amp;qpair-&gt;free_req, req, stailq); &#125; TAILQ_INSERT_TAIL(&amp;ctrlr-&gt;active_io_qpairs, qpair, tailq); nvme_ctrlr_proc_add_io_qpair(qpair): // 与当前 active_proc 关联 TAILQ_INSERT_TAIL(&amp;active_proc-&gt;allocated_io_qpairs, qpair, per_process_tailq); qpair-&gt;active_proc = active_proc; // create_only = true // 2. qpair 添加 poll groups spdk_nvme_poll_group_add(nvme_poll_group, qpair): // io_qpair 添加到 nvme_poll_group、transport_poll_group while (transport) &#123; tgroup = nvme_transport_poll_group_create(transport): // 创建 transport_poll_group nvme_rdma_poll_group_create(): // 创建 rdma_poll_group STAILQ_INIT(&amp;rdma_poll_group-&gt;pollers); TAILQ_INIT(&amp;rdma_poll_group-&gt;connecting_qpairs); TAILQ_INIT(&amp;rdma_poll_group-&gt;active_qpairs); return rdma_poll_group-&gt;transport_poll_group; STAILQ_INIT(&amp;group-&gt;connected_qpairs); STAILQ_INIT(&amp;group-&gt;disconnected_qpairs); tgroup-&gt;group = nvme_poll_group; // transport_poll_group 关联 nvme_poll_group STAILQ_INSERT_TAIL(&amp;nvme_poll_group-&gt;tgroups, tgroup, link); &#125; nvme_transport_poll_group_add(tgroup, qpair): qpair-&gt;poll_group = tgroup; // qpair 关联 transport_poll_group nvme_rdma_poll_group_add(tgroup, qpair): // do nothing // 这里 rdma_poll_group 没有与 qpair 关联，在后面 rdma_poll_group 与 rdma_qpair 关联 // 3. 连接 io qpair spdk_nvme_ctrlr_connect_io_qpair(entry-&gt;u.nvme.ctrlr, qpair): nvme_transport_ctrlr_connect_qpair(ctrlr, qpair): nvme_qpair_set_state(qpair, NVME_QPAIR_CONNECTING); // 这里设置了 qpair 状态为正在连接 nvme_rdma_ctrlr_connect_qpair(ctrlr, qpair): // 函数指针 // 通过 nvme_qpair、nvme_ctrlr 移动 n 个字节得到 rqpair = nvme_rdma_qpair(qpair): // rqpair 为 nvme_rdma_qpair SPDK_CONTAINEROF(qpair, struct nvme_rdma_qpair, qpair): #define SPDK_CONTAINEROF(ptr, type, member) ((type *)((uintptr_t)ptr - offsetof(type, member))); /* offsetof(...): Offset of member MEMBER in a struct of type TYPE. */ rctrlr = nvme_rdma_ctrlr(ctrlr); // rctrlr 为 nvme_rdma_ctrlr nvme_parse_addr(&amp;dst_addr, ctrlr-&gt;trid.traddr, &amp;port, ...); // 解析 destination_address nvme_parse_addr(&amp;src_addr, ctrlr-&gt;opts.src_addr, &amp;src_port, ...); // 解析 source_address rdma_create_id(rctrlr-&gt;cm_channel, &amp;rqpair-&gt;cm_id, rqpair, RDMA_PS_TCP); // 分配 communication id nvme_rdma_resolve_addr(rqpair, &amp;src_addr, &amp;dst_addr): rdma_set_option(rqpair-&gt;cm_id, ...); rdma_resolve_addr(rqpair-&gt;cm_id, src_addr, dst_addr, ...); // 开始处理 rdma events nvme_rdma_process_event_start(rqpair, RDMA_CM_EVENT_ADDR_RESOLVED = 0, nvme_rdma_addr_resolved): rqpair-&gt;evt_cb = evt_cb; // evt_cb = nvme_rdma_addr_resolved ... // 经过一系列操作，最后是怎么执行回调函数 nvme_rdma_addr_resolved()？ /** 这里的 rdma_process_event_start() 调用逻辑见后文 **/ rqpair-&gt;state = NVME_RDMA_QPAIR_STATE_INITIALIZING; // 注意这里设置了 rqpair 状态，可能用于状态机 rgroup = nvme_rdma_poll_group(qpair-&gt;poll_group); // rgroup 为 nvme_rdma_poll_group TAILQ_INSERT_TAIL(&amp;rgroup-&gt;connecting_qpairs, rqpair, link_connecting); // rdma_poll_group 与 rdma_qpair 关联 nvme_poll_group_connect_qpair(qpair): nvme_transport_poll_group_connect_qpair(qpair): nvme_rdma_poll_group_connect_qpair(qpair): // do nothing // 这里 rdma_poll_group 没有连接 rqair // rqpair 在什么时候从 rgroup-&gt;connecting_qpairs 中移除并加入到 rgroup-&gt;active_qpairs？ // active_qpairs 是在 submit_request 中才使用，因此作用理解为当 rdma_qpair 有 req 时，加入到 active_qpairs 中 STAILQ_INSERT_TAIL(&amp;tgroup-&gt;connected_qpairs, qpair, poll_group_stailq); // qpair-&gt;async = true // 4. poll group 处理 qpairs 完成事件 while &#123; /** poll for completions on all qpairs in this poll group **/ // 与 检查 io 数据流 类似，见后文 spdk_nvme_poll_group_process_completions(group, 0, perf_disconnect_cb): STAILQ_FOREACH(tgroup, &amp;group-&gt;tgroups, link) &#123; nvme_transport_poll_group_process_completions(tgroup, ..., disconnected_qpair_cb): nvme_rdma_poll_group_process_completions(tgroup, ..., disconnected_qpair_cb): // 函数指针 TAILQ_FOREACH_SAFE(rqpair, &amp;rgroup-&gt;connecting_qpairs, ...) &#123; nvme_rdma_ctrlr_connect_qpair_poll(rqpair-&gt;qpair-&gt;ctrlr, rqpair-&gt;qpair): // TODO 这一块没有看懂 // rdma_qpair 状态机 // 根据不同状态执行不同操作、通过 callback 转移状态、直到状态为 NVME_RDMA_QPAIR_STATE_RUNNING 结束 // 在这里可能执行了 rqpair-&gt;evt_cb = nvme_rdma_addr_resolved() 函数 // 然后 rdma 解析完 addr 后进行路由 // 按以上思路走 // rqpair-&gt;state = NVME_RDMA_QPAIR_STATE_INITIALIZING ... TAILQ_REMOVE(&amp;rgroup-&gt;connecting_qpairs, rqpair, ...); // submit queued requests nvme_qpair_resubmit_requests(rqpair-&gt;qpair, rqpair-&gt;num_entries): ... // 与 发送数据流 类似，见后文 &#125; STAILQ_FOREACH_SAFE(qpair, &amp;tgroup-&gt;connected_qpairs, ...) &#123; nvme_rdma_qpair_process_cm_event(rqpair); ... // rdma_qpair 状态机 &#125; STAILQ_FOREACH(poller, &amp;rgroup-&gt;pollers, ...) &#123; nvme_rdma_cq_process_completions(poller-&gt;cq, batch_size, poller, NULL, &amp;rdma_completions); // 处理 rdma cq ... // 与 检查 io 数据流 类似，见后文 &#125; &#125; spdk_nvme_poll_group_all_connected(group): ... // 检查是否都 connected，否则 while 循环继续 &#125; &#125; &#125; pthread_barrier_wait(&amp;g_worker_sync_barrier); // 线程同步 TAILQ_FOREACH(ns_ctx, &amp;worker-&gt;ns_ctx, link) &#123; submit_io(ns_ctx, g_queue_depth); // 发送数据流，见后文 &#125; while (!g_exit) &#123; TAILQ_FOREACH(ns_ctx, &amp;worker-&gt;ns_ctx, link) &#123; ns_ctx-&gt;entry-&gt;fn_table-&gt;check_io(ns_ctx); // 检查 io 数据流，见后文 ... // 计时、信息统计 &#125; ... // 遍历完一次队列之后就检查时间，如果超过指定的时间就退出，否则继续 &#125; ... // 计时、信息统计、ns_ctx 清理// 回到主线程 main()：spdk_env_thread_wait_all();print_stats(); // 打印信息统计pthread_barrier_destroy(&amp;g_worker_sync_barrier);... // cleanupunregister_trids();unregister_namespaces();unregister_controllers();unregister_workers();spdk_env_fini(); 工作任务大体步骤： 一般每个线程管理一个 NS； 为每个 NS 创建 n 个（假设一个）io QP； io QP 需要与 Target 端 io QP 建立对应连接，因此需要建立 RDMA 连接； 为 io QP 创建轮询组 poll_group 以及轮询器 poller； 准备发送 IO 和检查 IO 完成情况。 （五）控制流（建立 RDMA 层连接） 函数调用栈： 1234567/** 开始解析地址 **/nvme_rdma_resolve_addr(rqpair, &amp;src_addr, &amp;dst_addr): rdma_set_option(rqpair-&gt;cm_id, ...); rdma_resolve_addr(rqpair-&gt;cm_id, src_addr, dst_addr, ...); // 开始处理 rdma events nvme_rdma_process_event_start(rqpair, RDMA_CM_EVENT_ADDR_RESOLVED = 0, nvme_rdma_addr_resolved): // 略 RDMA 建立连接部分略。 在这一步中，在 RDMA 建立连接完成后，io QP 创建了 rdma_req 池和 rdma_rsp 池，并且 rsps 全部压到 RQ 中。 （六）数据流（发送） 流程图： 函数调用栈： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* Submit initial I/O for each namespace. */submit_io(ns_ctx, g_queue_depth): while (queue_depth-- &gt; 0) &#123; task = allocate_task(ns_ctx, queue_depth): nvme_setup_payload(task, pattern = queue_depth % 8 + 1): ... // 设置 io 负载 task-&gt;ns_ctx = ns_ctx; submit_single_io(task): nvme_submit_io(task, task-&gt;ns_ctx, task-&gt;ns_ctx-&gt;entry, offset_in_ios): qp_num = ns_ctx-&gt;u.nvme.last_qpair++; spdk_nvme_ns_cmd_read_with_md(entry-&gt;u.nvme.ns, ns_ctx-&gt;u.nvme.qpair[qp_num], ..., io_complete, ...): // io_complete() callback payload = NVME_PAYLOAD_CONTIG(buffer, metadata); // 配置 payload req = _nvme_ns_cmd_rw(ns, qpair, &amp;payload, SPDK_NVME_OPC_READ, ...): req = nvme_allocate_request(qpair, payload, ...): // 从请求池中分配 req req = STAILQ_FIRST(&amp;qpair-&gt;free_req); STAILQ_REMOVE_HEAD(&amp;qpair-&gt;free_req, stailq); NVME_INIT_REQUEST(req, cb_fn, cb_arg, *payload, ...); ... // 配置 req _nvme_ns_cmd_setup_request(ns, req, ...); // 配置 req-&gt;cmd nvme_qpair_submit_request(qpair, req): // 请求提交到 qpair _nvme_qpair_submit_request(qpair, req): nvme_transport_qpair_submit_request(qpair, req): // admin queue 不支持将 transport 存储在 ctrlr 或 admin queue 中 // io queue 支持 if (!nvme_qpair_is_admin_queue(qpair)): qpair-&gt;transport-&gt;ops.qpair_submit_request(qpair, req); else: transport-&gt;ops.qpair_submit_request(qpair, req): // transport 通过 nvme_get_transport(qpair-&gt;ctrlr-&gt;trid.trstring) 获取 nvme_rdma_qpair_submit_request(qpair, req): rqpair = nvme_rdma_qpair(qpair); rdma_req = nvme_rdma_req_get(rqpair); nvme_rdma_req_init(rqpair, req, rdma_req): rdma_req-&gt;req = req; req-&gt;cmd.cid = rdma_req-&gt;id; ... // 配置 rdma_req TAILQ_INSERT_TAIL(&amp;rqpair-&gt;outstanding_reqs, rdma_req, link); // 添加到 rqpair-&gt;outstanding_reqs 队列中 TAILQ_INSERT_TAIL(&amp;rgroup-&gt;active_qpairs, rqpair, link_active); // rqpair 添加到 rgroup-&gt;active_qpairs 队列中 // 发送请求排队 spdk_rdma_qp_queue_send_wrs(rqpair-&gt;rdma_qp, wr); // 提交发送请求 nvme_rdma_qpair_submit_sends(rqpair); // 刷新 rqpair spdk_rdma_qp_flush_send_wrs(rqpair-&gt;rdma_qp, &amp;bad_send_wr): // 提交发送请求至 send queue ibv_post_send(spdk_rdma_qp-&gt;qp, spdk_rdma_qp-&gt;send_wrs.first, bad_wr); /** 发送请求的过程结束 **/ &#125; 发送 IO 大体步骤： 以 IO 任务的形式下发。这个 IO 任务在后续被接收完成后会被复用，直到超过运行时间后回收内存并释放； IO 任务可以看作是 io queue 的槽，一共会有 g_queue_depth 个 IO 任务； 在发送前，设置 IO 任务的 io 偏移和随机读写，然后提交任务生成 nvme_req 请求； nvme SQ 的队列长度一般小于 io queue 的 g_queue_depth，所以会出现 IO 任务排队； 通过层层封装、转换，经过 perf_task -&gt; nvme_req -&gt; rdma_req 后，通过 RDMA ibverbs 发送请求。 （七）数据流（检查 IO 完成情况） 流程图： 函数调用栈： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102check_io(ns_ctx): nvme_check_io(ns_ctx): /** poll for completions on all qpairs in this poll group **/ spdk_nvme_poll_group_process_completions(ns_ctx-&gt;u.nvme.group, g_max_completions, perf_disconnect_cb): STAILQ_FOREACH(tgroup, &amp;group-&gt;tgroups, link) &#123; nvme_transport_poll_group_process_completions(tgroup, completions_per_qpair, ...): nvme_rdma_poll_group_process_completions(tgroup, completions_per_qpair, ...): // 1. 处理 cm_events STAILQ_FOREACH_SAFE(qpair, &amp;tgroup-&gt;connected_qpairs, ...) &#123; rqpair = nvme_rdma_qpair(qpair); /** event 为空，没有执行 nvme_rdma_qpair_process_cm_event(rqpair); */ &#125; // 2. poll CQ STAILQ_FOREACH(poller, &amp;rgroup-&gt;pollers, link) &#123; while &#123; nvme_rdma_cq_process_completions(poller-&gt;cq, batch_size, poller, rdma_qpair = NULL, &amp;rdma_completions): rc = ibv_poll_cq(cq, batch_size, ibv_wc); // 从 CQ 中取 work completion for (i &lt; rc) &#123; rdma_wr = (struct nvme_rdma_wr *)ibv_wc[i].wr_id; /** 处理 recv */ if (rdma_wr-&gt;type == RDMA_WR_TYPE_RECV): nvme_rdma_process_recv_completion(poller, &amp;ibv_wc[i], rdma_wr): // rdma work request 类型为接收 rdma_rsp = SPDK_CONTAINEROF(rdma_wr, struct spdk_nvme_rdma_rsp, rdma_wr); rqpair = rdma_rsp-&gt;rqpair; rdma_req = &amp;rqpair-&gt;rdma_reqs[rdma_rsp-&gt;cpl.cid]; rdma_req-&gt;completion_flags |= NVME_RDMA_RECV_COMPLETED; rdma_req-&gt;rdma_rsp = rdma_rsp; // 这里是如何不进入 if 代码段？ if ((rdma_req-&gt;completion_flags &amp; NVME_RDMA_SEND_COMPLETED) == 0) &#123; return 0; &#125; nvme_rdma_request_ready(rqpair, rdma_req): rdma_rsp = rdma_req-&gt;rdma_rsp; recv_wr = rdma_rsp-&gt;recv_wr; recv_wr-&gt;next = NULL; nvme_rdma_req_complete(rdma_req, &amp;rdma_rsp-&gt;cpl, true): req = rdma_req-&gt;req; qpair = rdma_req-&gt;req-&gt;qpair; rqpair = nvme_rdma_qpair(qpair); TAILQ_REMOVE(&amp;rqpair-&gt;outstanding_reqs, rdma_req, link); nvme_complete_request(req-&gt;cb_fn, req-&gt;cb_arg, qpair, req, rsp): _nvme_free_request(req, qpair); // 回收 req io_complete(cb_arg = perf_task, cpl): task_complete(task): ... // 计时、信息统计 nvme_rdma_req_put(rqpair, rdma_req); // 回收 rreq // 接收请求排队 // 疑问：为啥要提交接收请求？ // 可能是因为 RQ 队列需要随时准备 recv_wr 来随时准备接收？ spdk_rdma_qp_queue_recv_wrs(rqpair-&gt;rdma_qp, recv_wr): rdma_queue_recv_wrs(&amp;spdk_rdma_qp-&gt;recv_wrs, first, &amp;spdk_rdma_qp-&gt;stats-&gt;recv); // 提交接收请求 nvme_rdma_qpair_submit_recvs(rqpair): spdk_rdma_qp_flush_recv_wrs(rqpair-&gt;rdma_qp, &amp;bad_recv_wr); ibv_post_recv(spdk_rdma_qp-&gt;qp, spdk_rdma_qp-&gt;recv_wrs.first, bad_wr); /** 处理 send */ else (rdma_wr-&gt;type == RDMA_WR_TYPE_SEND): nvme_rdma_process_send_completion(poller, rdma_qpair, &amp;ibv_wc[i], rdma_wr): // rdma work request 类型为发送 rdma_req = SPDK_CONTAINEROF(rdma_wr, struct spdk_nvme_rdma_req, rdma_wr); rqpair = nvme_rdma_qpair(rdma_req-&gt;req-&gt;qpair); rdma_req-&gt;completion_flags |= NVME_RDMA_SEND_COMPLETED; // ？ if ((rdma_req-&gt;completion_flags &amp; NVME_RDMA_RECV_COMPLETED) == 0) &#123; return 0; &#125; /** 以下代码段没有执行 nvme_rdma_request_ready(rqpair, rdma_req): rdma_rsp = rdma_req-&gt;rdma_rsp; recv_wr = rdma_rsp-&gt;recv_wr; nvme_rdma_req_complete(rdma_req, &amp;rdma_rsp-&gt;cpl, true): qpair = rdma_req-&gt;req-&gt;qpair; rqpair = nvme_rdma_qpair(qpair); TAILQ_REMOVE(&amp;rqpair-&gt;outstanding_reqs, rdma_req, link); nvme_complete_request(req-&gt;cb_fn, req-&gt;cb_arg, qpair, req, rsp): _nvme_free_request(req, qpair); // 回收 req io_complete(cb_arg = perf_task, cpl): task_complete(task): ... // 计时、信息统计 nvme_rdma_req_put(rqpair, rdma_req); // 回收 rreq // 接收请求排队 // 疑问：为啥要接收请求？ spdk_rdma_qp_queue_recv_wrs(rqpair-&gt;rdma_qp, recv_wr): rdma_queue_recv_wrs(&amp;spdk_rdma_qp-&gt;recv_wrs, first, &amp;spdk_rdma_qp-&gt;stats-&gt;recv); // 提交接收请求 nvme_rdma_qpair_submit_recvs(rqpair): spdk_rdma_qp_flush_recv_wrs(rqpair-&gt;rdma_qp, &amp;bad_recv_wr); ibv_post_recv(spdk_rdma_qp-&gt;qp, spdk_rdma_qp-&gt;recv_wrs.first, bad_wr); **/ &#125; &#125; &#125; // 3. 活跃 QP 提交 send/recv 请求 TAILQ_FOREACH_SAFE(rqpair, &amp;group-&gt;active_qpairs, link_active, tmp_rqpair) &#123; nvme_rdma_qpair_process_submits(group, rqpair): // 提交 send_wrs 和 recv_wrs nvme_rdma_qpair_submit_sends(rqpair); nvme_rdma_qpair_submit_recvs(rqpair); // 重新提交 queued 请求 if (rqpair-&gt;num_completions &gt; 0): nvme_qpair_resubmit_requests(qpair, rqpair-&gt;num_completions); &#125; &#125; 检查 IO 完成情况大体步骤： CQ 收到 CQE 后，通过结构体偏移得到 WQE，判断是 SEND 还是 RECV 请求的完成消息； 只有当 WQE 指向的 rdma_req 的 completion_flags 为 SEND_COMPLETED &amp; RECV_COMPLETED 即发送和接收都完成了，才判断为 IO 任务完成； 通过 callback 得到原始 IO 任务； 记录时间，统计信息； IO 任务被复用，重新设置 io 偏移量以及随机读写，重复发送过程。","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"存储","slug":"notes/存储","permalink":"https://cs0522.github.io/categories/notes/%E5%AD%98%E5%82%A8/"}],"tags":[{"name":"存储","slug":"存储","permalink":"https://cs0522.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"SPDK","slug":"SPDK","permalink":"https://cs0522.github.io/tags/SPDK/"}]},{"title":"【学习笔记】SPDK（二）：SPDK NVMe over RDMA 部署","slug":"n-spdk-02","date":"2024-08-29T07:46:24.000Z","updated":"2025-01-17T18:57:47.133Z","comments":false,"path":"notes/存储/n-spdk-02/","link":"","permalink":"https://cs0522.github.io/notes/%E5%AD%98%E5%82%A8/n-spdk-02/","excerpt":"记录 SPDK NVMe over RDMA 的部署过程。","text":"记录 SPDK NVMe over RDMA 的部署过程。 环境准备 Ubuntu 22.04 虚拟机 x2 dev1，作为 Host 端，ip：192.168.246.129 dev2，作为 Target 端，ip：192.168.246.130 dev2 可以在 dev1 环境准备完成后进行 clone 2 块虚拟硬盘： SATA：用于安装 Ubuntu NVMe：用于绑定 spdk NVMe 硬盘不需要挂载和格式化，lsblk 结果如下： 12345678# lsblk# ...sda 8:0 0 60G 0 disk ├─sda1 8:1 0 1M 0 part ├─sda2 8:2 0 513M 0 part /boot/efi└─sda3 8:3 0 59.5G 0 part /var/snap/firefox common/ host-hunspell /nvme0n1 259:0 0 20G 0 disk 文件准备 需要下载的文件：（严格控制版本，不同版本可能会导致很多错误） spdk-24.05.x.zip isa-l_crypto-08297dc3e76d65e1bad83a9c9f9e49059cf806b5.zip libvfio-user-a646db0b7d65c774a0b9415ea582735e7c2d2eb6.zip dpdk-08f3a46de70afff49f55d175de690b5ad7e4a44d.zip xnvme-3834fd860d40b6a3608aae11f9ceb017a0c93b29.zip ocf-d1d6d7cb5f55b616d2aa5123f84ce4ece10fdb0b.zip isa-l-6f420b14a1e3e091bc9d15f508a54f82c007483c.zip intel-ipsec-mb-935a3802883249ba3b12e566833994af7991e808.zip 安装与构建 clone 项目源码 123456# pwd: ~/Workspace/spdk-24.05.x# clone 源码git clone -b v24.05.x git@github.com:spdk/spdk.git# 或者直接下载 zip 文件（推荐）# spdk-24.05.x.zip 更新子模块 12345678910111213141516171819202122# 更新子模块git submodule update --init# 建议手动 clone 子模块（网络原因）# 1. 根据 Github repo 中 spdk 版本对应的 submodule 版本，# 下载对应 zip 文件（严格控制版本一致）# dpdk-08f3a46de70afff49f55d175de690b5ad7e4a44d.zip# intel-ipsec-mb-935a3802883249ba3b12e566833994af7991e808.zip# isa-l-6f420b14a1e3e091bc9d15f508a54f82c007483c.zip# isa-l_crypto-08297dc3e76d65e1bad83a9c9f9e49059cf806b5.zip# libvfio-user-a646db0b7d65c774a0b9415ea582735e7c2d2eb6.zip# ocf-d1d6d7cb5f55b616d2aa5123f84ce4ece10fdb0b.zip# xnvme-3834fd860d40b6a3608aae11f9ceb017a0c93b29.zip# 2. 解压后文件夹名删掉 &#x27;-xxx&#x27; 字符串，# 并把它们复制到 spdk 根目录下# spdk/dpdk# spdk/intel-ipsec-mb# spdk/isa-l# spdk/isa-l-crypto# spdk/libvfio-user# spdk/ocf# spdk/xnvme 安装依赖 123456789101112131415# 安装各种依赖包# -r: 带 RDMAsudo ./scripts/pkgdep.sh -r# 出于网络原因，可以修改 sh 脚本，添加临时源# scripts/pkgdep/ubuntu.sh 下：pip3 install ninja -i https://pypi.doubanio.com/simplepip3 install meson -i https://pypi.doubanio.com/simplepip3 install pyelftools -i https://pypi.doubanio.com/simplepip3 install ijson -i https://pypi.doubanio.com/simplepip3 install python-magic -i https://pypi.doubanio.com/simplepip3 install grpcio -i https://pypi.doubanio.com/simplepip3 install grpcio-tools -i https://pypi.doubanio.com/simplepip3 install pyyaml -i https://pypi.doubanio.com/simplepip3 install Jinja2 -i https://pypi.doubanio.com/simplepip3 install tabulate -i https://pypi.doubanio.com/simple 打上 patch、修改代码 开发者说明 master 分支已经整合该 patch，v24.05.x 还未整合。 位于 lib/log/log.c。添加和修改以下代码（共 3 处）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// lib/log.log.cvoid spdk_vlog(enum spdk_log_level level, const char *file, const int line, const char *func, const char *format, va_list ap)&#123; int severity = LOG_INFO; char *buf, _buf[MAX_TMPBUF], *ext_buf = NULL; char timestamp[64]; va_list ap_copy; // 添加代码 int rc; if (g_log) &#123; g_log(level, file, line, func, format, ap); return; &#125; if (level &gt; g_spdk_log_print_level &amp;&amp; level &gt; g_spdk_log_level) &#123; return; &#125; severity = spdk_log_to_syslog_level(level); if (severity &lt; 0) &#123; return; &#125; buf = _buf; va_copy(ap_copy, ap); // 添加代码 rc = vsnprintf(_buf, sizeof(_buf), format, ap); if (rc &gt; MAX_TMPBUF) &#123; /* The output including the terminating was more than MAX_TMPBUF bytes. * Try allocating memory large enough to hold the output. */ rc = vasprintf(&amp;ext_buf, format, ap_copy); // 修改代码：ap -&gt; ap_copy if (rc &lt; 0) &#123; /* Failed to allocate memory. Allow output to be truncated. */ &#125; else &#123; buf = ext_buf; &#125; &#125; if (level &lt;= g_spdk_log_print_level) &#123; get_timestamp_prefix(timestamp, sizeof(timestamp)); if (file) &#123; // ...... 构建项目 123# 构建./configure --with-rdma --enable-debugmake 执行单元测试 12345678./test/unit/unittest.sh# 正确结果：# =====================# All unit tests passed# =====================# WARN: lcov not installed or SPDK built without coverage!# WARN: neither valgrind nor ASAN is enabled! 绑定 NVMe 设备 绑定 NVMe 设备： 1234567891011./scripts/setup.sh# 正确结果：# 0000:0b:00.0 (15ad 07f0): nvme -&gt; uio_pci_generic# 查看状态./scripts/setup.sh status# 正确结果：# Type BDF Vendor Device NUMA Driver Device Block devices# NVMe 0000:0b:00.0 15ad 07f0 unknown uio_pci_generic - - 则绑定成功。lsblk 中看不到 NVMe 设备。 若输出结果为： 10000:03:00.0 (15ad 07f0): Active devices: mount@nvme0n1:nvme0n1, so not binding PCI dev 且运行 build/examples/hello_world，若出现以下结果： 12345./build/examples/hello_world# 输出结果：# Initializing NVMe Controllers# no NVMe controllers found 说明没有 NVMe 设备或者 NVMe 设备处于挂载状态，无法解除内核驱动，此时需要将该设备初始化或者其他的方法。 添加 NVMe 设备后，NVMe 设备不能处于挂载状态，lsblk 结果： 12345678# lsblk# ...sda 8:0 0 60G 0 disk ├─sda1 8:1 0 1M 0 part ├─sda2 8:2 0 513M 0 part /boot/efi└─sda3 8:3 0 59.5G 0 part /var/snap/firefox common/host-hunspell /nvme0n1 259:0 0 50G 0 disk 再次绑定后测试，出现正确结果则成功。 取消绑定 1./scripts/setup.sh reset 部署 RDMA Soft-RoCE 参考 【学习笔记】NVMeoF（二）：NVMe over RDMA 环境部署 部署 RDMA 部分，部署好 RDMA Soft RoCE 软件栈。 仅部署 RDMA 部分，sh 脚本中从 # 1. config nvme subsystem 后的代码全部注释掉。 重启后需要重新部署一遍 RDMA 软件栈。 这部分结束可以对 dev1 进行克隆。 配置 SPDK NVMe over RDMA Target 端 Target 端 ip：192.168.246.130。 运行 nvmeof-setup.sh 脚本部署 RDMA Soft-RoCE 绑定 NVMe SSD 设备 1234567891011./scripts/setup.sh# 正确结果：# 0000:0b:00.0 (15ad 07f0): nvme -&gt; uio_pci_generic# 查看状态./scripts/setup.sh status# 正确结果：# Type BDF Vendor Device NUMA Driver Device Block devices# NVMe 0000:0b:00.0 15ad 07f0 unknown uio_pci_generic - - 这个 BDF 0000:0b:00.0 可能会变化，需要记住。 给 SPDK 分配大页（非必须） 12345echo 32768 | tee /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages# output:# 32768mkdir /dev/hugepages_2mbmount -t hugetlbfs none /dev/hugepages_2mb -o pagesize=2MB 启动 tgt 并监听 12345678910111213141516171819202122232425262728293031323334353637383940# 具体参数代表含义还没完全弄清，可以通过 --help 查询# 1. 启动 nvmf_tgt 并监听# 这里第一次可能没能启动成功，再试一次看到 succeed 就是成功build/bin/nvmf_tgt &amp; scripts/rpc.py nvmf_create_transport -t RDMA -u 8192 -i 131072 -c 8192# 2. 将 NVMe 控制器附加到 SPDK 的块设备层# 0000:0b:00.0 是上文的 BDF./scripts/rpc.py bdev_nvme_attach_controller -b NVMe1 -t PCIe -a 0000:0b:00.0# output:# NVMe1n1# 3. 创建 subsystem# cnode1、SPDK00000000000001 可以自定义./scripts/rpc.py nvmf_create_subsystem nqn.2016-06.io.spdk:cnode1 -a -s SPDK00000000000001 -d SPDK_Controller1# 4. 添加 namespace./scripts/rpc.py nvmf_subsystem_add_ns nqn.2016-06.io.spdk:cnode1 NVMe1n1# NVMe1n1 是 2 中的输出# 5. 添加监听# -a 是本机 ip，-s 是端口，可修改./scripts/rpc.py nvmf_subsystem_add_listener nqn.2016-06.io.spdk:cnode1 -t rdma -a 192.168.246.130 -s 4420# 6. 再添加 namespace再加一个ns./scripts/rpc.py bdev_nvme_attach_controller -b NVMe2 -t PCIe -a 0000:0b:00.0# outout:# NVMe2n1./scripts/rpc.py nvmf_subsystem_add_ns nqn.2016-06.io.spdk:cnode1 NVMe2n1# 获取 subsystem 信息./scripts/rpc.py nvmf_get_subsystems# 删除 subsystem./scripts/rpc.py nvmf_delete_subsystem nqn.2016-06.io.spdk:cnode1# 删除 ns# ns_id 通过 nvmf_get_subsystems 获取./scripts/rpc.py nvmf_remove_ns &lt;nsid&gt;# 移除监听./scripts/rpc.py nvmf_subsystem_remove_listener nqn.2016-06.io.spdk:cnode1 -t rdma -a 192.168.246.130 -s 4420 配置 SPDK NVMe over RDMA Host 端 Host 端 ip：192.168.246.129。 运行 nvmeof-setup.sh 脚本部署 RDMA Soft-RoCE SPDK 初始化 1234./scripts/setup.sh# 正确结果：# 0000:0b:00.0 (15ad 07f0): nvme -&gt; uio_pci_generic 发现 Target 并连接（与 SPDK 无关） 这一步执行的是 nvme-cli 的命令，需要经过 kernel 驱动，而 SPDK 是用户态驱动。可以直接跳过这一步直接运行 SPDK 的应用程序。 1234567891011121314151617181920212223242526# 发现nvme discover -t rdma -a 192.168.246.130 -s 4420# output: # =====Discovery Log Entry 0======# trtype: rdma# adrfam: ipv4# subtype: nvme subsystem# treq: not required# portid: 0# trsvcid: 4420# subnqn: nqn.2016-06.io.spdk:cnode1# traddr: 192.168.246.130# rdma_prtype: not specified# rdma_qptype: connected# rdma_cms: rdma-cm# rdma_pkey: 0x0000# 连接nvme connect -t rdma -n &quot;nqn.2016-06.io.spdk:cnode1&quot; -a 192.168.246.130 -s 4420# 查看设备nvme listlsblk# 都可以看到连接的 nvme 设备 简单测试 1234567891011121314151617181920212223242526# 用 spdk 自带的 perf 进行测试./build/bin/spdk_nvme_perf -r &#x27;trtype:rdma adrfam:IPv4 traddr:192.168.246.130 trsvcid:4420&#x27; -q 256 -o 4096 -w randread -t 100# 一些参数含义# -q, --io-depth &lt;val&gt; io depth# -o, --io-size &lt;val&gt; io size in bytes# -w, --io-pattern &lt;pattern&gt; io pattern type, must be one of: # (read, write, randread, randwrite, rw, randrw)# -t, --time &lt;sec&gt; time in seconds# -r, --transport &lt;fmt&gt; Transport ID for local PCIe NVMe or NVMeoF# 对于同时测试多块盘，只需要添加多个 -r 指定设备地址即可# output:# ===== spdk_nvme_perf start =====# Initializing NVMe Controllers# Attached to NVMe over Fabrics controller at 192.168.246.130:4420: nqn.2016-06.io.spdk:cnode1# Controller IO queue size 128, less than required.# Consider using lower queue depth or smaller IO size, because IO requests may be queued at the NVMe driver.# Associating RDMA (addr:192.168.246.130 subnqn:nqn.2016-06.io.spdk:cnode1) NSID 1 with lcore 0# Initialization complete. Launching workers.# ========================================================# Latency(us)#Device Information : IOPS MiB/s Average min max#RDMA (addr:192.168.246.130 subnqn:nqn.2016-06.io.spdk:cnode1) NSID 1 from core 0: 6091.58 23.80 42033.57 3583.64 87966.63#========================================================#Total : 6091.58 23.80 42033.57 3583.64 87966.63 测试结果图： 这里测试结果的值较低，可能是因为虚拟机的缘故？ 取消连接（与 SPDK 无关） 如果执行了前面的 nvme connect 命令连接设备，则这里执行 nvme disconnect 命令取消连接。 1nvme disconnect -n &quot;nqn.2016-06.io.spdk:cnode1&quot; 恢复内核态驱动 1./scripts/setup.sh reset","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"存储","slug":"notes/存储","permalink":"https://cs0522.github.io/categories/notes/%E5%AD%98%E5%82%A8/"}],"tags":[{"name":"存储","slug":"存储","permalink":"https://cs0522.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"SPDK","slug":"SPDK","permalink":"https://cs0522.github.io/tags/SPDK/"}]},{"title":"【学习笔记】SPDK（一）初识 SPDK 框架","slug":"n-spdk-01","date":"2024-08-27T05:10:46.000Z","updated":"2025-01-17T18:57:47.133Z","comments":false,"path":"notes/存储/n-spdk-01/","link":"","permalink":"https://cs0522.github.io/notes/%E5%AD%98%E5%82%A8/n-spdk-01/","excerpt":"了解 SPDK。","text":"了解 SPDK。 简介 SPDK 存储性能开发套件（Storage Performance Development Kit）—— 针对于支持 NVMe 协议的 SSD 设备。 是 Intel 发布的，提供了一整套工具和库，以实现高性能、扩展性强、全用户态的存储应用程序。它是继 DPDK 之后，Intel 在存储领域推出的又一项颠覆性技术，旨在大幅缩减存储 I/O 栈的软件开销，从而提升存储性能，可以说它就是为了存储性能而生。 SPDK 的基础是用户态、轮询、异步、无锁 NVMe 驱动。这提供了从用户空间应用程序直接访问 SSD 的零拷贝、高度并行的访问。 SPDK 引入目的和优势 详见：为什么用 SPDK？ 总结版： 传统 I/O SPDK 以前的 I/O 栈针对 HDD 做了诸多优化：page cache等；内核采用中断方式进行 DMA； 这样的优化会使 SSD 存在空缺，不能充分利用。 会存在大量的内核上下文切换和中断，造成大量的延迟和开销。 SPDK 采用将设备驱动代码放在用户态（userspace I/O），避免内核上下文切换。spdk 采用轮询（polling）模式代替。 应用程序提交读写请求后进入睡眠状态，一旦 I/O 完成，中断就会将其唤醒。 应用程序提交读写请求后继续执行其他工作，以一定的时间间隔回头检查 I/O 是否已经完成。（因为 SSD 很快，传统方式会导致 “请求后进入睡眠再醒来过程太慢”） 中断开销只占整个 I/O 时间（I/O 读取慢）的很小的百分比，因此给系统带来了巨大的效率提升。 持续引入更低时延的持久化设备，I/O 读取变快，中断开销成为了整个 I/O 时间中不可忽视的部分。所以需要去优化，使其达到平衡。 SPDK 关键技术 将所有必要的驱动程序移动到用户空间，从而避免 syscalls，并允许可以直接使用用户态内存落盘实现零拷贝。 对硬件进行完成轮询，而不是依赖中断，降低了总延迟。 任何业务都可以在 spdk 的线程中将轮询函数注册为 poller，注册之后该函数会在 spdk 中周期性的执行，避免了 epoll 等事件通知机制造成的 overhead。 避免 I/O 路径中的所有锁，使用无锁队列传递消息 I/O。 为了降低这种性能开销，spdk 引入了无锁队列，使用 lock-free 编程，从而避免锁带来的性能损耗。 spdk 的无锁队列主要依赖的 dpdk 的实现，其本质是使用 cas（compare and swap）实现了多生产者多消费者 FIFO 队列。 SPDK 主要运用了两项关键技术：用户态 I/O（UI/O）和轮询（polling）。 因此 SPDK 的实施目标就是：要在用户态实施一套基于用户态软件驱动的完整 I/O 栈,避免在 spdk 核上出现进程上下文切换。 SPDK 软件架构 底层：驱动层（Drivers） 包括：NVMe PCIe 驱动，以及 NVMe-oF 驱动。 中间层：存储服务层（Storage Services） 核心是提供了一个块设备抽象层，并实现了块设备的常见功能如逻辑卷、快照、克隆。 bdev 的 API 与 Linux 文件系统的 API 非常类似，主要是打开关闭设备和进行数据读写等功能。 上层：存储协议层（Storage Protocols） 通过存储协议访问 NVMe 提供的存储功能。 SPDK 项目结构 ./app（核心） 包含 build/bin/ 中应用程序的源代码，可以以这些应用程序的源代码 ./app/* 作为切入点学习 SPDK 的使用和实现。 ./lib（核心） 核心功能，以库的形式提供，如事件、线程模型等。 ./module（核心） 实现中间层存储服务层相关的功能。 ./examples 包含一些使用参考，可以进行学习，如 examples/nvme/hello_world。 ./scripts 包含一些 sh 脚本，方便一些操作。如 ./scripts/setup.sh 用于从内核驱动中绑定和取消绑定设备；./scripts/pkgdep.sh 用于安装依赖。 ./tests 测试文件，单元测试、函数功能测试。 SPDK hello_world 示例分析 源代码位于 examples/nvme/hello_world 下，可执行文件位于 build/examples/hello_world 下。通过 hello_world 入门 SPDK 的运行流程，了解 SPDK 用户态驱动的主要工作流程和方式。 参考文章 spdk 入门 hello_world 源码解析","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"存储","slug":"notes/存储","permalink":"https://cs0522.github.io/categories/notes/%E5%AD%98%E5%82%A8/"}],"tags":[{"name":"存储","slug":"存储","permalink":"https://cs0522.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"SPDK","slug":"SPDK","permalink":"https://cs0522.github.io/tags/SPDK/"}]},{"title":"【学习笔记】NVMeoF（二）：NVMe over RDMA 环境部署","slug":"n-nvmeof-02","date":"2024-08-25T08:42:26.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/存储/n-nvmeof-02/","link":"","permalink":"https://cs0522.github.io/notes/%E5%AD%98%E5%82%A8/n-nvmeof-02/","excerpt":"NVMe over RDMA 环境部署记录。","text":"NVMe over RDMA 环境部署记录。 前提虚拟机环境要求： 1. Ubuntu 22.04 2. Ubuntu 虚拟机的磁盘配置为 NVMe 3. clone 为两份虚拟机，一份为 Host 端，一份为 Target 端 1. 自动部署软件栈 sh 脚本 以 root 权限运行： 1sudo sh ./rdma-setup.sh 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# rdma-setup.sh#!/bin/bash# @CS0522# rdma setup# run with root# DOING:# 1. Install tools# 2. Setup rdma &amp; nvme# install apt-get install vim open-vm-tools open-vm-tools-desktop net-tools nvme-cli fio# rdma user space toolsapt-get install libibverbs1 ibverbs-utils librdmacm1 libibumad3 ibverbs-providers rdma-core# rdma test toolapt-get install perftest# get local IP addresslocal_ip=`ifconfig -a | grep inet | grep -v 127.0.0.1 | grep -v inet6 | awk &#x27;&#123;print $2&#125;&#x27; | tr -d &quot;addr:&quot;`echo local_ip=&quot;$&#123;local_ip&#125;&quot;# get device namenet_dev=`ifconfig | grep -w BROADCAST | awk &#x27;&#123;print $1&#125;&#x27; | sed &#x27;s/://g&#x27;`echo net_dev=&quot;$&#123;net_dev&#125;&quot;# modprobe RXE NICmodprobe rdma_rxerdma link add rxe_0 type rxe netdev $&#123;net_dev&#125;# modprobe nvmemodprobe nvmetmodprobe nvmet-rdmamodprobe nvme-rdma# 1. config nvme subsystemsubsys_name=&quot;nvme-rdma-test&quot;echo subsys_name=&quot;$&#123;subsys_name&#125;&quot;mkdir /sys/kernel/config/nvmet/subsystems/&quot;$&#123;subsys_name&#125;&quot;cd /sys/kernel/config/nvmet/subsystems/&quot;$&#123;subsys_name&#125;&quot;# 2. allow any host to be connected to this targetecho 1 &gt; attr_allow_any_host# 3. create a namespace，example: nsid=10nsid=10echo nsid=&quot;$&#123;nsid&#125;&quot;mkdir namespaces/&quot;$&#123;nsid&#125;&quot;cd namespaces/&quot;$&#123;nsid&#125;&quot;# 4. set the path to the NVMe deviceecho -n /dev/nvme0n1&gt; device_pathecho 1 &gt; enable# 5. create the following directory with an NVMe portportid=1echo portid=&quot;$&#123;portid&#125;&quot;mkdir /sys/kernel/config/nvmet/ports/&quot;$&#123;portid&#125;&quot;cd /sys/kernel/config/nvmet/ports/&quot;$&#123;portid&#125;&quot;# 6. set ip address to traddrecho &quot;$&#123;local_ip&#125;&quot; &gt; addr_traddr# 7. set rdma as a transport type，addr_trsvcid is unique.echo rdma &gt; addr_trtypeecho 4420 &gt; addr_trsvcid# 8. set ipv4 as the Address familyecho ipv4 &gt; addr_adrfam# 9. create a soft linkln -s /sys/kernel/config/nvmet/subsystems/&quot;$&#123;subsys_name&#125;&quot; /sys/kernel/config/nvmet/ports/&quot;$&#123;portid&#125;&quot;/subsystems/&quot;$&#123;subsys_name&#125;&quot;# 10. Check dmesg to make sure that the NVMe target is listening on the portdmesg -T | grep &quot;enabling port&quot;# 11. output info &lt; ip/port&gt;# XXX nvmet_rdma: enabling port 1 (192.168.225.131:4420)# 12. check the status of nvmelsblk | grep nvme# nvme0n1 运行结果： 2. 手动部署——RDMA 2.1. 确认内核是否支持 123456cat /boot/config-$(uname -r) | grep RXE# output:# CONFIG_RDMA_RXE=m# if not m or y, then cannot support RXE 2.2. 安装环境依赖、工具 12345apt-get install vim open-vm-tools open-vm-tools-desktop net-tools nvme-cli fioapt-get install libibverbs1 ibverbs-utils librdmacm1 libibumad3 ibverbs-providers rdma-coreapt-get install perftest 2.3. 获取 IP 地址、NIC 设备名 12345678ifconfig -a# output:# ens33: ......# inet: 192.168.159.140# ......# net_dev = ens33# local_ip = 192.168.159.140 2.4. 配置 RXE 网卡 1234567# 加载内核驱动modprobe rdma_rxe# 用户态配置sudo rdma link add rxe_0 type rxe netdev ens33# rxe_0: RDMA 设备名，可任意取名# ens33: 网卡名，会发生变化，根据机器 ifconfig 的结果为准 2.5. RDMA 配置结果检验 123456789101112rdma link# example output: # link rxe_0/1 state ACTIVE physical_state LINK_UP netdev ens33ibv_devinfo -d rxe_0# example output: # hca_id: rxe_0# ...# port: 1# state: PORT_ACTIVE# ...... 3. 手动部署——NVMe 3.1. 加载 NVMe 相关内核 123modprobe nvmetmodprobe nvmet-rdmamodprobe nvme-rdma 3.2. 配置 nvme subsystem 123# subsys_name 可替换mkdir /sys/kernel/config/nvmet/subsystems/&lt;subsys_name&gt;cd /sys/kernel/config/nvmet/subsystems/&lt;subsys_name&gt; 3.3. Allow any host to be connected to this target 1echo 1 &gt; attr_allow_any_host 3.4. Create a namespace，example: nsid=10 123# nsid 可替换mkdir namespaces/&lt;nsid&gt;cd namespaces/&lt;nsid&gt; 3.5. Set the path to the NVMe device 12echo -n /dev/nvme0n1&gt; device_pathecho 1 &gt; enable 3.6. Create the following directory with an NVMe port 123# portid 可替换mkdir /sys/kernel/config/nvmet/ports/&lt;portid&gt;cd /sys/kernel/config/nvmet/ports/&lt;portid&gt; 3.7. Set ip address to traddr 12# local_ip 为 ifconfig 中的结果echo &lt;local_ip&gt; &gt; addr_traddr 3.8. Set rdma as a transport type，addr_trsvcid is unique 12echo rdma &gt; addr_trtypeecho 4420 &gt; addr_trsvcid 3.9. Set ipv4 as the Address family 1echo ipv4 &gt; addr_adrfam 3.10. create a soft link 12# subsys_name、portid 可替换ln -s /sys/kernel/config/nvmet/subsystems/&lt;subsys_name&gt; /sys/kernel/config/nvmet/ports/&lt;portid&gt;/subsystems/&lt;subsys_name&gt; 3.11. Check dmesg to make sure that the NVMe target is listening on the port 1234dmesg -T | grep &quot;enabling port&quot;# output: # nvmet_rdma: enabling port 1 (192.168.225.131:4420) 3.12. Check the status of NVMe 12lsblk | grep nvme# nvme0n1 4. NVMe over RDMA 环境验证 虚拟机重启后需要重新配置 RDMA 部分 Host 端执行： 1ib_send_bw -d rxe_0 Target 端执行： 123ib_send_bw -d rxe_0 &lt;server_ip&gt;# ib_send_bw -d rxe_0 192.168.159.141 Target 端执行后，两端的运行输出如下： Host 端： Target 端： 在 Target 端发现 Host 端的 NVMe 设备： 1sudo nvme discover -t rdma -q &lt;subsys_name&gt; -a &lt;server_ip&gt; -s 4420 结果： 在 Target 端连接 Host 端的 NVMe 设备： 1sudo nvme connect -t rdma -q &lt;subsys_name&gt; -n &lt;subsys_name&gt; -a &lt;server_ip&gt; -s 4420 结果： 断开连接： 1sudo nvme disconnect -n &lt;subsys_name&gt;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"存储","slug":"notes/存储","permalink":"https://cs0522.github.io/categories/notes/%E5%AD%98%E5%82%A8/"}],"tags":[{"name":"存储","slug":"存储","permalink":"https://cs0522.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"NVMe","slug":"NVMe","permalink":"https://cs0522.github.io/tags/NVMe/"}]},{"title":"【刷题日记】二叉树-二叉树的最小深度-L111-Easy","slug":"p-tree-minDepth-L111","date":"2024-08-22T14:52:09.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/p-tree-minDepth-L111/","link":"","permalink":"https://cs0522.github.io/practices/p-tree-minDepth-L111/","excerpt":"给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。","text":"给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 思路 层序遍历，当出现首个没有左、右子树的节点时，该节点为首个叶子节点，其拥有最短深度。 学习点 代码 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int minDepth(TreeNode* root) &#123; int depth = 0; queue&lt;TreeNode*&gt; qe; if (root) qe.push(root); while (!qe.empty()) &#123; int node_num = qe.size(); for (int i = 0; i &lt; node_num; i++) &#123; auto tmp = qe.front(); qe.pop(); // 如果没有左右子树，则该节点为叶子节点，为最短深度 if (!tmp-&gt;left &amp;&amp; !tmp-&gt;right) return depth + 1; else &#123; if (tmp-&gt;left) qe.push(tmp-&gt;left); if (tmp-&gt;right) qe.push(tmp-&gt;right); &#125; &#125; ++depth; &#125; return depth; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"【刷题日记】二叉树-二叉树的最大深度-L104-Easy","slug":"p-tree-maxDepth-L104","date":"2024-08-22T14:51:58.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/二叉树/p-tree-maxDepth-L104/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-maxDepth-L104/","excerpt":"给定一个二叉树 root ，返回其最大深度。 二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。","text":"给定一个二叉树 root ，返回其最大深度。 二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。 思路 层序遍历，每次遍历一层后，depth 计数加 1。 学习点 代码 1234567891011121314151617181920212223242526class Solution &#123;public: int maxDepth(TreeNode* root) &#123; int depth = 0; queue&lt;TreeNode*&gt; qe; if (root) qe.push(root); while (!qe.empty()) &#123; int node_num = qe.size(); for (int i = 0; i &lt; node_num; i++) &#123; auto tmp = qe.front(); qe.pop(); if (tmp-&gt;left) qe.push(tmp-&gt;left); if (tmp-&gt;right) qe.push(tmp-&gt;right); &#125; ++depth; &#125; return depth; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-填充每个节点的下一个右侧节点指针-L116-Medium","slug":"p-tree-nextRightPointers-L116","date":"2024-08-22T11:29:45.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/二叉树/p-tree-nextRightPointers-L116/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-nextRightPointers-L116/","excerpt":"给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。","text":"给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。 初始状态下，所有 next 指针都被设置为 NULL。 思路 层序遍历，遍历过程中每层的每个节点的 next 指针指向队列中的头节点（他的同层右节点）；每层的最后一个节点需要特殊处理。 学习点 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Definition for a Node.class Node &#123;public: int val; Node* left; Node* right; Node* next; Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125; Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125; Node(int _val, Node* _left, Node* _right, Node* _next) : val(_val), left(_left), right(_right), next(_next) &#123;&#125;&#125;;class Solution &#123;public: Node* connect(Node* root) &#123; queue&lt;Node*&gt; qe; if (root) qe.push(root); while (!qe.empty()) &#123; int node_num = qe.size(); for (int i = 0; i &lt; node_num; i++) &#123; auto tmp = qe.front(); qe.pop(); // 设置他的 next 指针 if (!qe.empty() &amp;&amp; i != node_num - 1) &#123; auto tmp_next = qe.front(); tmp-&gt;next = tmp_next; &#125; if (tmp-&gt;left) qe.push(tmp-&gt;left); if (tmp-&gt;right) qe.push(tmp-&gt;right); &#125; &#125; return root; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-在每个树行中找最大值-L515-Medium","slug":"p-tree-maxOfLevel-L515","date":"2024-08-22T11:20:27.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/二叉树/p-tree-maxOfLevel-L515/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-maxOfLevel-L515/","excerpt":"给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。","text":"给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。 思路 层序遍历，记录每层的最大值。 学习点 代码 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;int&gt; largestValues(TreeNode* root) &#123; vector&lt;int&gt; res; if (!root) return res; queue&lt;TreeNode*&gt; qe; qe.push(root); while (!qe.empty()) &#123; int node_num = qe.size(); int max_of_level = qe.front()-&gt;val; for (int i = 0; i &lt; node_num; i++) &#123; auto tmp = qe.front(); qe.pop(); if (max_of_level &lt; tmp-&gt;val) max_of_level = tmp-&gt;val; if (tmp-&gt;left) qe.push(tmp-&gt;left); if (tmp-&gt;right) qe.push(tmp-&gt;right); &#125; res.push_back(max_of_level); &#125; return res; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-N叉树的层序遍历-L429-Medium","slug":"p-tree-NaryLevelTraversal-L429","date":"2024-08-22T11:10:10.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/二叉树/p-tree-NaryLevelTraversal-L429/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-NaryLevelTraversal-L429/","excerpt":"给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。","text":"给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。 思路 层序遍历，在加入下一层的子树时循环加入子树的节点。 学习点 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val) &#123; val = _val; &#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; if (!root) return res; queue&lt;Node*&gt; qe; qe.push(root); while (!qe.empty()) &#123; int node_num = qe.size(); vector&lt;int&gt; level_res; for (int i = 0; i &lt; node_num; i++) &#123; auto tmp = qe.front(); qe.pop(); level_res.push_back(tmp-&gt;val); // 加入子树 auto children_num = tmp-&gt;children.size(); for (int j = 0; j &lt; children_num; j++) &#123; if (tmp-&gt;children[j]) qe.push(tmp-&gt;children[j]); &#125; &#125; res.push_back(level_res); &#125; return res; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-二叉树的层平均值-L637-Easy","slug":"p-tree-avgOfLevel-L637","date":"2024-08-22T11:02:42.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/二叉树/p-tree-avgOfLevel-L637/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-avgOfLevel-L637/","excerpt":"给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。","text":"给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。 思路 二叉树层序遍历，计算每层的总和后结果集中压入平均值。 学习点 代码 123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123; vector&lt;double&gt; res; if (!root) return res; queue&lt;TreeNode*&gt; qe; qe.push(root); while (!qe.empty()) &#123; int node_num = qe.size(); double sum_of_level = 0; for (int i = 0; i &lt; node_num; i++) &#123; auto tmp = qe.front(); qe.pop(); sum_of_level += tmp-&gt;val; if (tmp-&gt;left) qe.push(tmp-&gt;left); if (tmp-&gt;right) qe.push(tmp-&gt;right); &#125; res.push_back(sum_of_level / node_num * 1.0); &#125; return res; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-二叉树的右视图-L199-Medium","slug":"p-tree-rightSide-L199","date":"2024-08-22T07:31:47.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/二叉树/p-tree-rightSide-L199/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-rightSide-L199/","excerpt":"给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。","text":"给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 思路 二叉树的层序遍历，但仅仅在结果集中加入每层的最后一个节点的值。 若考虑通过深度遍历去遍历右子树，但从 右视图 视角来看，如果右子树为空，则右视图会看到左子树的最右边的节点，因此这个思路不正确。 学习点 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; // 层序遍历，只弹出最后一个节点 vector&lt;int&gt; res; if (root == nullptr) return res; queue&lt;TreeNode*&gt; qe; qe.push(root); while (!qe.empty()) &#123; int node_num = qe.size(); for (int i = 0; i &lt; node_num; i++) &#123; auto tmp = qe.front(); qe.pop(); if (i == node_num - 1) res.push_back(tmp-&gt;val); if (tmp-&gt;left) qe.push(tmp-&gt;left); if (tmp-&gt;right) qe.push(tmp-&gt;right); &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-二叉树的层序遍历II-L107-Medium","slug":"p-tree-levelTraversalII-L107","date":"2024-08-21T04:50:53.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/二叉树/p-tree-levelTraversalII-L107/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-levelTraversalII-L107/","excerpt":"给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）","text":"给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 思路 相比于 L102 的正序层序遍历，只需要将 res 的第一维（层级的顺序，而不是其中的元素的顺序）倒序即可。 学习点 代码 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; // result vector&lt;vector&lt;int&gt;&gt; res; if (root == nullptr) return res; // queue queue&lt;TreeNode*&gt; qe; qe.push(root); while (!qe.empty()) &#123; int node_num = qe.size(); vector&lt;int&gt; level_traverse; for (int i = 0; i &lt; node_num; i++) &#123; auto tmp = qe.front(); qe.pop(); level_traverse.push_back(tmp-&gt;val); if (tmp-&gt;left) qe.push(tmp-&gt;left); if (tmp-&gt;right) qe.push(tmp-&gt;right); &#125; res.push_back(level_traverse); &#125; // 相比于正序遍历只需要倒序第一维 reverse(res.begin(), res.end()); return res; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-二叉树的层序遍历-L102-Medium","slug":"p-tree-levelTraversal-L102","date":"2024-08-21T04:50:23.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/二叉树/p-tree-levelTraversal-L102/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-levelTraversal-L102/","excerpt":"给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。","text":"给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 思路 层序遍历使用队列。题目需要按照不同层来输出，因此使用 pair 来组合 TreeNode 和 levelIndex 来标记节点的层级。 使用队列。使用 size (queue.size()) 记录二叉树每层的节点数。每层遍历的时候都会弹空队列，然后加入下层的所有节点。这时候队列的 size 即为下一层的节点个数。 学习点 用 queue.size() 记录每层的节点个数。 代码 我的： 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; // result vector&lt;vector&lt;int&gt;&gt; res; if (root == nullptr) return res; // &lt;node, level&gt; queue&lt;pair&lt;TreeNode*, int&gt;&gt; qe; qe.push(make_pair&lt;&gt;(root, 0)); int curr_level = -1; while (!qe.empty()) &#123; auto p = qe.front(); qe.pop(); // 遍历到新的层 if (curr_level != p.second) &#123; vector&lt;int&gt; tmp; res.push_back(tmp); &#125; // 加入结果集 res[res.size() - 1].push_back(p.first-&gt;val); // 加入队列 if (p.first-&gt;left) qe.push(make_pair&lt;&gt;(p.first-&gt;left, p.second + 1)); if (p.first-&gt;right) qe.push(make_pair&lt;&gt;(p.first-&gt;right, p.second + 1)); curr_level = p.second; &#125; return res; &#125;&#125;; 第二个思路： 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; // result vector&lt;vector&lt;int&gt;&gt; res; if (root == nullptr) return res; // queue queue&lt;TreeNode*&gt; qe; qe.push(root); while (!qe.empty()) &#123; int node_num = qe.size(); vector&lt;int&gt; level_traverse; for (int i = 0; i &lt; node_num; i++) &#123; auto tmp = qe.front(); qe.pop(); level_traverse.push_back(tmp-&gt;val); if (tmp-&gt;left) qe.push(tmp-&gt;left); if (tmp-&gt;right) qe.push(tmp-&gt;right); &#125; res.push_back(level_traverse); &#125; return res; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-统一迭代法遍历-L94、144、145","slug":"p-tree-iterTraversal","date":"2024-08-21T04:45:56.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/二叉树/p-tree-iterTraversal/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-iterTraversal/","excerpt":"二叉树的统一迭代法遍历。","text":"二叉树的统一迭代法遍历。 思路 将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记：要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 学习点 代码 前序遍历： 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; if (root != NULL) st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); if (node != NULL) &#123; st.pop(); if (node-&gt;right) st.push(node-&gt;right); // 右 if (node-&gt;left) st.push(node-&gt;left); // 左 st.push(node); // 中 st.push(NULL); &#125; else &#123; st.pop(); node = st.top(); st.pop(); result.push_back(node-&gt;val); &#125; &#125; return result; &#125;&#125;; 中序遍历： 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; if (root != NULL) st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); if (node != NULL) &#123; st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node-&gt;right) st.push(node-&gt;right); // 添加右节点（空节点不入栈） st.push(node); // 添加中节点 st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node-&gt;left) st.push(node-&gt;left); // 添加左节点（空节点不入栈） &#125; else &#123; // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.top(); // 重新取出栈中元素 st.pop(); result.push_back(node-&gt;val); // 加入到结果集 &#125; &#125; return result; &#125;&#125;; 后序遍历： 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; if (root != NULL) st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); if (node != NULL) &#123; st.pop(); st.push(node); // 中 st.push(NULL); if (node-&gt;right) st.push(node-&gt;right); // 右 if (node-&gt;left) st.push(node-&gt;left); // 左 &#125; else &#123; st.pop(); node = st.top(); st.pop(); result.push_back(node-&gt;val); &#125; &#125; return result; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-中序遍历-L94-Easy","slug":"p-tree-inOrder-L94","date":"2024-08-20T09:12:23.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/二叉树/p-tree-inOrder-L94/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-inOrder-L94/","excerpt":"给你二叉树的根节点 root ，返回它节点值的 中序 遍历。","text":"给你二叉树的根节点 root ，返回它节点值的 中序 遍历。 思路 递归法。 迭代法。 学习点 迭代法需要特殊处理。需要额外定义一个指针指向正在处理的节点，否则在回溯节点的时候，会重复遍历之前访问过的节点。 代码 递归法： 123456789101112131415161718192021class Solution&#123;public: void inOrder(TreeNode *root, vector&lt;int&gt; &amp;res) &#123; // 递归终止 if (root == nullptr) return; // 左中右 inOrder(root-&gt;left, res); res.push_back(root-&gt;val); inOrder(root-&gt;right, res); &#125; vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; res; inOrder(root, res); return res; &#125;&#125;; 迭代法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution&#123;public: void inOrder(TreeNode *root, vector&lt;int&gt; &amp;res) &#123; // 递归终止 if (root == nullptr) return; // 左中右 inOrder(root-&gt;left, res); res.push_back(root-&gt;val); inOrder(root-&gt;right, res); &#125; vector&lt;int&gt; inorderTraversal(TreeNode *root) &#123; // vector&lt;int&gt; res; // inOrder(root, res); // return res; // 迭代法 vector&lt;int&gt; res; stack&lt;TreeNode*&gt; st; TreeNode* curr = root; while (curr != nullptr || !st.empty()) &#123; // 左 if (curr != nullptr) &#123; st.push(curr); curr = curr-&gt;left; &#125; // 中、右 else &#123; curr = st.top(); st.pop(); res.push_back(curr-&gt;val); curr = curr-&gt;right; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-后序遍历-L145-Easy","slug":"p-tree-postOrder-L145","date":"2024-08-20T09:12:15.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/二叉树/p-tree-postOrder-L145/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-postOrder-L145/","excerpt":"给你二叉树的根节点 root ，返回它节点值的 后序 遍历。","text":"给你二叉树的根节点 root ，返回它节点值的 后序 遍历。 思路 递归法。 迭代法。 学习点 迭代法与前序遍历顺序部分相反，前序为 中左右，倒序后为 右左中，则在前序遍历入栈的顺序改为先入左子树后入右子树即可。 代码 递归法： 1234567891011121314151617181920class Solution&#123;public: void postOrder(TreeNode *root, vector&lt;int&gt; &amp;res) &#123; if (root == nullptr) return; // 左右中 postOrder(root-&gt;left, res); postOrder(root-&gt;right, res); res.push_back(root-&gt;val); &#125; vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; res; postOrder(root, res); return res; &#125;&#125;; 迭代法： 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution&#123;public: void postOrder(TreeNode *root, vector&lt;int&gt; &amp;res) &#123; if (root == nullptr) return; // 左右中 postOrder(root-&gt;left, res); postOrder(root-&gt;right, res); res.push_back(root-&gt;val); &#125; vector&lt;int&gt; postorderTraversal(TreeNode *root) &#123; // vector&lt;int&gt; res; // postOrder(root, res); // return res; // 迭代法 vector&lt;int&gt; res; stack&lt;TreeNode*&gt; st; if (root == nullptr) return; st.push(root); while (!st.empty()) &#123; auto p = st.top(); st.pop(); res.push_back(p-&gt;val); // 空值不入栈 if (p-&gt;left) st.push(p-&gt;left); if (p-&gt;right) st.push(p-&gt;right); &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-前序遍历-L144-Easy","slug":"p-tree-preOrder-L144","date":"2024-08-20T09:11:57.000Z","updated":"2025-01-17T18:57:47.141Z","comments":false,"path":"practices/二叉树/p-tree-preOrder-L144/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-preOrder-L144/","excerpt":"给你二叉树的根节点 root ，返回它节点值的 前序 遍历。","text":"给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 思路 递归法。 迭代法。 学习点 注意递归三要素：终止条件、返回值、递归操作 代码 递归法： 1234567891011121314151617181920212223242526272829303132333435struct TreeNode&#123; int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;&#125;;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Solution&#123;public: void preOrder(TreeNode *root, vector&lt;int&gt; &amp;res) &#123; // 递归终止 if (root == nullptr) return; // 中左右 res.push_back(root-&gt;val); preOrder(root-&gt;left, res); preOrder(root-&gt;right, res); &#125; vector&lt;int&gt; preorderTraversal(TreeNode *root) &#123; vector&lt;int&gt; res; preOrder(root, res); return res; &#125;&#125;; 迭代法： 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); st.pop(); result.push_back(node-&gt;val); if (node-&gt;right) st.push(node-&gt;right); // 右（空节点不入栈） if (node-&gt;left) st.push(node-&gt;left); // 左（空节点不入栈） &#125; return result; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【刷题日记】二叉树-二叉树理论基础","slug":"p-tree-basic","date":"2024-08-20T04:56:46.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/二叉树/p-tree-basic/","link":"","permalink":"https://cs0522.github.io/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/p-tree-basic/","excerpt":"二叉树理论基础。","text":"二叉树理论基础。 二叉树的种类 满二叉树 完全二叉树 优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。 二叉搜索树 二叉搜索树是有数值的，二叉搜索树是一个有序树。 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树 平衡二叉搜索树（AVL 树） 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 C++ 中 map、set、multimap、multiset 的底层实现都是平衡二叉搜索树，所以 map、set 的增删操作时间时间复杂度是 O(logn)。 unordered_map、unordered_set 底层实现是哈希表。 二叉树的存储 链式存储 类似链表 顺序存储 数组存储 二叉树的遍历 二叉树主要有两种遍历方式： 深度优先遍历：先往深走，遇到叶子节点再往回走。 广度优先遍历：一层一层的去遍历。 这两种遍历是图论中最基本的两种遍历方式。 前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。 广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。 深度优先遍历 前序遍历（递归法，迭代法）：中左右 中序遍历（递归法，迭代法）：左中右 后序遍历（递归法，迭代法）：左右中 广度优先遍历 层次遍历（迭代法） 二叉树的链式定义 123456struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【学习笔记】NVMeoF（一）：基础知识","slug":"n-nvmeof-01","date":"2024-08-19T13:44:02.000Z","updated":"2025-01-17T18:57:47.125Z","comments":false,"path":"notes/存储/n-nvmeof-01/","link":"","permalink":"https://cs0522.github.io/notes/%E5%AD%98%E5%82%A8/n-nvmeof-01/","excerpt":"NVMe 相关基础知识记录。","text":"NVMe 相关基础知识记录。 相关名词 SATA、PCIe 两者都是总线标准。 SATA 由 IDE/ATA 标准发展而来，主要用途是把存储设备连接到主板。 直连 PCI Express (PCIe) 总线的设计。端对端的互连协议，提供了高速传输带宽的解决方案。点对点的方式连接两个设备。 AHCI、NVMe AHCI 和 NVMe 是逻辑（或者说软件、驱动程序）上的标准（协议）。 NVMe 只适用于 SSD（SSD 和主板也要支持 NVMe）。AHCI 则适用于机械硬盘和 SSD。 物理接口 SATA 接口。采用这种接口的，只能使用 SATA 总线，不能使用 PCIe 总线。大部分 2.5”SSD 就是这种接口。 M.2 接口。采用这种接口的 SSD，可以使用 SATA 或者 PCIe 总线（取决于主板和 SSD）。如果采用 PCIe 总线，又分为 AHCI 和 NVMe 两种协议。 SATA Express 接口。SATA Express 使用的是 PCIe 总线，向下兼容 SATA 总线。 循环队列 数据结构：循环队列 SQ、CQ SQ: Submission Queue，简称 SQ。 CQ: Completion Queue，简称 CQ。 namespace NVMe-namespace Host, Target 和 Transport client 端称作 Host，处理 client 请求的部分称作 Target 端（连接物理 NVMe 设备），Host 和 Target 之间使用 NVMe 命令交流。Transport 是连接 Host 和 Target 的桥梁，可以是 RDMA 或者 FC。在 Fabrics 传输过程中，NVMe 命令会被相应的 Transport 代码封装（Capsule）和解析。 NVMe Subsystem, NVMe Namespace 和 Port 一个 Subsystem 就是一个 NVMe 子系统，Subsystem 在 target 端，Host 可以申请连接某个 target 的 Subsystem。一个 Port 代表一个 Transport 资源。Subsystem 必须和 Namespace，Port 建立关系，但是他们的联系又是很灵活的：即一个 Subsystem 可以包含多个 Namespace，一个 Namespace 可以加入多个 Subsystem，一个 Port 可以放入多个 Subsystem。 NVM Set 和 Endurance Group 详见 NVM Set 和 Endurance Group NQN NVM Qualified Name，用于唯一标识 NVMe 目标的名称格式，通常用于 iSCSI 和 Fabric 等协议中。 NQN 的主要特点： * 唯一性：NQN 通常是全局唯一的，确保在整个存储网络中可以唯一识别目标。 * 格式：NQN 的格式通常是 nqn.2021-09.io.spdk:nvm.target1，其中包含了时间戳和命名空间，这样可以避免名称冲突。 * 结构：NQN 的结构通常包括前缀、日期和描述符，以便于在组织中管理多个存储目标。 作用： NQN 用于标识 NVMe 目标设备，以便在网络中进行连接和管理。它在存储网络中起到类似于 DNS 名称的作用，使得设备能够在网络上被识别和访问。 RDMA RDMA 概述 RDMA 技术浅析 RDMA SEND/RECV、Read/Write 流程 RDMA 操作可以简单理解为： Host 提交工作请求（WR）到工作队列（WQ）：工作队列包括发送队列（SQ）和接收队列（RSQ）。工作队列的每一个元素叫做 WQE，也就是 WR。 Host 从完成队列（CQ）中获取工作完成（WC）：完成队列里的每一个元素叫做 CQE，也就是 WC。 具有 RDMA 引擎的硬件就是一个队列元素处理器。RDMA 硬件不断地从工作队列 WQ 中去取工作请求 WR 来执行，执行完了就给完成队列 CQ 中放置工作完成 WC。从生产者-消费者的角度理解就是： Host 生产 WR，把 WR 放到 WQ 中去 RDMA 硬件消费 WR RDMA 硬件生产 WC，把 WC 放到 CQ 中去 Host 消费 WC NVMe NVMe 是一种协议，而并非外形规格或接口规范。不同于其他存储协议，NVMe 将 SSD 设备视为内存，而不是硬盘驱动器。NVMe 协议的设计从一开始就以搭配 PCIe 接口使用为目标，因此几乎直接连接到服务器的 CPU 和内存子系统。 NVMe 旨在定义主机软件如何通过 PCI Express (PCIe) 总线与非易失性存储器进行通信，适用于各种 PCIe 固态硬盘 (SSD) 。 NVMe 中 Command 执行流程有 8 步，Host 与 Controller 之间用 PCIe TLP 传递信息。 Host 提交新的 Command。Host 下发一个新 Command 时，将其放入 Host 内存中 SQ。 Host 通知 Controller 提取 Command。Host 把 Command 写入 SQ 之后，此时 Device 并不知道这件事。所以，Host 此时需要给 Controller 发信息，通知 NVMe Controller。这个过程通过更新在 Controller 内部的寄存器 SQ Tail Doorbell 来完成。 NVMe Controller 从 SQ 提取 Command。取走 Command 之后，需要在 Controller 内部的 SQ Head Pointer 寄存器中更新 Head 所在的位置。NVMe 没有规定 Command 存入队列的执行顺序，Controller 可以一次取出多个 Command 进行批量处理。 NVMe Controller 执行从 SQ 提取的 Commands。一个队列中的 Command 执行顺序是不固定的（可能导致先提交的请求后处理），涉及到 NVMe 定义的命令仲裁机制。执行 Read/Wirte Command 时，这个过程也会与 Host Memory 进行数据传递。 NVMe Controller 将 Commands 的完成状态写入 CQ。此时，Controller 需要更新 CQ Tail Pointer 寄存器。 NVMe Controller 通知 Host 检查 Commands 的完成状态。Controller 通过发送一个中断信息告知 Host 已执行完毕。 Host 检查 CQ 中的 Completion 信息。 Host 告知 Controller 已处理完成 Completion 信息。此时，Host 更新 Controller 内部的 CQ Head Doorbell。告知 Controller 处理完毕。 流程示意图： NVMe 相关规范 NVM-Express-Base-Specification-2.0b NVM-Express-RDMA-Transport-Specification-1.0d NVMe-over-Fabrics-1.1a NVMe 技术概述 NVMe 2.0 简介 介绍 NVMe NVMe系列专题之一：NVMe技术概述 NVMe 技术浅析 NVMe 队列管理 NVMe系列专题之二：队列(Queue)管理 NVMe 命令仲裁机制 NVMe系列专题之三：命令仲裁机制 寻址模型 PRP 和 SGL NVMe系列专题之四：寻址模型PRP和SGL解析 NVMe-oF 什么是 NVMe-oF RDMA 架构与实践 NVMe 协议并非局限于在服务器内部连接本地闪存驱动器，它还可通过网络使用。在网络环境内使用时，网络“架构”支持存储和服务器元素之间的任意连接。NVMe-oF 支持组织创建超高性能存储网络，其时延能够媲美直连存储。因而可在服务器之间按需共享快速存储设备。NVMe-oF 使用基于消息的模型通过网络在主机和目标存储设备之间发送请求和响应。 NVMe-oF 传输协议 NVMe over TCP 基于现有的 IP 网络，采用 TCP 协议传输 NVMe，在网络基础设施不变的情况下实现端到端 NVMe。 NVMe over RDMA RDMA 是承载 NoF 的原生网络协议，RDMA 协议除了 RoCE 外还包括 IB（InfiniBand）和 iWARP（Internet Wide Area RDMA Protocol）。NVMe over RDMA 协议比较简单，直接把 NVMe 的 IO 队列映射到 RDMA QP（Queue Pair）连接，通过 RDMA SEND，RDMA WRITE，RDMA READ 三个语义实现 IO 交互。 NVMe-oF 整体架构 NVMe Host(Controller)-side Transport Abstraction 这两层便是 NVMe over Fabrics 协议的实现层。该协议只是一个用于 NVMe Transport 的抽象层而已，它并不实现真正的命令和数据传输功能，它只是为命令和数据传输定义了统一的规范，因此该协议只是“指导方针”。它是构建在 Fabrics 之上的，即它并不关心实际的 Fabrics 到底是什么，它只是提供了 Fabrics 通用的对接 NVMe 的接口，完成了对 NVMe 接口和命令在各种 Fabrics 而非只是 PCIe 上（NVMe Base 协议只涉及 PCIe 这一种 Fabric）的拓展。因此，为了使 NVMe 可以架构于不同的 Fabric 之上，各 Fabric 还需开发专用的功能实现层，真正实现基于此 Fabric 的数据传输功能，并完成和 Transport Abstraction 抽象层（即 NVMe over Fabrics 协议的实现层）的对接以使得传输抽象层可以调用到这些函数。 NVMe over RDMA NVMe Host 和 NVMe Subsystem Controller 是 NVMe Base 协议扩展到 NVMe over Fabrics 的部分；NVMe Host(Controller)-side Transport Abstraction 则是 NVMe over Fabrics 传输抽象层的实现。RoCE 层则是支持 RoCE 技术的网卡及相关驱动和 RDMA 协议栈，而不论 InfiniBand、RoCE 或者 iWarp 何种具体的 RDMA 实现形式，都约定提供统一的操作接口，RDMA Verbs 便是 RDMA 技术向上层提供的接口。NVMe RDMA 则是实现将 RDMA 的接口 Verbs 和 NVMe 对接的关键粘合层，简言之，其作用是将 NVMe Transport Abstraction 传输抽象层提供的传输接口可以调用到下层 RDMA 提供的传输接口（即 verbs）。","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"存储","slug":"notes/存储","permalink":"https://cs0522.github.io/categories/notes/%E5%AD%98%E5%82%A8/"}],"tags":[{"name":"存储","slug":"存储","permalink":"https://cs0522.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"NVMe","slug":"NVMe","permalink":"https://cs0522.github.io/tags/NVMe/"}]},{"title":"【刷题日记】栈和队列-栈和队列理论基础","slug":"p-stack-basic","date":"2024-08-19T13:17:18.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/栈和队列/p-stack-basic/","link":"","permalink":"https://cs0522.github.io/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/p-stack-basic/","excerpt":"栈和队列理论基础。","text":"栈和队列理论基础。 基础点 栈和队列不提供迭代器，不能够遍历所有元素 栈和队列的底层容器可插拔（可以更换容器） 栈和队列都是一种容器适配器 deque（双端队列）是缺省底层容器 栈和队列内存分布 容器适配器，底层容器使用不同的容器，导致栈内数据在内存中不一定是连续分布的。 缺省情况下，默认底层容器是 deque，那么 deque 在内存中的数据分布是不连续的。","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"栈和队列","slug":"practices/栈和队列","permalink":"https://cs0522.github.io/categories/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"栈和队列","slug":"栈和队列","permalink":"https://cs0522.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}]},{"title":"【刷题日记】栈和队列-前 K 个高频元素-L347-Medium","slug":"p-stack-topK-L347","date":"2024-08-17T13:21:19.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/栈和队列/p-stack-topK-L347/","link":"","permalink":"https://cs0522.github.io/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/p-stack-topK-L347/","excerpt":"给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。","text":"给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。 思路 使用 map 键值对存储每个元素出现的次数；然后按照出现的次数进行从大到小排序（排序可以用小顶堆优化）；最后取前 k 个元素。 看了下官解确实是用小顶堆的。 学习点 为什么使用小顶堆（什么时候用小顶堆，什么时候用大顶堆）。 函数指针 auto cmp = [] (...) &#123; ... &#125;; 以及 delctype()。 代码 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; map&lt;int, int&gt; ele_freq; // 用 map 键值对先存储每个元素对应的出现次数 for (int i = 0; i &lt; nums.size(); i++) ele_freq[nums[i]]++; // map 不能根据 value 排序 // 使用 vector 接收 map 数据，并排序 vector&lt;pair&lt;int, int&gt;&gt; map_eles; for(auto it = ele_freq.begin(); it != ele_freq.end(); it++) &#123; map_eles.emplace_back(pair&lt;int, int&gt;(it-&gt;first, it-&gt;second)); &#125; auto cmp = [] (pair&lt;int, int&gt; &amp;a, pair&lt;int, int&gt; &amp;b) &#123; return a.second &gt; b.second; &#125;; // 应该不需要 sort，只需要前 k 个即可 // 可以使用 k-小顶堆：当大于 top 元素，弹出堆顶后入堆（堆顶元素为当前 k 个中的最小值，即选出的 k 个最大值中的最小值） // 最后堆中元素为最大的 k 个 sort(map_eles.begin(), map_eles.end(), cmp); vector&lt;int&gt; res; for (int i = 0; i &lt; k; i++) &#123; res.push_back(map_eles[i].first); &#125; return res; &#125;&#125;; 使用小顶堆： 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; // 要统计元素出现频率 unordered_map&lt;int, int&gt; map; // map&lt;nums[i],对应出现的次数&gt; for (int i = 0; i &lt; nums.size(); i++) &#123; map[nums[i]]++; &#125; // 对频率排序 // 定义一个小顶堆，大小为k auto cmp = [] (pair&lt;int, int&gt; &amp;a, pair&lt;int, int&gt; &amp;b) &#123; return a.second &gt; b.second; &#125;; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, delctype(cmp)&gt; pri_que; // 用固定大小为k的小顶堆，扫面所有频率的数值 for (unordered_map&lt;int, int&gt;::iterator it = map.begin(); it != map.end(); it++) &#123; pri_que.push(*it); if (pri_que.size() &gt; k) &#123; // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k pri_que.pop(); &#125; &#125; // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组 vector&lt;int&gt; result(k); for (int i = k - 1; i &gt;= 0; i--) &#123; result[i] = pri_que.top().first; pri_que.pop(); &#125; return result; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"栈和队列","slug":"practices/栈和队列","permalink":"https://cs0522.github.io/categories/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"栈和队列","slug":"栈和队列","permalink":"https://cs0522.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}]},{"title":"【刷题日记】栈和队列-滑动窗口最大值-L239-Hard","slug":"p-stack-slidingWindow-L239","date":"2024-08-17T12:13:07.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/栈和队列/p-stack-slidingWindow-L239/","link":"","permalink":"https://cs0522.github.io/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/p-stack-slidingWindow-L239/","excerpt":"给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值。","text":"给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值。 思路 用队列模拟滑动窗口，每添加一个元素就计算区间最大值。（超过时间限制） 使用 deque 实现 单调队列（单调递减或单调递增的队列），放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列可以返回里面的最大值；每次窗口移动的时候，调用que.pop(滑动窗口中移除元素的数值)，que.push(滑动窗口添加元素的数值)，然后que.front()就返回最大值。保证队列里的元素数值是由大到小的。 学习点 单调队列，队列中的元素从递增或者递减的顺序，有点类似于大顶堆、小顶堆，需要自己维护这个数据结构。 代码 超过时间限制： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;class Solution &#123;public: int get_que_max(queue&lt;int&gt; &amp;slide_que) &#123; int ele_num = slide_que.size(); int max_ele = slide_que.front(); for (int i = 0; i &lt; ele_num; i++) &#123; auto ele_tmp = slide_que.front(); slide_que.pop(); if (max_ele &lt; ele_tmp) max_ele = ele_tmp; slide_que.push(ele_tmp); &#125; return max_ele; &#125; vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; queue&lt;int&gt; slide_que; vector&lt;int&gt; res; for (int i = 0; i &lt; k; i++) slide_que.push(nums[i]); res.push_back(get_que_max(slide_que)); for (int i = k; i &lt; nums.size(); i++) &#123; slide_que.pop(); slide_que.push(nums[i]); res.push_back(get_que_max(slide_que)); &#125; return res; &#125;&#125;; 实现单调队列： 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;private: class MyQueue &#123; //单调队列（从大到小） public: deque&lt;int&gt; que; // 使用deque来实现单调队列 // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。 // 同时pop之前判断队列当前是否为空。 void pop(int value) &#123; if (!que.empty() &amp;&amp; value == que.front()) &#123; que.pop_front(); &#125; &#125; // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。 // 这样就保持了队列里的数值是单调从大到小的了。 void push(int value) &#123; while (!que.empty() &amp;&amp; value &gt; que.back()) &#123; que.pop_back(); &#125; que.push_back(value); &#125; // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。 int front() &#123; return que.front(); &#125; &#125;;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; MyQueue que; vector&lt;int&gt; result; for (int i = 0; i &lt; k; i++) &#123; // 先将前k的元素放进队列 que.push(nums[i]); &#125; result.push_back(que.front()); // result 记录前k的元素的最大值 for (int i = k; i &lt; nums.size(); i++) &#123; que.pop(nums[i - k]); // 滑动窗口移除最前面元素 que.push(nums[i]); // 滑动窗口前加入最后面的元素 result.push_back(que.front()); // 记录对应的最大值 &#125; return result; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"栈和队列","slug":"practices/栈和队列","permalink":"https://cs0522.github.io/categories/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"栈和队列","slug":"栈和队列","permalink":"https://cs0522.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}]},{"title":"【刷题日记】栈和队列-逆波兰表达式求值-L150-Medium","slug":"p-stack-evalRPN-L150","date":"2024-08-17T08:28:02.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/栈和队列/p-stack-evalRPN-L150/","link":"","permalink":"https://cs0522.github.io/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/p-stack-evalRPN-L150/","excerpt":"给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。 请你计算该表达式。返回一个表示表达式值的整数。","text":"给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。 请你计算该表达式。返回一个表示表达式值的整数。 思路 用栈，保存数字；遇到运算符，弹出两个数运算后，结果入栈。结束后栈里的最后一个元素为结果。 学习点 可以用 std::stoi()、std::stoll() 转换为数字，不需要自己再写。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;map&gt;using namespace std;class Solution &#123;public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; operands; // 存储运算符映射关系 map&lt;string, int&gt; operator_map; operator_map.insert(make_pair&lt;&gt;(&quot;+&quot;, 1)); operator_map.insert(make_pair&lt;&gt;(&quot;-&quot;, 2)); operator_map.insert(make_pair&lt;&gt;(&quot;*&quot;, 3)); operator_map.insert(make_pair&lt;&gt;(&quot;/&quot;, 4)); for (int i = 0; i &lt; tokens.size(); i++) &#123; // 非运算符入栈 if (!operator_map.count(tokens[i])) operands.push(stoi(tokens[i])); // 操作符弹出栈运算后入栈 else &#123; auto op1 = operands.top(); operands.pop(); auto op2 = operands.top(); operands.pop(); int res; switch (operator_map[tokens[i]]) &#123; case 1: // + res = op2 + op1; operands.push(res); break; case 2: // - res = op2 - op1; operands.push(res); break; case 3: // * res = op2 * op1; operands.push(res); break; case 4: // / res = op2 / op1; operands.push(res); break; &#125; &#125; &#125; return operands.top(); &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"栈和队列","slug":"practices/栈和队列","permalink":"https://cs0522.github.io/categories/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"栈和队列","slug":"栈和队列","permalink":"https://cs0522.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}]},{"title":"【刷题日记】栈和队列-删除字符串中的所有相邻重复项-L1047-Easy","slug":"p-stack-removeDuplicate-L1047","date":"2024-08-16T16:50:19.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/栈和队列/p-stack-removeDuplicate-L1047/","link":"","permalink":"https://cs0522.github.io/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/p-stack-removeDuplicate-L1047/","excerpt":"给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。","text":"给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 思路 用栈存放遍历过的元素，当遍历当前的这个元素的时候，去栈中检查是否遍历过相同数值的相邻元素，再做消除操作。 学习点 栈 代码 12345678910111213141516171819202122232425262728class Solution &#123;public: string removeDuplicates(string s) &#123; // 用栈 stack&lt;char&gt; uniques; for (int i = 0; i &lt; s.length(); i++) &#123; if ((!uniques.empty() &amp;&amp; s[i] != uniques.top()) || uniques.empty()) &#123; uniques.push(s[i]); &#125; else if (!uniques.empty() &amp;&amp; s[i] == uniques.top()) &#123; uniques.pop(); &#125; &#125; // stack 中即为最后的结果 string res = &quot;&quot;; while (!uniques.empty()) &#123; res += uniques.top(); uniques.pop(); &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"栈和队列","slug":"practices/栈和队列","permalink":"https://cs0522.github.io/categories/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"栈和队列","slug":"栈和队列","permalink":"https://cs0522.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}]},{"title":"【刷题日记】栈和队列-有效括号-L20-Easy","slug":"p-stack-validBrace-L20","date":"2024-08-16T10:27:53.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/栈和队列/p-stack-validBrace-L20/","link":"","permalink":"https://cs0522.github.io/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/p-stack-validBrace-L20/","excerpt":"给定一个只包括 '('，')'，'&#123;'，'&#125;'，'['，']' 的字符串 s ，判断字符串是否有效。","text":"给定一个只包括 '('，')'，'&#123;'，'&#125;'，'['，']' 的字符串 s ，判断字符串是否有效。 思路 用栈暂存左括号；用 map 键值对存储左括号和右括号的对应关系。 学习点 栈、map。 代码 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: bool isValid(string s) &#123; // 用类似 map 的数据结构 // 保存对应关系 map&lt;char, char&gt; brace_mp; brace_mp.insert(make_pair&lt;&gt;(&#x27;(&#x27;, &#x27;)&#x27;)); brace_mp.insert(make_pair&lt;&gt;(&#x27;[&#x27;, &#x27;]&#x27;)); brace_mp.insert(make_pair&lt;&gt;(&#x27;&#123;&#x27;, &#x27;&#125;&#x27;)); stack&lt;char&gt; left_brace_st; for (int i = 0; i &lt; s.length(); i++) &#123; // 左括号入栈 // 右括号弹出栈 if (brace_mp.count(s[i])) // 左括号 left_brace_st.push(s[i]); else // 右括号 &#123; if (!left_brace_st.empty()) &#123; auto tmp_left_brace = left_brace_st.top(); if (s[i] != brace_mp[tmp_left_brace]) break; // 跳出循环，残留元素，统一 return false else left_brace_st.pop(); &#125; else return false; &#125; &#125; return left_brace_st.empty(); &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"栈和队列","slug":"practices/栈和队列","permalink":"https://cs0522.github.io/categories/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"栈和队列","slug":"栈和队列","permalink":"https://cs0522.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}]},{"title":"【刷题日记】栈和队列-用队列实现栈-L225-Easy","slug":"p-stack-queue2Stack-L225","date":"2024-08-16T08:35:34.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/栈和队列/p-stack-queue2Stack-L225/","link":"","permalink":"https://cs0522.github.io/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/p-stack-queue2Stack-L225/","excerpt":"请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。","text":"请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。 思路 用一个队列，将队头元素弹出并重新加入队尾，并用 count 计数，当队头元素为最后一个元素时，弹出。 学习点 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class MyStack &#123;private: queue&lt;int&gt; inQ;public: MyStack() &#123; &#125; void push(int x) &#123; inQ.push(x); &#125; int pop() &#123; auto inQ_size = inQ.size(); // 返回最后一个元素 int ele_cnt = 0; while (ele_cnt != inQ_size - 1) &#123; inQ.push(inQ.front()); inQ.pop(); ele_cnt += 1; &#125; // 此时队头元素为要 pop 的元素 auto res = inQ.front(); inQ.pop(); return res; &#125; int top() &#123; auto inQ_size = inQ.size(); // 返回最后一个元素 int ele_cnt = 0; while (ele_cnt != inQ_size - 1) &#123; inQ.push(inQ.front()); inQ.pop(); ele_cnt += 1; &#125; // 此时队头元素为要 pop 的元素 auto res = inQ.front(); inQ.push(inQ.front()); inQ.pop(); return res; &#125; bool empty() &#123; return inQ.empty(); &#125;&#125;;/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"栈和队列","slug":"practices/栈和队列","permalink":"https://cs0522.github.io/categories/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"栈和队列","slug":"栈和队列","permalink":"https://cs0522.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}]},{"title":"【刷题日记】栈和队列-用栈实现队列-L232-Easy","slug":"p-stack-stack2Queue-L232","date":"2024-08-16T08:33:03.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/栈和队列/p-stack-stack2Queue-L232/","link":"","permalink":"https://cs0522.github.io/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/p-stack-stack2Queue-L232/","excerpt":"请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：","text":"请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 思路 两个栈，互相倒腾。 学习点 栈和队列的特性。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class MyQueue &#123;private: stack&lt;int&gt; st; stack&lt;int&gt; tmp_st; public: MyQueue() &#123; &#125; void push(int x) &#123; this-&gt;st.push(x); &#125; int pop() &#123; while (!st.empty()) &#123; tmp_st.push(st.top()); st.pop(); &#125; auto res = tmp_st.top(); tmp_st.pop(); // 元素还回 st while (!tmp_st.empty()) &#123; st.push(tmp_st.top()); tmp_st.pop(); &#125; return res; &#125; int peek() &#123; while (!st.empty()) &#123; tmp_st.push(st.top()); st.pop(); &#125; auto res = tmp_st.top(); // tmp_st.pop(); // 元素还回 st while (!tmp_st.empty()) &#123; st.push(tmp_st.top()); tmp_st.pop(); &#125; return res; &#125; bool empty() &#123; return (st.empty() &amp;&amp; tmp_st.empty()); &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"栈和队列","slug":"practices/栈和队列","permalink":"https://cs0522.github.io/categories/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"栈和队列","slug":"栈和队列","permalink":"https://cs0522.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"}]},{"title":"【刷题日记】字符串-重复的子字符串-L459-Easy","slug":"p-str-repeatedStr-L459","date":"2024-08-15T04:08:22.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/字符串/p-str-repeatedStr-L459/","link":"","permalink":"https://cs0522.github.io/practices/%E5%AD%97%E7%AC%A6%E4%B8%B2/p-str-repeatedStr-L459/","excerpt":"给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。","text":"给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 思路 多次循环 KMP 算法，重点在于如何取子字符串作为模式串进行匹配，减少时间开销。 判断字符串 s 是否由重复子串组成，只要两个 s 拼接在一起，里面还出现一个 s 的话，就说明是由重复子串组成。在判断 s + s 拼接的字符串里是否出现一个 s 的的时候，要刨除 s + s 的首字符和尾字符，这样避免在 s + s 中搜索出原来的 s，我们要搜索的是中间拼接出来的 s。 数学推理：利用 next 数组 学习点 如何取子字符串？子字符串的长度一定是母串的因数，这样可以剪枝处理，节省很多循环。 代码 我的（复杂了）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100class Solution &#123;public: // 计算 next 数组 void calNext(int *next, string &amp;pattern) &#123; // 回溯指针 // 也可以表示最长前缀长度 int j = -1; // 默认 next[0] = -1 next[0] = -1; for (int i = 1; i &lt; pattern.length(); i++) &#123; // 当正在匹配的字符 p[i] // 与正在匹配的最长前缀的下一位 p[j + 1] // 匹配失败时， // j 回溯到最长前缀的上一个最长前缀 while (j != -1 &amp;&amp; pattern[i] != pattern[j + 1]) &#123; j = next[j]; &#125; // 匹配成功 // 最长前缀 + 1 if (pattern[i] == pattern[j + 1]) &#123; j += 1; &#125; next[i] = j; &#125; &#125; // KMP bool KMP(string &amp;text, string &amp;pattern, int *next) &#123; // int next[pattern.length()]; // // 计算 next 数组 // calNext(next, pattern); int j = -1; // 开始匹配 for (int i = 0; i &lt; text.length(); i++) &#123; while (j != -1 &amp;&amp; text[i] != pattern[j + 1]) &#123; j = next[j]; &#125; if (text[i] == pattern[j + 1]) &#123; j++; &#125; // 当 j 匹配到模式串最后一位 // 匹配成功 if (j == pattern.length() - 1) &#123; return true; &#125; &#125; // 匹配失败 return false; &#125; bool repeatedSubstringPattern(string s) &#123; int len = s.length(); bool flag = false; // i 为长度 for (int i = len / 2; i &gt;= 1; i--) &#123; // NOTE: 剪枝处理 // 只有倍数才满足要求 // 可以节省很多循环 if (len % i != 0) continue; string pattern = s.substr(0, i); // pattern 作为模式串 // 用 KMP 算法进行匹配 int next[pattern.length()]; calNext(next, pattern); // end 为已经匹配成功的下标 + 1 int end = i; while (end != len) &#123; string text = s.substr(end, i); // 部分匹配失败 // 退出 while，for 循环 continue if (!KMP(text, pattern, next)) break; // 部分匹配成功 else end += i; &#125; // 匹配成功 if (end == len) return true; // 该字串匹配失败 else continue; &#125; // 全部匹配失败 return false; &#125;&#125;; 官解的 KMP： 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: bool kmp(const string&amp; query, const string&amp; pattern) &#123; int n = query.size(); int m = pattern.size(); vector&lt;int&gt; fail(m, -1); for (int i = 1; i &lt; m; ++i) &#123; int j = fail[i - 1]; while (j != -1 &amp;&amp; pattern[j + 1] != pattern[i]) &#123; j = fail[j]; &#125; if (pattern[j + 1] == pattern[i]) &#123; fail[i] = j + 1; &#125; &#125; int match = -1; for (int i = 1; i &lt; n - 1; ++i) &#123; while (match != -1 &amp;&amp; pattern[match + 1] != query[i]) &#123; match = fail[match]; &#125; if (pattern[match + 1] == query[i]) &#123; ++match; if (match == m - 1) &#123; return true; &#125; &#125; &#125; return false; &#125; bool repeatedSubstringPattern(string s) &#123; return kmp(s + s, s); &#125;&#125;; 利用 next 数组： 12345678910111213141516171819202122232425262728class Solution &#123;public: void getNext (int* next, const string&amp; s)&#123; next[0] = -1; int j = -1; for(int i = 1;i &lt; s.size(); i++)&#123; while(j &gt;= 0 &amp;&amp; s[i] != s[j + 1]) &#123; j = next[j]; &#125; if(s[i] == s[j + 1]) &#123; j++; &#125; next[i] = j; &#125; &#125; bool repeatedSubstringPattern (string s) &#123; if (s.size() == 0) &#123; return false; &#125; int next[s.size()]; getNext(next, s); int len = s.size(); if (next[len - 1] != -1 &amp;&amp; len % (len - (next[len - 1] + 1)) == 0) &#123; return true; &#125; return false; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"字符串","slug":"practices/字符串","permalink":"https://cs0522.github.io/categories/practices/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"字符串","slug":"字符串","permalink":"https://cs0522.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"【刷题日记】字符串-找出字符串中第一个匹配项的下标-L28-Easy","slug":"p-str-kmp-l28","date":"2024-08-14T10:12:43.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/字符串/p-str-kmp-l28/","link":"","permalink":"https://cs0522.github.io/practices/%E5%AD%97%E7%AC%A6%E4%B8%B2/p-str-kmp-l28/","excerpt":"给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。","text":"给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。 思路 KMP 算法。 学习点 KMP 算法。可以背模板。 代码 KMP： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution &#123;public: // 计算 next 数组 void calNext(int *next, string &amp;pattern) &#123; // 回溯指针 // 也可以表示最长前缀长度 int j = -1; // 默认 next[0] = -1 next[0] = -1; for (int i = 1; i &lt; pattern.length(); i++) &#123; // 当正在匹配的字符 p[i] // 与正在匹配的最长前缀的下一位 p[j + 1] // 匹配失败时， // j 回溯到最长前缀的上一个最长前缀 while (j != -1 &amp;&amp; pattern[i] != pattern[j + 1]) &#123; j = next[j]; &#125; // 匹配成功 // 最长前缀 + 1 if (pattern[i] == pattern[j + 1]) &#123; j += 1; &#125; next[i] = j; &#125; &#125; // KMP // 返回匹配成功的下标 int KMP(string &amp;text, string &amp;pattern) &#123; int next[pattern.length()]; // 计算 next 数组 calNext(next, pattern); int j = -1; // 开始匹配 for (int i = 0; i &lt; text.length(); i++) &#123; while (j != -1 &amp;&amp; text[i] != pattern[j + 1]) &#123; j = next[j]; &#125; if (text[i] == pattern[j + 1]) &#123; j++; &#125; // 当 j 匹配到模式串最后一位 // 匹配成功 if (j == pattern.length() - 1) &#123; return i - j; &#125; &#125; // 匹配失败 return -1; &#125; int strStr(string haystack, string needle) &#123; // KMP return KMP(haystack, needle); &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"字符串","slug":"practices/字符串","permalink":"https://cs0522.github.io/categories/practices/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"字符串","slug":"字符串","permalink":"https://cs0522.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"【刷题日记】字符串-右旋字符串-L55-Easy","slug":"p-str-rotateStr-l55","date":"2024-08-14T09:59:08.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/字符串/p-str-rotateStr-l55/","link":"","permalink":"https://cs0522.github.io/practices/%E5%AD%97%E7%AC%A6%E4%B8%B2/p-str-rotateStr-l55/","excerpt":"字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 例如，对于输入字符串 &quot;abcdefg&quot; 和整数 2，函数应该将其转换为 &quot;fgabcde&quot;。","text":"字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 例如，对于输入字符串 &quot;abcdefg&quot; 和整数 2，函数应该将其转换为 &quot;fgabcde&quot;。 思路 用额外空间临时存储子字符串。 多次局部反转。 学习点 局部字符串反转。 代码 子字符串： 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main()&#123; int k; string s; while (cin &gt;&gt; k) &#123; cin &gt;&gt; s; // 用临时字符串保存后面 k 个字符 string last_k = s.substr(s.length() - k, k); // 用临时变量保存前面的字符 string first_sub = s.substr(0, s.length() - k); // 拼接 string res = last_k + first_sub; cout &lt;&lt; res &lt;&lt; endl; &#125; return 0;&#125; 局部反转： 1234567891011121314151617#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main() &#123; int n; string s; cin &gt;&gt; n; cin &gt;&gt; s; int len = s.size(); //获取长度 reverse(s.begin(), s.end()); // 整体反转 reverse(s.begin(), s.begin() + n); // 先反转前一段，长度n reverse(s.begin() + n, s.end()); // 再反转后一段 cout &lt;&lt; s &lt;&lt; endl;&#125;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"字符串","slug":"practices/字符串","permalink":"https://cs0522.github.io/categories/practices/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"字符串","slug":"字符串","permalink":"https://cs0522.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"【刷题日记】字符串-反转单词-L151-Medium","slug":"p-str-reverseWords-l151","date":"2024-08-14T09:58:37.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/字符串/p-str-reverseWords-l151/","link":"","permalink":"https://cs0522.github.io/practices/%E5%AD%97%E7%AC%A6%E4%B8%B2/p-str-reverseWords-l151/","excerpt":"给你一个字符串 s ，请你反转字符串中 单词 的顺序。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。","text":"给你一个字符串 s ，请你反转字符串中 单词 的顺序。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。 思路 用栈存储。遍历完后弹出栈，添加到新字符串并加入空格。 双指针法移除空格，之后反转字符串（O(1)空间复杂度）。 学习点 双指针移除空格。 代码 栈： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: string reverseWords(string s) &#123; // 用栈 stack&lt;string&gt; st; string tmp = &quot;&quot;; for (int i = 0; i &lt; s.length(); i++) &#123; // 遇到空格压入栈 if (s[i] == &#x27; &#x27;) &#123; if (tmp != &quot;&quot;) st.push(tmp); tmp = &quot;&quot;; &#125; // 非空格更新临时字符串 else tmp += s[i]; &#125; // 最后一个单词压入栈 if (tmp != &quot;&quot;) st.push(tmp); // 输出 string res = &quot;&quot;; while (!st.empty()) &#123; res += st.top(); st.pop(); // 为了最后一个单词尾部没有空格 if (!st.empty()) res += &quot; &quot;; &#125; return res; &#125;&#125;; 双指针：(O(1)复杂度) 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: void reverse(string&amp; s, int start, int end)&#123; //翻转，区间写法：左闭右闭 [] for (int i = start, j = end; i &lt; j; i++, j--) &#123; swap(s[i], s[j]); &#125; &#125; void removeExtraSpaces(string&amp; s) &#123;//去除所有空格并在相邻单词之间添加空格, 快慢指针。 int slow = 0; //整体思想参考https://programmercarl.com/0027.移除元素.html for (int i = 0; i &lt; s.size(); ++i) &#123; // if (s[i] != &#x27; &#x27;) &#123; //遇到非空格就处理，即删除所有空格。 if (slow != 0) s[slow++] = &#x27; &#x27;; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。 while (i &lt; s.size() &amp;&amp; s[i] != &#x27; &#x27;) &#123; //补上该单词，遇到空格说明单词结束。 s[slow++] = s[i++]; &#125; &#125; &#125; s.resize(slow); //slow的大小即为去除多余空格后的大小。 &#125; string reverseWords(string s) &#123; removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。 reverse(s, 0, s.size() - 1); int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。 for (int i = 0; i &lt;= s.size(); ++i) &#123; if (i == s.size() || s[i] == &#x27; &#x27;) &#123; //到达空格或者串尾，说明一个单词结束。进行翻转。 reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。 start = i + 1; //更新下一个单词的开始下标start &#125; &#125; return s; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"字符串","slug":"practices/字符串","permalink":"https://cs0522.github.io/categories/practices/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"字符串","slug":"字符串","permalink":"https://cs0522.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"【刷题日记】字符串-替换数字-L54-Easy","slug":"p-str-replaceNum-l54","date":"2024-08-14T09:58:01.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/字符串/p-str-replaceNum-l54/","link":"","permalink":"https://cs0522.github.io/practices/%E5%AD%97%E7%AC%A6%E4%B8%B2/p-str-replaceNum-l54/","excerpt":"给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 &quot;a1b2c3&quot;，函数应该将其转换为 &quot;anumberbnumbercnumber&quot;。","text":"给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 &quot;a1b2c3&quot;，函数应该将其转换为 &quot;anumberbnumbercnumber&quot;。 思路 原地修改字符串，不使用额外空间。 学习点 双指针，从后往前进行填充元素。 代码 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;int main()&#123; string s; while (cin &gt;&gt; s) &#123; // 统计字符串中数字个数 int nums_count = 0; int old_index = s.length() - 1; for (int i = 0; i &lt; s.length(); i++) &#123; if (s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;) nums_count += 1; &#125; // 扩容 s.resize(s.length() - nums_count + 6 * nums_count); // 从后向前进行数字替换 int new_index = s.length() - 1; while (old_index &gt;= 0) &#123; if (s[old_index] &gt;= &#x27;0&#x27; &amp;&amp; s[old_index] &lt;= &#x27;9&#x27;) &#123; s[new_index--] = &#x27;r&#x27;; s[new_index--] = &#x27;e&#x27;; s[new_index--] = &#x27;b&#x27;; s[new_index--] = &#x27;m&#x27;; s[new_index--] = &#x27;u&#x27;; s[new_index--] = &#x27;n&#x27;; &#125; else s[new_index--] = s[old_index]; old_index -= 1; &#125; cout &lt;&lt; s &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"字符串","slug":"practices/字符串","permalink":"https://cs0522.github.io/categories/practices/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"字符串","slug":"字符串","permalink":"https://cs0522.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"【刷题日记】字符串-反转字符串II-L541-Easy","slug":"p-str-reverseStrII-l541","date":"2024-08-14T09:57:34.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/字符串/p-str-reverseStrII-l541/","link":"","permalink":"https://cs0522.github.io/practices/%E5%AD%97%E7%AC%A6%E4%B8%B2/p-str-reverseStrII-l541/","excerpt":"给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。","text":"给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 思路 按照题目思路进行模拟 学习点 代码 12345678910class Solution &#123;public: string reverseStr(string s, int k) &#123; int n = s.length(); for (int i = 0; i &lt; n; i += 2 * k) &#123; reverse(s.begin() + i, s.begin() + min(i + k, n)); &#125; return s; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"字符串","slug":"practices/字符串","permalink":"https://cs0522.github.io/categories/practices/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"字符串","slug":"字符串","permalink":"https://cs0522.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"【刷题日记】字符串-反转字符串-L344-Easy","slug":"p-str-reverseStr-l344","date":"2024-08-14T09:56:33.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/字符串/p-str-reverseStr-l344/","link":"","permalink":"https://cs0522.github.io/practices/%E5%AD%97%E7%AC%A6%E4%B8%B2/p-str-reverseStr-l344/","excerpt":"编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。","text":"编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 思路 临时变量 位运算，异或 学习点 代码 位运算： 12345678910111213class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; int str_len = s.size(); char tmp; for (int i = 0; i &lt; str_len / 2; i++) &#123; s[i] ^= s[str_len - 1 - i]; s[str_len - 1 - i] ^= s[i]; s[i] ^= s[str_len - 1 -i]; &#125; &#125;&#125;; 临时变量： 12345678910111213class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; int str_len = s.size(); char tmp; for (int i = 0; i &lt; str_len / 2; i++) &#123; tmp = s[i]; s[i] = s[str_len - 1 -i]; s[str_len - 1 -i] = tmp; &#125; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"字符串","slug":"practices/字符串","permalink":"https://cs0522.github.io/categories/practices/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"字符串","slug":"字符串","permalink":"https://cs0522.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"【刷题日记】哈希表-四数之和-L18-Medium","slug":"p-hash-4sum-l18","date":"2024-08-11T16:34:36.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/哈希表/p-hash-4sum-l18/","link":"","permalink":"https://cs0522.github.io/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/p-hash-4sum-l18/","excerpt":"给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：","text":"给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 思路 初步想法，类比与三数之和，使用双指针做法做。 学习点 代码 双指针法，需要考虑到四数之和可能会超过 int 范围： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; // 双指针 vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); if (nums.size() &lt; 4) return res; // nums[i] + nums[j] + nums[left] + nums[right] size_t nums_size = nums.size(); for (size_t i = 0; i &lt; nums_size; i++) &#123; // 对 a 去重 if (i &gt;= 1 &amp;&amp; nums[i] == nums[i - 1]) continue; for (size_t j = i + 1; j &lt; nums_size; j++) &#123; // 对 b 去重 if (j &gt;= i + 2 &amp;&amp; nums[j] == nums[j - 1]) continue; int left = j + 1; int right = nums_size - 1; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; (long)nums[i] + (long)nums[j] + (long)nums[left] + (long)nums[right] &gt; target) --right; while (left &lt; right &amp;&amp; (long)nums[i] + (long)nums[j] + (long)nums[left] + (long)nums[right] &lt; target) ++left; // 如果不满足条件 if (left &gt;= right) break; // 满足条件 else if ((long)nums[i] + (long)nums[j] + (long)nums[left] + (long)nums[right] == target) &#123; res.emplace_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[left], nums[right]&#125;); // 指针前进去重 ++left; while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) ++left; --right; while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) --right; &#125; &#125; &#125; &#125; return res; &#125;&#125;; 优化的解法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; result; sort(nums.begin(), nums.end()); for (int k = 0; k &lt; nums.size(); k++) &#123; // 剪枝处理 if (nums[k] &gt; target &amp;&amp; nums[k] &gt;= 0) &#123; break; // 这里使用break，统一通过最后的return返回 &#125; // 对nums[k]去重 if (k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) &#123; continue; &#125; for (int i = k + 1; i &lt; nums.size(); i++) &#123; // 2级剪枝处理 if (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= 0) &#123; break; &#125; // 对nums[i]去重 if (i &gt; k + 1 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = nums.size() - 1; while (right &gt; left) &#123; // nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出 if ((long) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123; right--; // nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出 &#125; else if ((long) nums[k] + nums[i] + nums[left] + nums[right] &lt; target) &#123; left++; &#125; else &#123; result.push_back(vector&lt;int&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;); // 对nums[left]和nums[right]去重 while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--; while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++; // 找到答案时，双指针同时收缩 right--; left++; &#125; &#125; &#125; &#125; return result; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"哈希表","slug":"practices/哈希表","permalink":"https://cs0522.github.io/categories/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"哈希表","slug":"哈希表","permalink":"https://cs0522.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"【刷题日记】哈希表-三数之和-L15-Medium","slug":"p-hash-3sum-l15","date":"2024-07-25T04:23:20.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/哈希表/p-hash-3sum-l15/","link":"","permalink":"https://cs0522.github.io/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/p-hash-3sum-l15/","excerpt":"给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。","text":"给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 思路 刚开始用哈希表做，没做出来，去重不好处理。 考虑用双指针法做。 学习点 去重逻辑。 代码 我的双指针法，在去重处理上代码写的冗余： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; // 双指针 vector&lt;vector&lt;int&gt;&gt; result; sort(nums.begin(), nums.end()); if (nums[0] &gt; 0 || nums[nums.size() - 1] &lt; 0) return result; // a = nums[i], b = nums[left], c = nums[right] for (int i = 0; i &lt; nums.size(); ++i) &#123; // 对 a 去重 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; // b + c int left = i + 1; int right = nums.size() - 1; // i != left != right while (left &lt; right) &#123; while (nums[i] + nums[left] + nums[right] &gt; 0) &#123; --right; if (right &lt;= i) break; &#125; while (nums[i] + nums[left] + nums[right] &lt; 0) &#123; ++left; if (left &gt;= right) break; &#125; if (left &gt;= right || right &lt;= i) break; // 满足条件 else if (left &lt; right &amp;&amp; nums[i] + nums[left] + nums[right] == 0) &#123; result.emplace_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;); // 指针前进，并去重 ++left; while (nums[left] == nums[left - 1]) &#123; ++left; if (left &gt;= right) break; &#125; --right; while (nums[right] == nums[right + 1]) &#123; --right; if (right &lt;= i) break; &#125; &#125; &#125; &#125; return result; &#125;&#125;; 优化的双指针法： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; sort(nums.begin(), nums.end()); // 找出a + b + c = 0 // a = nums[i], b = nums[left], c = nums[right] for (int i = 0; i &lt; nums.size(); i++) &#123; // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了 if (nums[i] &gt; 0) &#123; return result; &#125; // 去重a if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; int left = i + 1; int right = nums.size() - 1; while (right &gt; left) &#123; if (nums[i] + nums[left] + nums[right] &gt; 0) right--; else if (nums[i] + nums[left] + nums[right] &lt; 0) left++; else &#123; result.push_back(vector&lt;int&gt;&#123;nums[i], nums[left], nums[right]&#125;); // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重 while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--; while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++; // 找到答案时，双指针同时收缩 right--; left++; &#125; &#125; &#125; return result; &#125;&#125;; 哈希法： 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; sort(nums.begin(), nums.end()); // 找出a + b + c = 0 // a = nums[i], b = nums[j], c = -(a + b) for (int i = 0; i &lt; nums.size(); i++) &#123; // 排序之后如果第一个元素已经大于零，那么不可能凑成三元组 if (nums[i] &gt; 0) &#123; break; &#125; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; //三元组元素a去重 continue; &#125; unordered_set&lt;int&gt; set; for (int j = i + 1; j &lt; nums.size(); j++) &#123; if (j &gt; i + 2 &amp;&amp; nums[j] == nums[j-1] &amp;&amp; nums[j-1] == nums[j-2]) &#123; // 三元组元素b去重 continue; &#125; int c = 0 - (nums[i] + nums[j]); if (set.find(c) != set.end()) &#123; result.push_back(&#123;nums[i], nums[j], c&#125;); set.erase(c);// 三元组元素c去重 &#125; else &#123; set.insert(nums[j]); &#125; &#125; &#125; return result; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"哈希表","slug":"practices/哈希表","permalink":"https://cs0522.github.io/categories/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"哈希表","slug":"哈希表","permalink":"https://cs0522.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"【学习笔记】设计模式（八）抽象工厂","slug":"n-pattern-08","date":"2024-07-09T03:59:38.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/设计模式/n-pattern-08/","link":"","permalink":"https://cs0522.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/n-pattern-08/","excerpt":"对象创建：抽象工厂。","text":"对象创建：抽象工厂。 模式类型 对象创建 抽象工厂 提供一个接口，让该接口负责创建一系列相关或者相互依赖的对象，无需指定他们具体的类。 使用场景 有应对“多系列对象构建”的需求变化。“系列对象”指的是在某一特定系列下的对象之间有相互依赖、或作用的关系。不同系列的对象之间不能相互依赖。 主要应对“新系列”的需求变动。 系列对象如： SQL Server 系列：SQLConnection、SQLCommand、SQLReader MySQL 系列：MySQLConnection、MySQLCommand、MySQLReader 举例 未使用 这里的对象都写死了，当需求的数据库从 SQL Server 变更为 MySQL 时，修改起来很麻烦。 123456789101112class EmployeeDAO &#123;public: vector&lt;EmployeeDAO&gt; getEmployees() &#123; SQLConnection *connection = new SQLConnection(); SQLCommand *command = new SQLCommand(); command-&gt;setConnection(connection); SQLReader *reader = command-&gt;executeReader(); ... &#125;&#125;; 使用抽象工厂 因为三个接口类必须都是同一个系列，如果其中某个是其他系列则报错。所以三个接口类可以合成一个工厂类，同一个工厂保证了关联性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// 接口类class IDBConnection &#123; virtual fn() = 0;&#125;;class IDBCommand &#123; virtual fn() = 0;&#125;;class IDBReader &#123; virtual fn() = 0;&#125;;// 工厂类// class IDBConnectionFactory &#123;// virtual createConnection() = 0;// &#125;;// class IDBCommandFactory &#123;// virtual createCommand() = 0;// &#125;;// class IDBReaderFactory &#123;// virtual createReader() = 0;// &#125;;// 三个工厂类合成一个工厂类class IDBFactory &#123; virtual createConnection() = 0; virtual createCommand() = 0; virtual createReader() = 0;&#125;;// 具体实现类class SQLConnection : public IDBConnection &#123;&#125;;class SQLCommand : public IDBCommand &#123;&#125;;class SQLReader : public IDBReader &#123;&#125;;// 具体工厂类// class SQLConnectionFactory : public IDBConnectionFactory &#123;// &#125;;// class SQLCommandFactory : public IDBCommandFactory &#123;// &#125;;// class SQLReaderFactory : public IDBReaderFactory &#123;// &#125;;class SQLFactory : public IDBFactory &#123;&#125;;class OracleConnection : public IDBConnection &#123;&#125;;class OracleCommand : public IDBCommand &#123;&#125;;class OracleReader : public IDBReader &#123;&#125;;// 具体工厂类class OracleFactory : public IDBFactory &#123;&#125;;class EmployeeDAO &#123; IDBFactory *dbFactory;public: vector&lt;EmployeeDAO&gt; getEmployees() &#123; IDBConnection *connection = dbFactory-&gt;createConnection(); IDBCommand *command = dbFactory-&gt;createCommand(); command-&gt;setConnection(connection); IDBReader *reader = command-&gt;executeReader(); ... &#125;&#125;;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【学习笔记】设计模式（七）工厂模式","slug":"n-pattern-07","date":"2024-07-08T08:49:33.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/设计模式/n-pattern-07/","link":"","permalink":"https://cs0522.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/n-pattern-07/","excerpt":"对象创建：工厂模式。","text":"对象创建：工厂模式。 模式类型 对象创建 工厂模式 通过对象创建的模式绕开 new，避免对象创建过程中导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象后的第一步工作。 使用场景 定义一个创建对象的接口，让子类决定实例化哪一个类。 用于隔离类对象和使用者和具体类型之间的耦合关系。面对经常变化的具体类型，紧耦合关系（new）会导致软件的脆弱。 缺点在于要求创建方法、参数相同。 举例 未使用工厂模式 123456789101112131415161718192021222324252627282930313233class MainForm&#123; TextBox* textBox; // ... ProgressBar* progressBar; void button_click() &#123; // ... ISplitter *splitter = new BinarySplitter( ... ); splitter-&gt;split(); &#125;&#125;;class ISplitter&#123; virtual void split() = 0;&#125;;class BinarySplitter : public ISplitter&#123; virtual void split() &#123; ... &#125;&#125;;class TextSplitter : public ISplitter&#123; virtual void split() &#123; ... &#125;&#125;;class VideoSplitter : public ISplitter&#123; virtual void split() &#123; ... &#125;&#125;; 使用工厂模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 主体类class MainForm&#123; TextBox* textBox; // ... ProgressBar* progressBar; SplitterFactory* factory; MainForm(SplitterFactory* factory) &#123; this-&gt;factory = factory; &#125; void button_click() &#123; // ... ISplitter *splitter = factory-&gt;create_splitter(); splitter-&gt;split(); &#125;&#125;;// 接口类class ISplitter&#123; virtual void split() = 0;&#125;;// 工厂class SplitterFactory&#123; virtual ISplitter* create_splitter() = 0;&#125;;// 具体类class BinarySplitter : public ISplitter&#123; virtual void split() &#123; ... &#125;&#125;;class TextSplitter : public ISplitter&#123; virtual void split() &#123; ... &#125;&#125;;class VideoSplitter : public ISplitter&#123; virtual void split() &#123; ... &#125;&#125;;// 具体工厂class BinarySplitterFactory : public SplitterFactory&#123; virtual ISplitter* create_splitter() &#123; return new BinarySplitter( ... ); &#125;&#125;;class TextSplitterFactory : public SplitterFactory&#123; virtual ISplitter* create_splitter() &#123; return new TextSplitter( ... ); &#125;&#125;;class VideoSplitterFactory : public SplitterFactory&#123; virtual ISplitter* create_splitter() &#123; return new VideoSplitter( ... ); &#125;&#125;;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【刷题日记】哈希表-赎金信-L383-Easy","slug":"p-hash-ransom-l383","date":"2024-07-08T02:58:43.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/哈希表/p-hash-ransom-l383/","link":"","permalink":"https://cs0522.github.io/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/p-hash-ransom-l383/","excerpt":"给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。","text":"给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 思路 建立哈希表存储 ransomNote 中的字母以及出现的个数；遍历 magazine，当出现相同字母的时候，自减；当哈希表中所有键的值都小于等于 0 时，说明可以满足条件。 只需要满足字符串 magazine 中的每个英文字母 (’a’-’z’) 的统计次数都大于等于 ransomNote 中相同字母的统计次数即可。 学习点 反向思路 代码 初始思路，时间复杂度较高，主要来自于 um_count_leq0 函数。 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int um_count_leq0(unordered_map&lt;char, int&gt; &amp;um) &#123; int count = 0; for (auto it = um.begin(); it != um.end(); it++) &#123; if (it-&gt;second &lt;= 0) ++count; &#125; return count; &#125; bool canConstruct(string ransomNote, string magazine) &#123; // 用哈希表 unordered_map 记录字母出现次数 unordered_map&lt;char, int&gt; um; // 遍历 ransomNote，添加哈希键值对 for (int i = 0; i &lt; ransomNote.length(); ++i) &#123; ++um[ransomNote[i]]; &#125; // 遍历 magazine，当出现哈希集合中全部为 0 的时候，返回 true for (int i = 0; i &lt; magazine.length(); ++i) &#123; // 当哈希集合中存在该字母 if (um.count(magazine[i])) --um[magazine[i]]; if (um_count_leq0(um) == um.size()) return true; &#125; return false; &#125;&#125;; 题解思路： 1234567891011121314151617181920class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; if (ransomNote.length() &gt; magazine.length()) return false; vector&lt;int&gt; counts(26, 0); for (int i = 0; i &lt; magazine.length(); ++i) &#123; ++counts[magazine[i] - &#x27;a&#x27;]; &#125; for (int i = 0; i &lt; ransomNote.length(); ++i) &#123; --counts[ransomNote[i] - &#x27;a&#x27;]; // 如果 &lt; 0，说明 magazine 中的字母数不够 if (counts[ransomNote[i] - &#x27;a&#x27;] &lt; 0) return false; &#125; return true; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"哈希表","slug":"practices/哈希表","permalink":"https://cs0522.github.io/categories/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"哈希表","slug":"哈希表","permalink":"https://cs0522.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"【刷题日记】哈希表-四数相加II-L454-Medium","slug":"p-hash-4sum-l454","date":"2024-07-07T13:48:59.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/哈希表/p-hash-4sum-l454/","link":"","permalink":"https://cs0522.github.io/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/p-hash-4sum-l454/","excerpt":"给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足： 0 &lt;= i, j, k, l &lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0","text":"给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足： 0 &lt;= i, j, k, l &lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 思路 与 L1. 两数之和 思路类似，寻找 target - x。为了降低时间复杂度，因此将 nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 分组为 nums1[i] + nums2[j] = 0 - nums3[k] - nums4[l]，先对 nums1 + nums2 遍历，并存储已出现的元素和以及其个数；然后遍历 nums3 + nums4，并查找当前元素和的相反数以及其出现个数。 学习点 借鉴 L1. 两数之和 的思路，进行 分组 + 哈希表。 代码 修改前：（超出时间限制） 123456789101112131415161718192021222324252627282930class Solution &#123;public: int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123; // nums1 + nums2 = - nums3 - nums4 multiset&lt;int&gt; ms; int res = 0; int nums_size = nums1.size(); // 先遍历 nums1，nums2，保存所有可能取值 for (int i = 0; i &lt; nums_size; ++i) &#123; for (int j = 0; j &lt; nums_size; ++j) &#123; ms.insert(nums1[i] + nums2[j]); &#125; &#125; // 后遍历 nums3，nums4，查找哈希集合中是否有其相反数 for (int i = 0; i &lt; nums_size; ++i) &#123; for (int j = 0; j &lt; nums_size; ++j) &#123; int opp_count = ms.count(0 - nums3[i] - nums4[j]); // 如果找到了，并且有可能不止一个 if (opp_count) res += opp_count; &#125; &#125; return res; &#125;&#125;; 修改后代码，没有超过时间限制，可能 multiset 的 insert 和 count 函数时间复杂度较高。 123456789101112131415161718192021222324252627282930class Solution &#123;public: int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123; // nums1 + nums2 = - nums3 - nums4 unordered_map&lt;int, int&gt; um; int res = 0; int nums_size = nums1.size(); // 先遍历 nums1，nums2，保存所有可能取值 for (int i = 0; i &lt; nums_size; ++i) &#123; for (int j = 0; j &lt; nums_size; ++j) &#123; ++um[nums1[i] + nums2[j]]; &#125; &#125; // 后遍历 nums3，nums4，查找哈希集合中是否有其相反数 for (int i = 0; i &lt; nums_size; ++i) &#123; for (int j = 0; j &lt; nums_size; ++j) &#123; int opp_count = um[0 - nums3[i] - nums4[j]]; // 如果找到了，并且有可能不止一个 if (opp_count) res += opp_count; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"哈希表","slug":"practices/哈希表","permalink":"https://cs0522.github.io/categories/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"哈希表","slug":"哈希表","permalink":"https://cs0522.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"【刷题日记】哈希表-两数之和-L1-Easy","slug":"p-hash-2sum-l1","date":"2024-07-07T03:33:26.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/哈希表/p-hash-2sum-l1/","link":"","permalink":"https://cs0522.github.io/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/p-hash-2sum-l1/","excerpt":"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。","text":"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 思路 时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。 学习点 使用哈希表存储已经访问过的元素，然后在哈希表中查找 target - x。 代码 1234567891011121314class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hashtable; for (int i = 0; i &lt; nums.size(); ++i) &#123; auto it = hashtable.find(target - nums[i]); if (it != hashtable.end()) &#123; return &#123;it-&gt;second, i&#125;; &#125; hashtable[nums[i]] = i; &#125; return &#123;&#125;; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"哈希表","slug":"practices/哈希表","permalink":"https://cs0522.github.io/categories/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"哈希表","slug":"哈希表","permalink":"https://cs0522.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"【刷题日记】哈希表-快乐数-L202-Easy","slug":"p-hash-happyNum-l202","date":"2024-07-06T16:16:50.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/哈希表/p-hash-happyNum-l202/","link":"","permalink":"https://cs0522.github.io/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/p-hash-happyNum-l202/","excerpt":"编写一个算法来判断一个数 n 是不是快乐数。","text":"编写一个算法来判断一个数 n 是不是快乐数。 思路 存在循环（重复）时不满足快乐数条件，返回 false。因此用哈希集合存储已经出现过的 sum 值。 学习点 代码 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: long long cal_sum(int &amp;n) &#123; // 从个位开始保存 long long sum = 0LL; while (n &gt; 0) &#123; int digit = n % 10; sum += digit * digit; n /= 10; &#125; return sum; &#125; bool isHappy(int n) &#123; // 哈希表，如果存在相同值，说明存在循环，返回 false unordered_set&lt;int&gt; us; auto sum = cal_sum(n); while (sum != 1) &#123; // 存在循环 if (us.count(sum)) return false; // 暂时没有循环 us.insert(sum); n = sum; sum = cal_sum(n); &#125; // 退出 while，说明满足 sum == 1 return true; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"哈希表","slug":"practices/哈希表","permalink":"https://cs0522.github.io/categories/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"哈希表","slug":"哈希表","permalink":"https://cs0522.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"【刷题日记】哈希表-两个数组的交集-L349-Easy","slug":"p-hash-intersection-l349","date":"2024-07-06T15:23:17.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/哈希表/p-hash-intersection-l349/","link":"","permalink":"https://cs0522.github.io/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/p-hash-intersection-l349/","excerpt":"给定两个数组 nums1 和 nums2 ，返回它们的交集。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。","text":"给定两个数组 nums1 和 nums2 ，返回它们的交集。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 思路 使用哈希集合，分别遍历一次数组1和数组2，第一次遍历初始化哈希集合，第二次遍历对比交集。再使用另一个集合确保是还没有加入过结果中的元素，避免重复。时间复杂度为 O(m + n)。 学习点 vector&lt;int&gt;(us_no_repeat.begin(), us_no_repeat.end()) vector 利用迭代器的构造方法。 代码 哈希集合： 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; // 哈希集合 unordered_set&lt;int&gt; us; // 为了去除重复 // 结果集合 unordered_set&lt;int&gt; us_no_repeat; // 遍历数组1，加入到哈希集合 for (int i = 0; i &lt; nums1.size(); i++) &#123; us.insert(nums1[i]); &#125; // 遍历数组2，查找相同元素 for (int i = 0; i &lt; nums2.size(); i++) &#123; if (us.count(nums2[i]) &amp;&amp; !us_no_repeat.count(nums2[i])) &#123; us_no_repeat.insert(nums2[i]); &#125; &#125; return vector&lt;int&gt;(us_no_repeat.begin(), us_no_repeat.end()); &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"哈希表","slug":"practices/哈希表","permalink":"https://cs0522.github.io/categories/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"哈希表","slug":"哈希表","permalink":"https://cs0522.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"【刷题日记】哈希表-找到字符串中所有字母异位词-L438-Medium","slug":"p-hash-findAnagram-l438","date":"2024-07-06T13:23:00.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/哈希表/p-hash-findAnagram-l438/","link":"","permalink":"https://cs0522.github.io/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/p-hash-findAnagram-l438/","excerpt":"给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。","text":"给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 思路 与 L49 一致，但超出时间限制。 滑动窗口，固定一段长度，在前进的时候只要左边的字母数量自减，右边的字母数量自加即可，与刚开始的思路优化的是减少了每次都需要进行 key 的排序。实际上也是对哈希表的键的取值的优化。 学习点 构建哈希表的键的取值，滑动窗口在移动的同时只需要两端的字母的数量自减或自加即可，大大节省时间开销。 代码 超出时间限制： 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; findAnagrams(string s, string p) &#123; if (s.length() &lt; p.length()) &#123; return &#123;&#125;; &#125; int len = p.length(); // unordered_map // key(string). value(index) unordered_map&lt;string, vector&lt;int&gt;&gt; um; // 遍历 s for (int i = 0; i &lt; s.length(); i++) &#123; string key = s.substr(i, len); sort(key.begin(), key.end()); um[key].emplace_back(i); &#125; // 找 p 对应的键值 sort(p.begin(), p.end()); return um[p]; &#125;&#125;; 滑动窗口： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;int&gt; findAnagrams(string s, string p) &#123; int s_len = s.length(); int p_len = p.length(); if (s_len &lt; p_len) return &#123;&#125;; // 滑动窗口 + 哈希表 vector&lt;int&gt; s_counts(26, 0); vector&lt;int&gt; p_counts(26, 0); // 存储 indices vector&lt;int&gt; ans; // 初始化 for (int i = 0; i &lt; p_len; ++i) &#123; ++s_counts[s[i] - &#x27;a&#x27;]; ++p_counts[p[i] - &#x27;a&#x27;]; &#125; // 滑动窗口遍历 s for (int i = 0; i &lt; s_len - p_len; ++i) &#123; // 如果哈希数组相同 if (s_counts == p_counts) ans.emplace_back(i); // 不相同，滑动窗口前进，前面的自减，后面的自加 --s_counts[s[i] - &#x27;a&#x27;]; ++s_counts[s[i + p_len] - &#x27;a&#x27;]; &#125; // 最后再比较一次，如果哈希数组相同 if (s_counts == p_counts) ans.emplace_back(s_len - p_len); return ans; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"哈希表","slug":"practices/哈希表","permalink":"https://cs0522.github.io/categories/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"哈希表","slug":"哈希表","permalink":"https://cs0522.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"【刷题日记】哈希表-字母异位词分组-L49-Medium","slug":"p-hash-groupAnagram-l49","date":"2024-07-06T02:25:18.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/哈希表/p-hash-groupAnagram-l49/","link":"","permalink":"https://cs0522.github.io/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/p-hash-groupAnagram-l49/","excerpt":"给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。","text":"给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。 思路 构建哈希表 map 学习点 如何构建哈希的 key 值，来代表每组的 anagram。因为异位词都是字母相同，字母位置不同，所以按照字典排序的结果是一样的，可以当作键。 代码 12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; // 哈希表 map，key 为排序后的 str，值为对应的 vector&lt;string&gt; unordered_map&lt;string, vector&lt;string&gt;&gt; um; for (string str : strs) &#123; string key = str; sort(key.begin(), key.end()); um[key].emplace_back(str); &#125; vector&lt;vector&lt;string&gt;&gt; res; for (auto it = um.begin(); it != um.end(); it++) &#123; res.emplace_back(it-&gt;second); &#125; return res; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"哈希表","slug":"practices/哈希表","permalink":"https://cs0522.github.io/categories/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"哈希表","slug":"哈希表","permalink":"https://cs0522.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"【刷题日记】哈希表-有效的字母异位词-L242-Easy","slug":"p-hash-anagram-l242","date":"2024-07-06T02:11:46.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/哈希表/p-hash-anagram-l242/","link":"","permalink":"https://cs0522.github.io/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/p-hash-anagram-l242/","excerpt":"给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。","text":"给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 思路 建立哈希表，保存每个字符出现的次数。s 中的字母出现则增加，t 中的字母出现则减少。如果最后哈希表中刚好都为 0，则满足条件。 学习点 代码 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool isAnagram(string s, string t) &#123; if (s.length() != t.length()) &#123; return false; &#125; // 建立哈希表，保存每个字符出现的次数 int char_count[26] = &#123;0&#125;; for (int i = 0; i &lt; s.length(); ++i) &#123; char_count[s[i] - &#x27;a&#x27;] += 1; &#125; for (int i = 0; i &lt; t.length(); ++i) &#123; char_count[t[i] - &#x27;a&#x27;] -= 1; &#125; // 如果刚好所有 char_count 里的值均为 0 // 则 s，t 为异位词 for (int i = 0; i &lt; 26; ++i) &#123; if (char_count[i]) &#123; return false; &#125; &#125; return true; &#125; &#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"哈希表","slug":"practices/哈希表","permalink":"https://cs0522.github.io/categories/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"哈希表","slug":"哈希表","permalink":"https://cs0522.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"【刷题日记】哈希表-哈希表理论基础","slug":"p-hash-basic","date":"2024-07-06T01:54:16.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/哈希表/p-hash-basic/","link":"","permalink":"https://cs0522.github.io/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/p-hash-basic/","excerpt":"哈希表理论基础。","text":"哈希表理论基础。 哈希表 哈希表是根据关键码的值而直接进行访问的数据结构。关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。 一般哈希表都是用来快速判断一个元素是否出现集合里。 哈希函数 将元素映射到哈希表上，并得到哈希表上该元素的索引，然后就可以通过索引下标快速访问到该元素。 对得到的索引进行取模操作，确保所有元素都在映射表中。 哈希碰撞 多个元素映射到同一个索引位置 拉链法 和 线性探测法 常见的哈希结构 常见的哈希结构 数组 set 集合 map 映射 set 集合 底层实现 是否有序？ 数值可重复？ 更改数值？ 查询效率 增删效率 std::set 红黑树 有序 否 否 O(log n) O(log n) std::multiset 红黑树 有序 是 否 O(logn) O(logn) std::unordered_set 哈希表 无序 否 否 O(1) O(1) map 集合 底层实现 是否有序？ 数值可重复？ 更改数值？ 查询效率 增删效率 std::map 红黑树 key有序 key不可重复 key不可修改 O(logn) O(logn) std::multimap 红黑树 key有序 key可重复 key不可修改 O(log n) O(log n) std::unordered_map 哈希表 key无序 key不可重复 key不可修改 O(1) O(1)","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"哈希表","slug":"practices/哈希表","permalink":"https://cs0522.github.io/categories/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"哈希表","slug":"哈希表","permalink":"https://cs0522.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"【学习笔记】设计模式（六）桥模式","slug":"n-pattern-06","date":"2024-07-04T14:04:56.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/设计模式/n-pattern-06/","link":"","permalink":"https://cs0522.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/n-pattern-06/","excerpt":"单一职责：桥模式。","text":"单一职责：桥模式。 模式类型 单一职责 桥模式 由于某些类型的固有实现逻辑，使他具有多个维度的变化。 将抽象部分（业务功能）与实现部分（平台实现）分离，使他们都可以独立地变化。 使用场景 与装饰模式类似，不过接口进行了拆分，将业务功能和平台实现进行了接口的拆分。 桥模式中的桥可以看作是 Messager 基类中的那个指向 MessagerImp 的指针，将二者组合起来，而不是继承。 以下例子为一个具有一个维度的变化。如果具有多个维度的变化，则需要多个指向基类的指针来充当“桥”组合各个基类。 与装饰模式作为对比，桥模式是主要区别是进行了接口的拆分。 举例 不使用桥模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Messager&#123;public: virtual void login() = 0; virtual void send_message() = 0; virtual void send_picture() = 0; virtual void play_sound() = 0; virtual void draw_shape() = 0; virtual void write_text() = 0; virtual void connect() = 0; virtual ~Messager() &#123;&#125;&#125;;// PC 平台class PCMessagerBase : public Messager&#123; virtual void play_sound() &#123; ... &#125; virtual void draw_shape() &#123; ... &#125; virtual void write_text() &#123; ... &#125; virtual void connect() &#123; ... &#125;&#125;;// 移动平台class MobileMessagerBase: public Messager&#123; virtual void play_sound() &#123; ... &#125; virtual void draw_shape() &#123; ... &#125; virtual void write_text() &#123; ... &#125; virtual void connect() &#123; ... &#125;&#125;;// PC 平台添加功能class PCMessagerLite : public PCMessagerBase&#123; virtual void login() &#123; PCMessagerBase::connect(); // ... &#125; virtual void send_message() &#123; PCMessagerBase::write_text(); // ... &#125; virtual void send_picture() &#123; PCMessagerBase::play_sound(); PCMessagerBase::draw_shape(); // ... &#125;&#125;// 移动平台添加功能class MobileMessagerLite : public MobileMessagerBase&#123; virtual void login() &#123; MobileMessagerBase::connect(); // ... &#125; virtual void send_message() &#123; MobileMessagerBase::write_text(); // ... &#125; virtual void send_picture() &#123; MobileMessagerBase::play_sound(); MobileMessagerBase::draw_shape(); // ... &#125;&#125;void process()&#123; MobileMessagerLite *m = new MobileMessagerLite();&#125; 使用桥模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 对原本的 Messager 接口隔离class Messager&#123; // 组合，而不是继承 MessagerImp* messagerImp;public: Messager(Messager* m): messagerImp(m) &#123; &#125; virtual void login() = 0; virtual void send_message() = 0; virtual void send_picture() = 0; virtual ~Messager() &#123;&#125;&#125;;class MessagerImp&#123;public: virtual void play_sound() = 0; virtual void draw_shape() = 0; virtual void write_text() = 0; virtual void connect() = 0; virtual ~MessagerImp() &#123;&#125;&#125;;// PC 平台class PCMessagerImp : public MessagerImp&#123; virtual void play_sound() &#123; ... &#125; virtual void draw_shape() &#123; ... &#125; virtual void write_text() &#123; ... &#125; virtual void connect() &#123; ... &#125;&#125;;// 移动平台class MobileMessagerImp: public MessagerImp&#123; virtual void play_sound() &#123; ... &#125; virtual void draw_shape() &#123; ... &#125; virtual void write_text() &#123; ... &#125; virtual void connect() &#123; ... &#125;&#125;;// PC 平台、移动平台添加功能// 添加的功能一致。因此和装饰模式一样class MessagerLite : public Messager&#123; // 初始化 MessagerLite(MessagerImp* m): messagerImp(m) &#123; &#125; virtual void login() &#123; messagerImp-&gt;connect(); // ... &#125; virtual void send_message() &#123; messagerImp-&gt;write_text(); // ... &#125; virtual void send_picture() &#123; messagerImp-&gt;play_sound(); messagerImp-&gt;draw_shape(); // ... &#125;&#125;;void process()&#123; MessagerImp *pcMessagerImp = new PCMessagerImp(); MessagerLite *ml = new MessagerLite(pcMessagerImp);&#125;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【学习笔记】设计模式（五）装饰模式","slug":"n-pattern-05","date":"2024-07-04T13:04:31.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/设计模式/n-pattern-05/","link":"","permalink":"https://cs0522.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/n-pattern-05/","excerpt":"单一职责：装饰模式。","text":"单一职责：装饰模式。 模式类型 单一职责 装饰模式 某些时候“过度使用继承来扩展对象的功能”，导致缺乏灵活性；随着子类（扩展功能）的增多，各种子类的组合会导致更多子类的膨胀。 如何使“对象功能的扩展”根据需要来动态实现？避免子类的膨胀？ 通过组合（装饰类包含指向主体类的基类的指针）而非继承的方法，装饰模式实现了在运行时动态扩展对象功能的能力。 使用场景 在已有的功能上添加一系列扩展操作。主体类在多个方向上的扩展功能。 举例 未使用装饰模式 其中的额外的扩展操作（加密操作）都是一致的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 业务操作class Stream&#123;public: virtual char read(int number) = 0; // 定位文件流 virtual void seek(int pos) = 0; virtual void write(char data) = 0; virtual ~Stream() &#123; &#125;&#125;;// 主体类// 文件流class FileStream : public Stream&#123;public: virtual char read(int number) &#123; // ... &#125; virtual void seek(int pos) &#123; // ... &#125; virtual void write(char data) &#123; // ... &#125;&#125;;// 网络流class NetworkStream : public Stream&#123; // ...&#125;;// 内存流class MemoryStream : public Stream&#123; // ...&#125;;// 扩展操作class CryptoFileStream : public FileStream&#123;public: virtual void read(int number) &#123; // ...加密操作 FileStream::read(number); &#125; virtual void seek(int pos) &#123; // ...加密操作 FileStream::seek(pos); &#125; virtual void write(char data) &#123; // ...加密操作 FileStream::write(data); &#125;&#125;; 当额外的操作需要修改时，就需要大量的修改工作量。 使用装饰模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// 业务操作class Stream&#123;public: virtual char read(int number) = 0; // 定位文件流 virtual void seek(int pos) = 0; virtual void write(char data) = 0; virtual ~Stream() &#123; &#125;&#125;;// 主体类// 文件流class FileStream : public Stream&#123;public: virtual char read(int number) &#123; // ... &#125; virtual void seek(int pos) &#123; // ... &#125; virtual void write(char data) &#123; // ... &#125;&#125;;// 网络流class NetworkStream : public Stream&#123; // ...&#125;;// 内存流class MemoryStream : public Stream&#123; // ...&#125;;// 扩展操作// 装饰基类class DecoratorStream : public Stream&#123;protected: Stream* stream;public: DecoratorStream(Stream* stream): stream(stream) &#123; &#125;&#125;; // 装饰类1class CryptoStream : public DecoratorStream&#123;public: // 给 stream 赋值，是文件流、网络流还是内存流 CryptoStream(Stream* stream): DecoratorStream(stream) &#123; &#125; virtual void read(int number) &#123; // ...加密操作 stream-&gt;read(number); &#125; virtual void seek(int pos) &#123; // ...加密操作 stream-&gt;seek(pos); &#125; virtual void write(char data) &#123; // ...加密操作 stream-&gt;write(data); &#125;&#125;;// 装饰类2class BufferStream : public DecoratorStream&#123; Stream* stream;public: // 给 stream 赋值，是文件流、网络流还是内存流 BufferStream(Stream* stream): DecoratorStream(stream) &#123; &#125; // ...&#125;;void process()&#123; FileStream *fs = new FileStream(); CryptoStream * cs = new CryptoStream(fs); BufferStream * bs = new BufferStream(fs);&#125;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【学习笔记】设计模式（四）观察者模式","slug":"n-pattern-04","date":"2024-07-03T13:37:54.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/设计模式/n-pattern-04/","link":"","permalink":"https://cs0522.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/n-pattern-04/","excerpt":"组件协作：观察者模式。","text":"组件协作：观察者模式。 模式类型 组件协作 观察者模式 需要为某些对象建立一种“通知依赖关系”——一个对象的改变，所有依赖他的对象都得到通知。 使用背景 一个对象发生改变，所有依赖他的对象都要得到通知。 当一个对象的改变需要同时影响其他对象，并且不希望对象之间紧密耦合时，可以使用观察者模式。 举例 未使用观察者模式 123456789101112131415161718192021222324252627282930// FileSplitterclass FileSplitter&#123; // ... ProgressBar* m_progress_bar; FileSplitter(...) &#123; ... &#125; void split() &#123; if (m_progress_bar != nullptr) &#123; m_progress_bar-&gt;set_value(...); &#125; &#125;&#125;;// MainFormclass MainForm : public Form&#123; // ... ProgressBar* progress_bar; void button1_click() &#123; // ... FileSplitter splitter(...); splitter.split(); &#125;&#125;; 使用观察者模式 FileSplitter 类没有耦合界面类。 123456789101112131415161718192021222324252627282930313233343536373839404142// IProgressclass IProgress&#123; virtual void do_progress(float value) = 0; virtual ~do_progress() &#123;&#125;&#125;;// FileSplitterclass FileSplitter&#123; IProgress* m_iprogress; // 抽象通知 FileSplitter(..., IProgress* iprogress) m_iprogress(iprogress) &#123; ... &#125; void split() &#123; if (m_iprogress != nullptr) &#123; m_iprogress-&gt;do_progress(); &#125; &#125;&#125;;// MainFormclass MainForm : public Form, public IProgress&#123; // ... ProgressBar* progress_bar; void button1_click() &#123; // ... FileSplitter splitter(..., this); splitter.split(); &#125; // 形式上看，FileSplitter 原先的 set_value 迁移到 MainForm 类中 virtual void do_progress(float value) &#123; progress_bar-&gt;set_value(); &#125;&#125;; 另一个观察者模式的示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 被观察者的抽象基类public abstract class Subject&#123; private IList&lt;Observer&gt; _observers = new List&lt;Observer&gt;(); // 当前主题对象的观察者集合 // 添加观察者 public void Attach(Observer observer) &#123; _observers.Add(observer); &#125; // 移除观察者 public void Detach(Observer observer) &#123; _observers.Remove(observer); &#125; // 通知观察者 public void Nofity() &#123; Console.WriteLine(&quot;猫突然大叫一声...喵...&quot;); foreach (var item in _observers) &#123; item.Update(); &#125; &#125;&#125;// 观察者的抽象基类public abstract class Observer&#123; public abstract void Update();&#125;// 被观察者的子类public class Cat : Subject&#123; &#125;// 观察者的子类1public class Mouse : Observer&#123; public override void Update() &#123; Console.WriteLine(&quot;老鼠：快跑，被老猫发现了...&quot;); &#125;&#125;// 观察者的子类2public class Master : Observer&#123; public override void Update() &#123; Console.WriteLine(&quot;主人：我家的猫又叫了，开灯看看怎么回事？&quot;); &#125;&#125;// 调用internal class Client&#123; public void Start() &#123; Cat cat = new Cat(); cat.Attach(new Mouse()); cat.Attach(new Master()); cat.Nofity(); &#125;&#125;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【刷题日记】链表-环形链表II-L142-Medium","slug":"p-linklist-circle-l142","date":"2024-07-03T12:06:10.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/链表/p-linklist-circle-l142/","link":"","permalink":"https://cs0522.github.io/practices/%E9%93%BE%E8%A1%A8/p-linklist-circle-l142/","excerpt":"给定一个链表的头节点 head，返回链表开始入环的第一个节点。如果链表无环，则返回 null。","text":"给定一个链表的头节点 head，返回链表开始入环的第一个节点。如果链表无环，则返回 null。 思路 哈希表，存储已经遍历过的 ListNode 指针。 快慢指针，追及问题。。。 学习点 快慢指针，快指针和慢指针最终都会相遇。 代码 哈希表 1234567891011121314151617181920class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; // 哈希集合保存已经出现过的指针 ListNode *p = head; std::unordered_set&lt;ListNode*&gt; us; while (p != nullptr) &#123; // 如果哈希集合中存在这个指针 if (us.count(p)) return p; // 不存在 us.insert(p); p = p-&gt;next; &#125; // 遍历结束，没有环 return p; &#125;&#125;; 快慢指针 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; // 快慢指针 ListNode* fast = head; ListNode* slow = head; while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; // 相遇 if (slow == fast) &#123; ListNode* index1 = head; ListNode* index2 = fast; while (index1 != index2) &#123; index1 = index1-&gt;next; index2 = index2-&gt;next; &#125; return index1; &#125; &#125; return nullptr; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"链表","slug":"practices/链表","permalink":"https://cs0522.github.io/categories/practices/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"链表","slug":"链表","permalink":"https://cs0522.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【学习笔记】设计模式（三）策略模式","slug":"n-pattern-03","date":"2024-07-03T08:54:57.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/设计模式/n-pattern-03/","link":"","permalink":"https://cs0522.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/n-pattern-03/","excerpt":"组件协作：策略模式。","text":"组件协作：策略模式。 模式类型 组件协作 策略模式 软件构建过程中，某些对象使用的算法可能多种多样，经常改变。如何在运行时根据需要透明地改变对象的算法，将算法与对象本身解耦？ 遵循开放封闭原则，开放扩展（类的增加），封闭修改（原对象的修改）。 定义一系列算法，把它们一个个封装起来，并使他们能够在运行时根据需要发生切换（变化），这个模式使得算法可以独立于使用它的客户程序而变化（扩展，子类化）。 接口保持稳定，其中的算法发生变化。 使用场景 含有许多 if-else 条件语句的代码通常可以使用策略模式。绝对稳定不变的 if-else 可以不用使用策略模式。 举例 未使用策略模式 12345678910111213141516171819enum TaxBase&#123; CN_Tax, US_Tax, DE_Tax&#125;;class SalesOrder&#123; double cal_tax() &#123; if (CN_Tax) &#123; // A &#125; else if (US_Tax) &#123; // B &#125; else if (DE_Tax) &#123; // C &#125; &#125;&#125;; 使用策略模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445class TaxStrategy&#123; virtual double cal_tax(const Context&amp; context) = 0; virtual ~TaxStrategy() &#123;&#125;&#125;;class CNTax : public TaxStrategy&#123; virtual double cal_tax(const Context&amp; context) &#123; // A &#125;&#125;;class USTax : public TaxStrategy&#123; ...&#125;;class DETax : public TaxStrategy&#123; ...&#125;;class SalesOrder&#123; TaxStrategy* strategy; SalesOrder(StrategyFactory* strategyFactory) &#123; // 工厂模式，是哪一个子类由工厂决定 this-&gt;strategy = strategyFactory-&gt;newStrategy(); &#125; ~SalesOrder() &#123; delete strategy; &#125; calculate_tax() &#123; // ... Context context(); // ... double val = strategy-&gt;cal_tax(context); // ... &#125;&#125;;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【学习笔记】设计模式（二）模板方法","slug":"n-pattern-02","date":"2024-07-02T16:54:57.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/设计模式/n-pattern-02/","link":"","permalink":"https://cs0522.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/n-pattern-02/","excerpt":"组件协作：模板方法。","text":"组件协作：模板方法。 模型类型 组件协作 模板方法 定义一个操作中的算法的骨架（稳定），而将一些步骤（变化）放到子类中。模板方法使得子类不需要修改父类的结构（复用）即可重定义（override，重写）该算法中的某些特定步骤。 使用场景 一个算法骨架稳定，但其中一些步骤存在变化，可以使用模板方法。 举例 没有使用 template method 123456789101112131415161718192021222324class Library&#123; void step1() &#123; ... &#125; void step3() &#123; ... &#125; void step5() &#123; ... &#125;&#125;;class App&#123; void step2() &#123; ... &#125; void step4() &#123; ... &#125;&#125;;int main()&#123; Library l(); App a(); l.step1(); a.step2(); l.step3(); a.step4(); l.step5();&#125; 使用 template method 1234567891011121314151617181920212223242526272829303132333435363738class Library&#123; void step1() &#123; ... &#125; // 纯虚函数，子类实现 virtual void step2() = 0; void step3() &#123; ... &#125; // 纯虚函数，子类实现 virtual void step4() = 0; void step5() &#123; ... &#125; // 定义操作的算法骨架 // 稳定 template method void run() &#123; step1(); // 虚函数的多态调用 step2(); step3(); // 虚函数的多态调用 step4(); step5(); &#125; virtual ~Library() &#123;&#125;&#125;;class App : public Library&#123; virtual void step2() &#123; ... &#125; virtual void step4() &#123; ... &#125;&#125;;int main()&#123; // 声明类型为父类，实际类型为子类 Library *l = new App(); l-&gt;run();&#125;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【学习笔记】记录 C++ 中使用过的有用代码","slug":"d-cpp-used-codes","date":"2024-06-29T13:46:07.000Z","updated":"2025-01-24T08:35:50.725Z","comments":false,"path":"notes/d-cpp-used-codes/","link":"","permalink":"https://cs0522.github.io/notes/d-cpp-used-codes/","excerpt":"记录 C++ 中使用过的有用代码，以后应该还用的上。","text":"记录 C++ 中使用过的有用代码，以后应该还用的上。 const char, string 与 char 的转化 1234567891011121314// string 与 const char* 转换string s = &quot;abcd&quot;;const char *c_s = s.c_str();// const char* 转换 stringconst char* p = &quot;abcd&quot;;string s(p);// string 与 char* 的转换string s = &quot;abcd&quot;;char* c;const int len = s.length();c = new char[len + 1];strcpy(c, s.c_str()); 减少 vector 增加元素的开销 12345678std::vector&lt;std::pair&lt;int, int&gt;&gt; vec;// 1. emplace_backvec.emplace_back(1, 2);// 2. moveauto p = std::make_pair(1, 2);vec.push_back(std::move(p)); 获取文件描述符 1234#include &lt;fcntl.h&gt;int fd = open(filename.c_str(), O_RDWR);// 打开失败的返回值为 -1 读取 ivecs 数据文件 ivecs 格式每个向量构成：4 + dim * 4 字节，4 为一个 int。 1234567891011121314151617181920212223std::vector&lt;std::vector&lt;int&gt;&gt; read_ivecs(const std::string &amp;filename)&#123; std::ifstream input(filename, std::ios::binary); if (!input.is_open()) &#123; std::cerr &lt;&lt; &quot;无法打开文件: &quot; &lt;&lt; filename &lt;&lt; std::endl; exit(EXIT_FAILURE); &#125; std::vector&lt;std::vector&lt;int&gt;&gt; data; while (!input.eof()) &#123; int dim; input.read(reinterpret_cast&lt;char *&gt;(&amp;dim), sizeof(int)); std::vector&lt;int&gt; vec(dim); input.read(reinterpret_cast&lt;char *&gt;(vec.data()), dim * sizeof(int)); if (input) &#123; data.push_back(std::move(vec)); &#125; &#125; return data;&#125; 读取 bvecs 数据文件 bvecs 格式每个向量构成：4 + dim * 1 字节，4 为一个 int。 1234567891011121314151617181920212223242526272829std::vector&lt;std::vector&lt;float&gt;&gt; read_bvecs(const std::string &amp;filename)&#123; std::ifstream input(filename, std::ios::binary); if (!input.is_open()) &#123; std::cerr &lt;&lt; &quot;Open &quot; &lt;&lt; filename &lt;&lt; &quot;failed. &quot; &lt;&lt; std::endl; exit(EXIT_FAILURE); &#125; std::vector&lt;std::vector&lt;float&gt;&gt; data; while (!input.eof()) &#123; int dim; input.read((char *)&amp;dim, sizeof(int)); std::vector&lt;float&gt; vec(dim); std::vector&lt;u_char&gt; buff(dim); input.read((char *)buff.data(), dim * sizeof(u_char)); // u_char to float for (int i = 0; i &lt; dim; i++) &#123; vec[i] = (float)(buff[i]); &#125; data.push_back(std::move(vec)); &#125; return data;&#125; mmap 内存映射读取大文件的一部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void mmap_read_bvecs(std::string &amp;filename)&#123; // 获取文件描述符 int fd = open(filename.c_str(), O_RDWR); // 打开失败 if (fd == -1) &#123; perror((&quot;Open \\&quot;&quot; + filename + &quot;\\&quot; failed. Reason&quot;).c_str()); exit(EXIT_FAILURE); &#125; // 获取文件信息 struct stat fs; // 获取失败 if (fstat(fd, &amp;fs) == -1) &#123; perror(&quot;Get file information filed. Reason&quot;); close(fd); exit(EXIT_FAILURE); &#125; // 文件大小 off_t file_size = fs.st_size; std::cout &lt;&lt; &quot;File size: &quot; &lt;&lt; file_size &lt;&lt; std::endl; // 内存映射，获得指针 u_char* p = (u_char*)mmap(NULL, file_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); // 映射失败 if (p == MAP_FAILED) &#123; perror(&quot;Memory mapping failed. Reason&quot;); close(fd); exit(EXIT_FAILURE); &#125; // 访问数据 long long byte_count = 0LL; // 获取 vector number int num = 0; while(byte_count &lt; file_size) &#123; // vector dimension int dim; u_char *q = p + byte_count; dim = *(int*)q; q += sizeof(int); // output vector // std::cout &lt;&lt; &quot;[&quot;; for (int i = 0; i &lt; dim; i++) &#123; std::cout &lt;&lt; (float)*(q + i) &lt;&lt; ((i == dim - 1) ? &quot;]\\n&quot; : &quot;, &quot;); &#125; byte_count += sizeof(int) + dim * sizeof(u_char); num += 1; &#125; // output vector number std::cout &lt;&lt; &quot;vector num: &quot; &lt;&lt; num &lt;&lt; std::endl; // 关闭映射 munmap(p, file_size); // 关闭文件 close(fd);&#125; 打印错误信息 void perror(const char *s) 用来将上一个函数发生错误的原因输出到标准设备 (stderr)。参数 s 所指的字符串会先打印，后面再加上错误原因字符串。此错误原因依照全局变量 error 的值来决定要输出的字符串。在库函数中有个error变量，每个error值对应着以字符串表示的错误类型。当调用函数出错时，该函数已经重新设置了error的值。perror 将输入的一些信息和现在的error所对应的错误一起输出。 strerror() 通过标准错误的标号，获得错误的描述字符串，将单纯的错误标号转为字符串描述，方便用户查找错误。 123456789101112131415void perror(const char *s);char* strerror(errno);// perror// 获取文件描述符int fd = open(filename.c_str(), O_RDWR);// 打开失败if (fd == -1)&#123; perror((&quot;Open \\&quot;&quot; + filename + &quot;\\&quot; failed. Reason&quot;).c_str()); exit(EXIT_FAILURE);&#125;// strerrorprintf(&quot;strerror: %s\\n&quot;, strerror(errno)); 创建虚拟内存 12345678910111213141516int main() &#123; off_t size = 1024 * 1024; // 虚拟内存大小为 1MB int fd = open(&quot;/dev/zero&quot;, O_RDWR); // 使用 /dev/zero 作为匿名内存映射的数据源 void* ptr = mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0); if (ptr == MAP_FAILED) &#123; std::cerr &lt;&lt; &quot;mmap failed&quot; &lt;&lt; std::endl; return 1; &#125; // 可以使用 ptr 来访问这块虚拟内存 // ... munmap(ptr, size); // 当不再需要这块虚拟内存时，记得释放它 close(fd); // 关闭文件描述符&#125; 虚拟内存中创建 vector 数组 在虚拟内存中使用定位 new 运算符（placement new），最后手动在虚拟内存中调用 std::vector 的析构函数 12345678910// 使用虚拟内存创建 std::vectorstd::vector&lt;int&gt;* vec = new (ptr) std::vector&lt;int&gt;();// 添加元素到 vectorvec-&gt;push_back(10);vec-&gt;push_back(20);vec-&gt;push_back(30);// 释放 vectorvec-&gt;~vector(); // 手动调用析构函数 placement new 允许在已经分配好的内存区域中创建对象，可以决定对象存储的确切位置。 1std::vector&lt;std::vector&lt;float&gt;&gt;* data = new(v_mem) std::vector&lt;std::vector&lt;float&gt;&gt;(); 其中 v_mem 为指针，指向预分配的内存地址。 保存已访问的数据 哈希表 unordered_set 1234std::unordered_set&lt;ListNode*&gt; visited;if (visited.count(p)) &#123; ... &#125;visited.insert(p); 构造 vector：通过其他 STL 容器初始化一个 vector 12345678// eg.1std::unordered_set&lt;int&gt; us;// ...return vector&lt;int&gt;(us.begin(), us.end());// eg.2int arr[5] = &#123;1, 2, 3, 4, 5&#125;;return vector&lt;int&gt;(arr, arr+5); vector 构造函数： 1234567891011121314// 1vector( const Allocator&amp; = Allocator() );// 2vector( size_type n,constT&amp; value = T(), const Allocator&amp; = Allocator() );// 3// 上面例子中用的这个构造函数// 利用迭代器template &lt;class InputIterator&gt; vector ( InputIterator first, InputIterator last, const Allocator&amp; = Allocator() );// 4vector ( const vector&lt;T,Allocator&gt;&amp; x ); 获取文件大小 123456789101112// 获取文件信息int fd = open(&quot;...&quot;);struct stat fs;// 获取失败if (fstat(fd, &amp;fs) == -1) &#123; perror(&quot;Get file information filed. Reason&quot;); close(fd); exit(EXIT_FAILURE);&#125;// 文件大小off_t file_size = fs.st_size;std::cout &lt;&lt; &quot;File size: &quot; &lt;&lt; file_size &lt;&lt; std::endl; 通过 seekg() 和 tellg()： 1234std::ifstream in(&quot;...&quot;, std::ios::binary);in.seekg(0, std::ios::end);std::ios::pos_type ss = in.tellg();size_t fsize = (size_t)ss; 多态中父类析构调用子类析构 将析构函数声明为虚函数实现。 1234567891011121314151617181920class A&#123;public: explicit A() &#123;&#125; virtual ~A() &#123; cout &lt;&lt; &quot;~A()&quot; &lt;&lt; endl; &#125;&#125;;class B : public A&#123;public: explicit B() &#123;&#125; virtual ~B() &#123; cout &lt;&lt; &quot;~B()&quot; &lt;&lt; endl; &#125;&#125;;A *a = new B();a-&gt;~A();// result// print: ~B()// ~A() barrier 方式的无锁线程同步 Linux 中提供了多种同步机制，其中使用 barrier 是多线程之间进行同步的方法之一。 假设多个线程约定一个栅栏，只有当所有的线程都达到这个栅栏时，栅栏才会放行，否则到达此处的线程将被阻塞。 在代码中，当所有 thread 都执行到 barrier_wait() 后，才继续执行后续代码。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;pthread_barrier_t barrier;void* initor(void* args) &#123; printf(&quot;---------------thread init work(%d)--------------\\n&quot;, time(NULL)); //模拟初始化工作。 sleep(3); //到达栅栏 pthread_barrier_wait(&amp;barrier); printf(&quot;--------------thread start work(%d)--------------\\n&quot;, time(NULL)); sleep(3); printf(&quot;--------------thread stop work(%d)--------------\\n&quot;, time(NULL)); return NULL;&#125;int main(int argc, char* argv[]) &#123; //初始化栅栏，该栅栏等待两个线程到达时放行 pthread_barrier_init(&amp;barrier, NULL, 2); printf(&quot;**************main thread barrier init done****************\\n&quot;); pthread_t pid; pthread_create(&amp;pid, NULL, &amp;initor, NULL); printf(&quot;**************main waiting(%d)********************\\n&quot;, time(NULL)); //主线程到达，被阻塞，当初始化线程到达栅栏时才放行。 pthread_barrier_wait(&amp;barrier); printf(&quot;***************main after barrier wait(%d)***************\\n&quot;, time(NULL)); pthread_barrier_destroy(&amp;barrier); printf(&quot;***************main start to work(%d)****************\\n&quot;, time(NULL)); sleep(10); pthread_join(pid, NULL); printf(&quot;***************thread complete(%d)***************\\n&quot;, time(NULL)); system(&quot;pause&quot;); return 0;&#125; 输出结果： 12345678**************main thread barrier init done******************************main waiting(1725351103)********************---------------thread init work(1725351103)-------------- --------------thread start work(1725351106)--------------***************main after barrier wait(1725351106)******************************main start to work(1725351106)**************** --------------thread stop work(1725351109)--------------***************thread complete(1725351116)*************** Linux 宏 likely()、unlikely() 使用 likely()，执行 if 后面的语句的机会更大，使用 unlikely()，执行 else 后面的语句机会更大一些。 123456if (likely(a&gt;b)) &#123; fun1();&#125;if (unlikely(a&gt;b))&#123; fun2();&#125; 这里就是程序员可以确定 a&gt;b 在程序执行流程中出现的可能相比较大，因此运用了 likely() 告诉编译器将 fun1() 函数的二进制代码紧跟在前面程序的后面，这样就 cache 在预取数据时就可以将 fun1() 函数的二进制代码拿到 cache 中。这样，也就添加了 cache 的命中率。 同样的，unlikely() 的作用就是告诉编译器，a&lt;=b 可能行大，fun2() 紧跟前面程序。 总之，likely 和 unlikely 的功能就是添加 cache 的命中率，提高系统执行速度。 条件编译与 CFLAGS 条件编译： 12345#ifdef PERF_LATENCY_LOG uint32_t io_id; ... clock_gettime(...);#endif 意思是，只有当在编译时宏 PERF_LATENCY_LOG 被定义了，#ifdef ... #endif 中的代码块才会被编译并执行；否则该代码块不会被编译执行。 这个宏可以在多个地方定义： 定义在头文件中 123// util.h#define PERF_LATENCY_LOG... 在 CMakeLists.txt 中 通过 CFLAGS 变量。 全局编译 12set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; -O0 -g&quot;)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -O0 -g&quot;) 区分编译 12345set(CMAKE_C_FLAGS_DEBUG &quot;$&#123;CMAKE_C_FLAGS_DEBUG&#125; -DDEBUG&quot;)set(CMAKE_CXX_FLAGS_DEBUG &quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -DDEBUG&quot;)set(CMAKE_CXX_FLAGS_Release &quot;$&#123;CMAKE_CXX_FLAGS_Release&#125; -DNDBUG&quot;)set(CMAKE_C_FLAGS_Release &quot;$&#123;CMAKE_C_FLAGS_Release&#125; -DNDBUG&quot;) 对于 Debug 模式，编译选项实际使用的值是 CMAKE_CXX_FLAGS 和 CMAKE_CXX_FLAGS_DEBUG 的值的组合（不管 CMAKE_CXX_FLAGS_RELEASE 设置什么值都不会被加入到编译选项中）。 对于 Release 模式，编译选项实际使用的值是 CMAKE_CXX_FLAGS 和 CMAKE_CXX_FLAGS_RELEASE 的值的组合（不管 CMAKE_CXX_FLAGS_DEBUG 设置什么值都不会被加入到编译选项中）。 1234mkdir debugcd debugcmake -DCMAKE_BUILD_TYPE=Debug ..make 1234mkdir releasecd releasecmake -DCMAKE_BUILD_TYPE=Release ..make 在 Makefile 中 通过 CFLAGS 变量。 1234# Makefile# 直接赋值或者追加CFLAGS = -g -WallCFLAGS += -DPERF_LATENCY_LOG 通过 make 命令 1234# MakefileCFLAGS=$(CFLAG)CFLAGS+=-g -Wall... 输入 make 编译命令： 1make CFLAG=-DPERF_LATENCY_LOG 在 configure 文件中 configure 文件本质可以看成是 shell 脚本文件，用来在 make 前配置 make 参数。 可以在 configure 文件中根据 configure 的参数来设置 make 的 CFLAGS 变量值。 这种情况一般是存在多级 Makefile，项目通过 configure 来配置。 123456789101112131415161718# configure...# 添加 PERF_LATENCY_LOG --with-perf-latency-log) CONFIG[PERF_LATENCY_LOG]=y ;;...# CFLAGS 添加相应宏if [[ &quot;$&#123;CONFIG[PERF_LATENCY_LOG]&#125;&quot; = &quot;y&quot; ]]; then echo -n &quot;Configuring PERF_LATENCY_LOG...&quot; CFLAGS=&quot;$&#123;CFLAGS&#125; -DPERF_LATENCY_LOG&quot; echo &quot;done.&quot;fi# CONFIG# perf latency logCONFIG_PERF_LATENCY_LOG=n 这样在 ./configure 时，加上 --with-perf-latency-log 参数，就可以在 CFLAGS 变量中添加 -DPERF_LATENCY_LOG 宏定义，再输入 make 就不需要输入参数了。 局部变量块作用域 大括号 &#123;&#125; 在 C++ 中用于定义一个作用域。在这个作用域内，局部变量被创建并使用；当这个作用域结束时，局部变量会被销毁释放资源。 1234567891011&#123; std::string string_val; // If it cannot pin the value, it copies the value to its internal buffer. // The intenral buffer could be set during construction. PinnableSlice pinnable_val(&amp;string_val); db-&gt;Get(ReadOptions(), db-&gt;DefaultColumnFamily(), &quot;key2&quot;, &amp;pinnable_val); assert(pinnable_val == &quot;value&quot;); // If the value is not pinned, the internal buffer must have the value. assert(pinnable_val.IsPinned() || string_val == &quot;value&quot;);&#125;// 在外面不能访问 string_val 变量 std::async 以异步方式执行函数或者任务，并且能够在未来某个时间点获取执行结果。 12345678910111213141516171819202122232425262728293031323334#include &lt;future&gt;#include &lt;iostream&gt;std::future&lt;int&gt; f1 = std::async(std::launch::async, []()&#123; return 8; &#125;); cout&lt;&lt;f1.get()&lt;&lt;endl; //output: 8 std::future&lt;int&gt; f2 = std::async(std::launch::async, []()&#123; cout&lt;&lt;8&lt;&lt;endl; &#125;); f2.wait(); //output: 8 std::future&lt;int&gt; future = std::async(std::launch::async, []()&#123; std::this_thread::sleep_for(std::chrono::seconds(3)); return 8; &#125;); std::cout &lt;&lt; &quot;waiting...\\n&quot;; std::future_status status; do &#123; status = future.wait_for(std::chrono::seconds(1)); if (status == std::future_status::deferred) &#123; std::cout &lt;&lt; &quot;deferred\\n&quot;; &#125; else if (status == std::future_status::timeout) &#123; std::cout &lt;&lt; &quot;timeout\\n&quot;; &#125; else if (status == std::future_status::ready) &#123; std::cout &lt;&lt; &quot;ready!\\n&quot;; &#125; &#125; while (status != std::future_status::ready); std::cout &lt;&lt; &quot;result is &quot; &lt;&lt; future.get() &lt;&lt; &#x27;\\n&#x27;;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://cs0522.github.io/tags/Linux/"}]},{"title":"【学习笔记】虚拟内存 + mmap 内存映射","slug":"n-virtual-memory-mmap","date":"2024-06-29T11:44:34.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"notes/C/n-virtual-memory-mmap/","link":"","permalink":"https://cs0522.github.io/notes/C/n-virtual-memory-mmap/","excerpt":"mmap 可以把磁盘文件的一部分直接映射到内存，这样文件中的位置直接就有对应的内存地址，对文件的读写可以直接用指针而不需要 read/write 函数。","text":"mmap 可以把磁盘文件的一部分直接映射到内存，这样文件中的位置直接就有对应的内存地址，对文件的读写可以直接用指针而不需要 read/write 函数。 1. 虚拟内存 https://welkinx.com/2020/02/07/mmap/ 1.1 Linux 增加交换空间 未开启交换空间： 123456789101112131415161718sudo su# 查看内存使用情况free -h# 创建 swap 文件# 单位 bs 为 G，大小 count 为 20，创建 20G 交换空间dd if=/dev/zero of=/swapfile bs=1G count=20# 激活 swap 文件chmod 600 swapfilemkswap swapfile# 开启 swapswapon swapfilefree -h# 查看已开启的交换空间swapon --show 已开启交换空间，重新修改 swap 大小： 123456789101112# 查看内存使用情况free -h# 关闭指定 swapswapoff /swapfile# 重新分配fallocate -l 30G /swapfilechmod 600 swapfilemkswap swapfileswapon swapfile 1.2 创建虚拟内存实例 1.2.1 创建虚拟内存、在虚拟内存中读入大文件数据并存储 注意 placement new 表达式的用法，其中 new(place) 中 place 为指针，指向预分配的内存地址。 点击查看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;#include &lt;vector&gt;/** * TODO * 用 mmap 实现虚拟大内存，并构建一个接口调用； * 在这块虚拟大内存中读入数据集并保存，用于建图。*//** * @name: create_virtual_mem * @msg: 创建虚拟内存，并返回指向该内存地址的指针 * @param &#123;off_t&amp;&#125; mem_size: 虚拟内存大小 * @param &#123;int&amp;&#125; fd: 文件描述符，main 函数中指定 * @return &#123;void*&#125;: 虚拟内存指针 */void* create_virtual_mem(off_t &amp;mem_size, int &amp;fd)&#123; // 使用 /dev/zero 作为匿名内存映射的数据源 fd = open(&quot;/dev/zero&quot;, O_RDWR); void* v_mem = mmap(nullptr, mem_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, fd, 0); // 映射失败 if (v_mem == MAP_FAILED) &#123; std::cout &lt;&lt; &quot;Create virtual memory failed. Reason: &quot; &lt;&lt; strerror(errno) &lt;&lt; std::endl; exit(EXIT_FAILURE); &#125; // 文件和映射统一关闭 // 返回虚拟内存指针 return v_mem;&#125;/** * @name: release_mem * @msg: 释放虚拟内存以及内存映射 * @param &#123;void*&#125; v_mem: 指向虚拟内存的指针 * @param &#123;off_t&amp;&#125; mem_size: 虚拟内存大小 * @param &#123;int&amp;&#125; fd: 文件描述符，用于关闭虚拟内存打开的 /dev/zero * @param &#123;u_char* &amp;&#125; file_map: 读取大文件时的内存映射的指针 * @param &#123;off_t &amp;&#125; file_size: 被映射的大文件的长度（字节） * @return &#123;void&#125; */void release_mem(void* v_mem, off_t &amp;mem_size, int &amp;fd, u_char* &amp;file_map, off_t &amp;file_size)&#123; munmap(v_mem, mem_size); close(fd); // 关闭 read data 映射 munmap(file_map, file_size); // 关闭文件 close(fd);&#125;/** * @name: mmap_read_bvecs * @msg: 通过 mmap 内存映射读取 *.bvecs 文件 * @param &#123;string&#125; &amp;filename: 文件名 * @param &#123;void*&#125; &amp;v_mem: 虚拟内存指针 * @param &#123;u_char* &amp;&#125; file_map: 读取大文件时的内存映射的指针 * @param &#123;off_t &amp;&#125; file_size: 被映射的大文件的长度（字节） * @param &#123;std::vector&lt;std::vector&lt;float&gt;&gt;* &amp;&#125; data: 存储数据 * @return &#123;void&#125; */void mmap_read_bvecs(std::string &amp;filename, void* v_mem, u_char* &amp;file_map, off_t &amp;file_size, std::vector&lt;std::vector&lt;float&gt;&gt;* &amp;data)&#123; // 获取文件描述符 int fd = open(filename.c_str(), O_RDWR); // 打开失败 if (fd == -1) &#123; perror((&quot;Open \\&quot;&quot; + filename + &quot;\\&quot; failed. Reason&quot;).c_str()); exit(EXIT_FAILURE); &#125; // 获取文件信息 struct stat fs; // 获取失败 if (fstat(fd, &amp;fs) == -1) &#123; perror(&quot;Get file information filed. Reason&quot;); close(fd); exit(EXIT_FAILURE); &#125; // 文件大小 file_size = fs.st_size; std::cout &lt;&lt; &quot;File size: &quot; &lt;&lt; file_size &lt;&lt; std::endl; // read data 映射，获得指针 file_map = (u_char*)mmap(nullptr, file_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); // 映射失败 if (file_map == MAP_FAILED) &#123; perror(&quot;Memory mapping failed. Reason&quot;); close(fd); exit(EXIT_FAILURE); &#125; // 访问数据 long long byte_count = 0LL; // vector number long long num = 0; std::cout &lt;&lt; &quot;Reading...&quot; &lt;&lt; std::endl; while(byte_count &lt; file_size) &#123; // vector dimension int dim; u_char* q = file_map + byte_count; dim = *(int*)q; q += sizeof(int); // 物理内存内保存单个数据 std::vector&lt;float&gt; vec(dim); for (int i = 0; i &lt; dim; i++) &#123; vec[i] = (float)*(q + i); &#125; // 存储到 data 中 data-&gt;push_back(std::move(vec)); byte_count += sizeof(int) + dim * sizeof(u_char); num += 1; &#125; // 文件和映射需要统一关闭&#125;int main()&#123; std::string filename = &quot;./dataset/bigann_learn.bvecs&quot;; // 创建虚拟内存 int fd_v_mem; off_t mem_size = 1024 * 1024 * 1024 * 20LL; auto v_mem = create_virtual_mem(mem_size, fd_v_mem); // 读入数据 u_char *file_map = nullptr; off_t file_size = 0LL; // 在虚拟内存中开辟空间存储 // 注意 placement new 表达式的用法 std::vector&lt;std::vector&lt;float&gt;&gt;* data = new(v_mem) std::vector&lt;std::vector&lt;float&gt;&gt;(); mmap_read_bvecs(filename, v_mem, file_map, file_size, data); // output auto vec_num = data-&gt;size(); auto vec_dim = (*data)[0].size(); std::cout &lt;&lt; &quot;vector number: &quot; &lt;&lt; vec_num &lt;&lt; std::endl; std::cout &lt;&lt; &quot;vector dimension: &quot; &lt;&lt; vec_dim &lt;&lt; std::endl; // for (size_t i = 0; i &lt; vec_num; ++i) // &#123; // std::cout &lt;&lt; &quot;[&quot;; // for (size_t j = 0; j &lt; vec_dim; ++j) // &#123; // std::cout &lt;&lt; (*data)[i][j] &lt;&lt; ((j == vec_dim - 1) ? &quot;&quot; : &quot;, &quot;); // &#125; // std::cout &lt;&lt; &quot;]\\n&quot;; // &#125; // 关闭映射和虚拟内存 release_mem(v_mem, mem_size, fd_v_mem, file_map, file_size); return 0;&#125; 2. mmap https://www.cnblogs.com/huxiao-tee/p/4660352.html 2.1 mmap 简介 mmap 可以把磁盘文件的一部分直接映射到内存，这样文件中的位置直接就有对应的内存地址，对文件的读写可以直接用指针而不需要 read/write 函数。 此函数的作用是创建一个新的虚拟内存区域，并将指定的对象映射到此区域。 内存映射（Memory Mapping）将文件内容映射到进程的虚拟地址空间。在这种机制下，文件可以被视为内存的一部分，从而允许程序直接对这部分内存进行读写操作，而无需传统的文件 I/O 调用，从而减少系统的用户态、内核态切换，减少切换开销。通过这种方式，文件内容可以通过指针直接访问，就像访问普通的内存数组一样，这极大地提高了文件操作的效率和直观性。 映射时，操作系统将文件的一部分或全部内容映射到虚拟内存地址空间。这些虚拟地址与物理内存地址相关联，但并不是所有数据立即加载到物理内存中。 当访问映射的地址时，如果对应数据不在物理内存中，操作系统会自动从磁盘加载所需的数据页到物理内存中（这称为“页错误”处理）。 2.2 mmap 特点 2.2.1 数据持久化 通过 mmap 映射的数据通常来自文件系统中的文件。这意味着数据是持久化的，即使程序终止，文件中的数据依然存在。当你通过映射的内存区域修改数据时，这些更改最终会反映到磁盘上的文件中。 2.2.2 大文件读写 mmap 特别适合于需要频繁读写大文件的场景，因为它可以减少磁盘 I/O 操作的次数。它也允许文件的一部分被映射到内存中，这对于处理大型文件尤为有用。 2.2.3 性能和效率 映射文件到内存可以提高文件访问的效率，尤其是对于随机访问或频繁读写的场景。系统可以利用虚拟内存管理和页缓存机制来优化访问。 2.2.4 同步和一致性 使用 mmap 时，必须考虑到文件内容的同步问题。例如，使用 msync 调用来确保内存中的更改被同步到磁盘文件中。 2.2.5 页缓存 使用 mmap 映射文件到内存时，操作系统利用页缓存（提升文件读写效率。在内存上，与文件中的数据块进行绑定。文件被划分为多个页大小的数据块）来优化对这些文件数据的访问。页缓存是操作系统的一部分，用于存储从磁盘读取的数据页。 访问 mmap 映射的文件时，并不是每次读取都会直接触及磁盘。如果所需数据已经在页缓存中（由于之前的读取操作），则直接从缓存中获取数据，而不需要磁盘 I/O。 2.3 mmap 函数介绍 1234void *mmap(void *addr, size_t len, int prot, int flags, int filedes, __off_t offset);int munmap(void *addr, size_t len); 2.3.1 参数 addr: 内存上的映射地址，给内核一个提示（建议），从（内存上）什么地址开始映射。建立映射后，真正的映射首地址通过返回值得到。如果 addr 为空，则内核自己选择合适的地址。 len: 需要映射的那部分文件的长度（多少个字节），代表将文件中多大的部分映射到内存。 prot: 4 个取值 PROT_EXEC: 映射部分可执行，如动态库 PROT_READ: 映射部分可读 PROT_WRITE: 映射部分可写 PROT_NONE: 映射部分不可访问 flags: 2 个取值 MAP_SHARED: 多个进程对相同映射文件共享 MAP_PRIVATE: 多个进程对相同映射文件不共享 filedes: 文件描述符。文件描述符是内核为了高效管理已经被打开的文件的索引，是一个非负整数，用于指代被打开的文件。文件描述符可以通过系统函数 open() 或 create() 获取，也可以从父进程继承，用于进行文件操作或网络通信。 offset: 从文件的什么位置开始映射，必须是页（内存上）大小的整数倍。 2.3.2 返回值 返回值为 void* 指针，因此可以进行各种类型转换，如 int*、char* 等。C++ 中不能直接 int* p = mmap()，需要对 mmap() 进行类型转换，如 int* p = (int*)mmap()。 2.3.3 需要的头文件 123456#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt; 2.4 mmap 实例 2.4.1 简单对文件进行修改 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;int main()&#123; std::string filename = &quot;./dataset/test.txt&quot;; int len = 12; // 获取文件描述符 int fd = open(filename.c_str(), O_RDWR); // 内存映射 auto* p = (char*)mmap(NULL, len, PROT_WRITE | PROT_READ, MAP_SHARED, fd, 0); // 直接对内存进行修改 for (int i = 0; i &lt; len; i++) &#123; p[i] = &#x27;a&#x27; + i; &#125; // 关闭内存映射 munmap(p, len); return 0;&#125; 2.4.2 读取 bvecs 文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465std::vector&lt;std::vector&lt;float&gt;&gt; mmap_read_bvecs(std::string &amp;filename)&#123; // 获取文件描述符 int fd = open(filename.c_str(), O_RDWR); // 打开失败 if (fd == -1) &#123; perror((&quot;Open \\&quot;&quot; + filename + &quot;\\&quot; failed. Reason&quot;).c_str()); exit(EXIT_FAILURE); &#125; // 获取文件信息 struct stat fs; // 获取失败 if (fstat(fd, &amp;fs) == -1) &#123; perror(&quot;Get file information filed. Reason&quot;); close(fd); exit(EXIT_FAILURE); &#125; // 文件大小 off_t file_size = fs.st_size; std::cout &lt;&lt; &quot;File size: &quot; &lt;&lt; file_size &lt;&lt; std::endl; // 内存映射，获得指针 u_char* p = (u_char*)mmap(NULL, file_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); // 映射失败 if (p == MAP_FAILED) &#123; perror(&quot;Memory mapping failed. Reason&quot;); close(fd); exit(EXIT_FAILURE); &#125; // 访问数据 long long byte_count = 0LL; // 获取 vector number int num = 0; while(byte_count &lt; file_size) &#123; // vector dimension int dim; u_char *q = p + byte_count; dim = *(int*)q; q += sizeof(int); // output vector // std::cout &lt;&lt; &quot;[&quot;; for (int i = 0; i &lt; dim; i++) &#123; std::cout &lt;&lt; (float)*(q + i) &lt;&lt; ((i == dim - 1) ? &quot;]\\n&quot; : &quot;, &quot;); &#125; byte_count += sizeof(int) + dim * sizeof(u_char); num += 1; &#125; // output vector number std::cout &lt;&lt; &quot;vector num: &quot; &lt;&lt; num &lt;&lt; std::endl; // 关闭映射 munmap(p, file_size); // 关闭文件 close(fd); // return data; return &#123;&#125;;&#125; 3. 虚拟内存分配例子 3.1 mmap_read_bvecs mmap_read_bvecs 函数单独写在一个 cpp 文件中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;cstring&gt;#include &lt;mimalloc.h&gt;#include &lt;vector&gt;/** * @name: mmap_read_bvecs * @msg: 通过 mmap 内存映射读取 *.bvecs 文件 * @param &#123;string&#125; &amp;filename: 文件名 * @param &#123;void*&#125; &amp;v_mem: 虚拟内存指针 * @param &#123;u_char* &amp;&#125; file_map: 读取大文件时的内存映射的指针 * @param &#123;off_t &amp;&#125; file_size: 被映射的大文件的长度（字节） * @param &#123;std::vector&lt;std::vector&lt;float&gt;&gt;* &amp;&#125; data: 存储数据 * @return &#123;void&#125; */void mmap_read_bvecs(std::string &amp;filename, u_char* &amp;file_map, off_t &amp;file_size, std::vector&lt;std::vector&lt;float&gt;&gt;* &amp;data)&#123; // 获取文件描述符 int fd = open(filename.c_str(), O_RDWR); // 打开失败 if (fd == -1) &#123; perror((&quot;Open \\&quot;&quot; + filename + &quot;\\&quot; failed. Reason&quot;).c_str()); exit(EXIT_FAILURE); &#125; // 获取文件信息 struct stat fs; // 获取失败 if (fstat(fd, &amp;fs) == -1) &#123; perror(&quot;Get file information filed. Reason&quot;); close(fd); exit(EXIT_FAILURE); &#125; // 文件大小 file_size = fs.st_size; std::cout &lt;&lt; &quot;File size: &quot; &lt;&lt; file_size &lt;&lt; std::endl; // read data 映射，获得指针 file_map = (u_char*)mmap(nullptr, file_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); // 映射失败 if (file_map == MAP_FAILED) &#123; perror(&quot;Memory mapping failed. Reason&quot;); close(fd); exit(EXIT_FAILURE); &#125; // 访问数据 long long byte_count = 0LL; // vector number long long num = 0; std::cout &lt;&lt; &quot;Reading...&quot; &lt;&lt; std::endl; while(byte_count &lt; file_size) &#123; // vector dimension int dim; u_char* q = file_map + byte_count; dim = *(int*)q; q += sizeof(int); // 物理内存内保存单个数据 std::vector&lt;float&gt; vec(dim); for (int i = 0; i &lt; dim; i++) &#123; vec[i] = (float)*(q + i); &#125; // 存储到 data 中 data-&gt;push_back(std::move(vec)); byte_count += sizeof(int) + dim * sizeof(u_char); num += 1; &#125; // 文件和映射需要统一关闭 close(fd);&#125;/** * @name: release_mmap * @msg: 释放内存映射 * @param &#123;u_char* &amp;&#125; file_map: 读取大文件时的内存映射的指针 * @param &#123;off_t &amp;&#125; file_size: 被映射的大文件的长度（字节） * @return &#123;void&#125; */void release_mmap(u_char* &amp;file_map, off_t &amp;file_size)&#123; // 关闭 read data 映射 munmap(file_map, file_size);&#125; 3.2 virtual_mem_test 直接调用 Linux API，手动创建虚拟内存后，在虚拟内存中开辟空间 12345678910111213141516171819202122232425262728293031323334353637int main()&#123; std::string filename = &quot;./dataset/bigann_learn.bvecs&quot;; // 创建虚拟内存 int fd_v_mem; off_t mem_size = 1024 * 1024 * 1024 * 65LL; auto v_mem = create_virtual_mem(mem_size, fd_v_mem); // 读入数据 u_char *file_map = nullptr; off_t file_size = 0LL; // 在虚拟内存中开辟空间存储 // 注意 placement new 表达式的用法 std::vector&lt;std::vector&lt;float&gt;&gt;* data = new (v_mem) std::vector&lt;std::vector&lt;float&gt;&gt;(); mmap_read_bvecs(filename, file_map, file_size, data); // output auto vec_num = data-&gt;size(); auto vec_dim = (*data)[0].size(); std::cout &lt;&lt; &quot;vector number: &quot; &lt;&lt; vec_num &lt;&lt; std::endl; std::cout &lt;&lt; &quot;vector dimension: &quot; &lt;&lt; vec_dim &lt;&lt; std::endl; // for (size_t i = 0; i &lt; vec_num; ++i) // &#123; // std::cout &lt;&lt; &quot;[&quot;; // for (size_t j = 0; j &lt; vec_dim; ++j) // &#123; // std::cout &lt;&lt; (*data)[i][j] &lt;&lt; ((j == vec_dim - 1) ? &quot;&quot; : &quot;, &quot;); // &#125; // std::cout &lt;&lt; &quot;]\\n&quot;; // &#125; // 关闭映射和虚拟内存 release_mem(v_mem, mem_size, fd_v_mem, file_map, file_size); return 0;&#125; 3.3 boost_interprocess_test 使用 Boost::interprocess 库，共享内存。在磁盘上创建一块空间用于文件映射。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;boost/interprocess/managed_mapped_file.hpp&gt;#include &quot;mmap_read_bvecs.cpp&quot;namespace bip = boost::interprocess;int main()&#123; // 创建共享内存 std::size_t mem_size = 1024 * 1024 * 1024 * 100LL; bip::managed_mapped_file file(bip::open_or_create, &quot;./shared_memory.bin&quot;, mem_size); // 在共享内存中分配一个大内存块 std::size_t alloc_size = 1024 * 1024 * 1024 * 80LL; void* mem_ptr = file.get_segment_manager()-&gt;allocate(alloc_size); if (mem_ptr == nullptr) &#123; perror(&quot;Memory allocation failed. Reason&quot;); exit(EXIT_FAILURE); &#125; // read std::string filename = &quot;./dataset/bigann_learn.bvecs&quot;; off_t file_size = 0LL; u_char *file_map = nullptr; std::vector&lt;std::vector&lt;float&gt;&gt;* data = new (mem_ptr) std::vector&lt;std::vector&lt;float&gt;&gt;(); mmap_read_bvecs(filename, file_map, file_size, data); // output auto vec_num = data-&gt;size(); auto vec_dim = (*data)[0].size(); std::cout &lt;&lt; &quot;vector number: &quot; &lt;&lt; vec_num &lt;&lt; std::endl; std::cout &lt;&lt; &quot;vector dimension: &quot; &lt;&lt; vec_dim &lt;&lt; std::endl; // 释放分配的大内存块 file.get_segment_manager()-&gt;deallocate(mem_ptr); release_mmap(file_map, file_size); return 0;&#125; 3.4 mimalloc_test 使用 mimalloc 内存分配器分配虚拟内存。 12345678910111213141516171819202122232425262728293031#include &quot;mmap_read_bvecs.cpp&quot;int main() &#123; std::string filename = &quot;./dataset/bigann_learn.bvecs&quot;; // 分配未对齐内存 size_t mem_size = 1024 * 1024 * 1024 * 65LL; auto v_mem = mi_malloc(mem_size); // 读入数据 u_char *file_map = nullptr; off_t file_size = 0LL; // 在虚拟内存中开辟空间存储 std::vector&lt;std::vector&lt;float&gt;&gt;* data = new (v_mem) std::vector&lt;std::vector&lt;float&gt;&gt;(); mmap_read_bvecs(filename, file_map, file_size, data); // output auto vec_num = data-&gt;size(); auto vec_dim = (*data)[0].size(); std::cout &lt;&lt; &quot;vector number: &quot; &lt;&lt; vec_num &lt;&lt; std::endl; std::cout &lt;&lt; &quot;vector dimension: &quot; &lt;&lt; vec_dim &lt;&lt; std::endl; // 释放内存 mi_free(v_mem); mi_stats_print(NULL); // 手动触发一次垃圾回收 mi_collect(true); return 0;&#125;","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"C++","slug":"notes/C","permalink":"https://cs0522.github.io/categories/notes/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://cs0522.github.io/tags/Linux/"},{"name":"mmap","slug":"mmap","permalink":"https://cs0522.github.io/tags/mmap/"},{"name":"虚拟内存","slug":"虚拟内存","permalink":"https://cs0522.github.io/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"}]},{"title":"【学习笔记】设计模式（一）要点与总结","slug":"n-pattern-01","date":"2024-06-29T09:10:29.000Z","updated":"2025-01-17T18:57:47.129Z","comments":false,"path":"notes/设计模式/n-pattern-01/","link":"","permalink":"https://cs0522.github.io/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/n-pattern-01/","excerpt":"设计模式的简介、设计原则与总结。","text":"设计模式的简介、设计原则与总结。 简介 可复用面向对象软件基础 好的软件设计：复用！！！ 接口标准化！！！ 设计模式的前提是存在一个稳定点 在变化和稳定之间寻找稳定点 要看出代码哪部分稳定，哪部分变化 面向对象设计原则 1. 依赖倒置原则 DIP 高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）。 实现细节（变化）应该依赖于抽象（稳定）。 即从问题中提出抽象类，找到低层稳定的抽象。 比如初始 MainForm 依赖于 Line 和 Rectangle，但低层模块这两个变化，实现细节不一致，因此还需要提出这两个的抽象类 Shape，因此修改后，MainForm 依赖于 Shape，Line 和 Rectangle 依赖于 Shape。 2. 开放封闭原则 OCP 对扩展开放，对更改封闭。 类模块可扩展，但是不可修改。 3. 单一责任原则 SRP 一个类应该仅有一个引起它变化的原因。 变化的方向隐含着类的责任。 4. Liskov 替换原则 LSP 子类能够替换他们的基类。 5. 接口隔离原则 ISP 接口应该小而完备。 仅暴露有必要的方法，非必要不暴露。 6. 优先使用对象组合，而不是继承 继承在某种程度上破坏了封装性，子类和父类耦合度高。 对象组合则要求被组合的对象具有良好定义的接口，耦合度较低。 7. 封装变化点 使用封装来创建对象之间的分界层，在一侧进行修改，另一层不受影响，从而实现层次间的松耦合。 8. 针对接口编程 不将（业务类）变量声明为某个特定的具体类，而是声明为接口类。 客户程序只需要知道对象的接口。 减少系统各部分的依赖关系，实现“高内聚、低耦合”。 重构技法 静态 -&gt; 动态 早绑定 -&gt; 晚绑定 继承 -&gt; 组合 编译时依赖 -&gt; 运行时依赖 紧耦合 -&gt; 松耦合 什么时候不用模式 代码可读性很差 需求理解很浅 变化没有显现 不是系统的关键依赖点 项目没有复用价值 项目将要发布 总结 不要为了模式而模式 关注抽象类 &amp; 接口 理清变化点和稳定点 审视依赖关系 良好的设计是演化的结果","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"【刷题日记】链表-链表相交-L160-Easy","slug":"p-linklist-intersection-l160","date":"2024-06-29T04:07:14.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/链表/p-linklist-intersection-l160/","link":"","permalink":"https://cs0522.github.io/practices/%E9%93%BE%E8%A1%A8/p-linklist-intersection-l160/","excerpt":"给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。","text":"给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 面试题 02.07. 链表相交 思路 用两个栈，从后往前的思路，分别存储指向 A，B 链表的指针。因为链表相交，则从相交节点往后的节点都是一致的，因此找到第一个不一致的节点，就是相交节点的前驱；如果其中某个栈空了都没有找到，则返回栈空的链表的指针，该指针指向的即为相交节点 哈希集合，用哈希集合存储链表节点。首先遍历链表 headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中。如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 nullptr 学习点 unordered_set 无序集合，构造哈希集合 代码 用栈，从后往前 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; // 用栈分别保存 A，B 链表的指针，从后往前对比 stack&lt;ListNode*&gt; stA; stack&lt;ListNode*&gt; stB; ListNode* pA = headA; ListNode* pB = headB; while (pA != nullptr) &#123; stA.push(pA); pA = pA-&gt;next; &#125; while (pB != nullptr) &#123; stB.push(pB); pB = pB-&gt;next; &#125; // 弹出栈 bool found = false; while (!stA.empty() &amp;&amp; !stB.empty()) &#123; pA = stA.top(); stA.pop(); pB = stB.top(); stB.pop(); // 相交点的前驱的条件 if ((pA != pB) &amp;&amp; (pA-&gt;next == pB-&gt;next)) &#123; found = true; break; &#125; &#125; // 如果找到了，相交节点为 next if (found) &#123; return (pA-&gt;next); &#125; // 如果没找到，则返回当前指向节点 else &#123; if (stA.empty()) return pA; else return pB; &#125; &#125;&#125;; 无序集合，建立哈希集合 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; // 哈希集合 unordered_set&lt;ListNode*&gt; uset; // 初始化哈希集合 ListNode *p = headA; while (p != nullptr) &#123; uset.insert(p); p = p-&gt;next; &#125; // 遍历 headB p = headB; while (p != nullptr) &#123; if (uset.count(p)) &#123; // 存在指向该节点的指针 return p; &#125; p = p-&gt;next; &#125; return nullptr; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"链表","slug":"practices/链表","permalink":"https://cs0522.github.io/categories/practices/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"链表","slug":"链表","permalink":"https://cs0522.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【刷题日记】链表-删除链表的倒数第N个节点-L19-Medium","slug":"p-linklist-delNFromEnd-l19","date":"2024-06-28T13:25:37.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/链表/p-linklist-delNFromEnd-l19/","link":"","permalink":"https://cs0522.github.io/practices/%E9%93%BE%E8%A1%A8/p-linklist-delNFromEnd-l19/","excerpt":"给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。","text":"给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 19. 删除链表的倒数第 N 个结点 思路 两次遍历，第 1 次计算总数目，第 2 次删除指定节点 用栈倒序存储指针，栈内正数第 N 个指针即指向删除的目标节点；弹出指针，最后返回头节点 update * 双指针。快指针始终比慢指针快 n 个节点。这样只需要遍历一遍 学习点 栈存储指针 倒数 n 个节点，n 这个值保持不变，双指针节省遍历次数 代码 两次遍历 123456789101112131415161718192021222324252627282930class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; // 两遍遍历 // 1 取得个数 ListNode* p = head; int count = 0; while (p != nullptr) &#123; count += 1; p = p-&gt;next; &#125; // 2 删除节点 // 创建头节点 ListNode* head_node = new ListNode(-1, head); p = head_node; int target_index = count - n; while (target_index &gt; 0) &#123; p = p-&gt;next; target_index -= 1; &#125; // 删除他的下一个节点 ListNode* target = p-&gt;next; p-&gt;next = target-&gt;next; delete target; return head_node-&gt;next; &#125;&#125;; 栈 12345678910111213141516171819202122232425262728class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; // 栈，存储指针 stack&lt;ListNode*&gt; st; // 添加头节点 ListNode* head_node = new ListNode(-1, head); ListNode* p = head_node; while (p != nullptr) &#123; st.push(p); p = p-&gt;next; &#125; // 弹出栈 for (int i = 1; i &lt;= n; i++) &#123; st.pop(); &#125; // 待删除节点的前驱 ListNode* pre = st.top(); ListNode* target = pre-&gt;next; pre-&gt;next = target-&gt;next; delete target; return head_node-&gt;next; &#125;&#125;; 双指针 123456789101112131415161718192021222324252627282930class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; // 双指针 // 添加头节点 ListNode* head_node = new ListNode(-1, head); // 初始化快慢指针 ListNode* slow = head_node; ListNode* fast = slow; while (n &gt;= 0) &#123; fast = fast-&gt;next; --n; &#125; // 遍历 while (fast != nullptr) &#123; // forward fast = fast-&gt;next; slow = slow-&gt;next; &#125; // fast 指向表尾 nullptr // slow 指向待删除元素前驱 ListNode* target = slow-&gt;next; slow-&gt;next = target-&gt;next; delete target; return head_node-&gt;next; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"链表","slug":"practices/链表","permalink":"https://cs0522.github.io/categories/practices/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"链表","slug":"链表","permalink":"https://cs0522.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【刷题日记】链表-两两交换链表中的节点-L24-Medium","slug":"p-linklist-swap-l24","date":"2024-06-25T02:58:30.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/链表/p-linklist-swap-l24/","link":"","permalink":"https://cs0522.github.io/practices/%E9%93%BE%E8%A1%A8/p-linklist-swap-l24/","excerpt":"给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。","text":"给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 24. 两两交换链表中的节点 思路 修改指针指向 学习点 添加一个空的头节点，方便统一交换，不需要单独针对 head 节点设置 代码 1234567891011121314151617181920212223242526272829class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; // 新建头节点 ListNode *head_node = new ListNode(-1, head); // 前一个节点 ListNode *pre = head_node; // 当前节点 ListNode *curr = head; while (curr != nullptr) &#123; // 下一个节点 ListNode *post = curr-&gt;next; // post 不为 null if (post != nullptr) &#123; curr-&gt;next = post-&gt;next; post-&gt;next = curr; pre-&gt;next = post; &#125; // forward pre = curr; curr = curr-&gt;next; &#125; return head_node-&gt;next; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"链表","slug":"practices/链表","permalink":"https://cs0522.github.io/categories/practices/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"链表","slug":"链表","permalink":"https://cs0522.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【刷题日记】链表-反转链表-L206-Easy","slug":"p-linklist-reverse-l206","date":"2024-06-24T17:05:00.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/链表/p-linklist-reverse-l206/","link":"","permalink":"https://cs0522.github.io/practices/%E9%93%BE%E8%A1%A8/p-linklist-reverse-l206/","excerpt":"给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。","text":"给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 思路 交换值。栈，遍历 2 遍，时间复杂度 O(n)，空间复杂度 O(n) 反转指针 学习点 ans = new ListNode(x.val, ans)，当前指向节点A（或 null），构建新节点B，其 next 指针指向节点A（或 null），同时指针指向新节点B 代码 栈： 12345678910111213141516171819202122232425// 栈class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; // 栈 // 交换 val stack&lt;int&gt; s; // 遍历 2 遍 ListNode *p = head; while (p != nullptr) &#123; s.push(p-&gt;val); p = p-&gt;next; &#125; ListNode *q = head; while (q != nullptr &amp;&amp; !s.empty()) &#123; q-&gt;val = s.top(); s.pop(); q = q-&gt;next; &#125; return head; &#125;&#125;; 评论区更简单解法： 123456789101112class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode ans = nullptr; for (ListNode x = head; x != nullptr; x = x.next) &#123; // 新建 node 的 next 域指向当前 node // ans 指向新建 node // 以此达到反转指针的目的 ans = new ListNode(x.val, ans); &#125; return ans; &#125;&#125; 反转指针： 123456789101112131415161718192021class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; // pre 指向前驱点 ListNode *pre = nullptr; ListNode *p = head; while (p != nullptr) &#123; // 暂存下一个节点的指针 ListNode *p_next = p-&gt;next; // 反转指针 p-&gt;next = pre; // 指针移动 pre = p; p = p_next; &#125; return pre; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"链表","slug":"practices/链表","permalink":"https://cs0522.github.io/categories/practices/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"链表","slug":"链表","permalink":"https://cs0522.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【刷题日记】链表-设计链表-L707-Medium","slug":"p-linklist-basic-l707","date":"2024-06-11T09:04:25.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/链表/p-linklist-basic-l707/","link":"","permalink":"https://cs0522.github.io/practices/%E9%93%BE%E8%A1%A8/p-linklist-basic-l707/","excerpt":"你可以选择使用单链表或者双链表，设计并实现自己的链表。 单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。","text":"你可以选择使用单链表或者双链表，设计并实现自己的链表。 单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。 707. 设计链表 思路 构造含有头节点的双链表 学习点 链表的基本操作 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134struct DNode&#123; int val; DNode* next; DNode* prev; DNode(int _val): val(_val) &#123;&#125; DNode(int _val, DNode* _next, DNode* _prev): val(_val), next(_next), prev(_prev) &#123;&#125;&#125;;// 带头节点class MyLinkedList &#123;public: MyLinkedList() &#123; // 初始化一个空节点 this-&gt;head = new DNode(-1, nullptr, nullptr); this-&gt;size = 0; &#125; int get(int index) &#123; if (index &lt; 0 || index &gt;= this-&gt;size || this-&gt;head-&gt;next == nullptr) &#123; return -1; &#125; auto p = this-&gt;head; while (index &gt;= 0 &amp;&amp; p != nullptr) &#123; p = p-&gt;next; --index; &#125; return p-&gt;val; &#125; void addAtHead(int val) &#123; DNode* new_node = new DNode(val, nullptr, nullptr); // 设置前驱后继 new_node-&gt;next = this-&gt;head-&gt;next; new_node-&gt;prev = this-&gt;head; // 修改链表前驱后继 if (this-&gt;head-&gt;next != nullptr) &#123; this-&gt;head-&gt;next-&gt;prev = new_node; &#125; this-&gt;head-&gt;next = new_node; // 增加个数 ++this-&gt;size; &#125; void addAtTail(int val) &#123; int count = this-&gt;size; auto p = this-&gt;head; // 移动到末尾元素 while (count &gt; 0) &#123; p = p-&gt;next; --count; &#125; // 添加元素 DNode* new_node = new DNode(val, nullptr, nullptr); // 设置前驱 new_node-&gt;prev = p; // 链接节点 p-&gt;next = new_node; // 增加个数 ++this-&gt;size; &#125; void addAtIndex(int index, int val) &#123; if (index &gt; this-&gt;size || index &lt; 0) &#123; return; &#125; if (index == this-&gt;size) &#123; addAtTail(val); return; &#125; auto p = head; // 遍历到 index - 1 处的元素 while (index &gt; 0) &#123; p = p-&gt;next; --index; &#125; // p 指向 index - 1 处的元素 DNode* new_node = new DNode(val, nullptr, nullptr); p-&gt;next-&gt;prev = new_node; new_node-&gt;next = p-&gt;next; new_node-&gt;prev = p; p-&gt;next = new_node; // 增加个数 ++this-&gt;size; &#125; void deleteAtIndex(int index) &#123; if (index &lt; 0 || index &gt;= this-&gt;size) &#123; return; &#125; auto p = head; while (index &gt;= 0) &#123; p = p-&gt;next; --index; &#125; // p 指向要删除的节点 // 前后节点链接 p-&gt;prev-&gt;next = p-&gt;next; if (p-&gt;next != nullptr) &#123; p-&gt;next-&gt;prev = p-&gt;prev; &#125; // 释放 p delete p; // 减少个数 --this-&gt;size; &#125;private: DNode* head; int size;&#125;;/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj-&gt;get(index); * obj-&gt;addAtHead(val); * obj-&gt;addAtTail(val); * obj-&gt;addAtIndex(index,val); * obj-&gt;deleteAtIndex(index); */","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"链表","slug":"practices/链表","permalink":"https://cs0522.github.io/categories/practices/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"链表","slug":"链表","permalink":"https://cs0522.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【刷题日记】链表-移除链表元素-L203-Easy","slug":"p-linklist-basic-l203","date":"2024-06-11T08:41:06.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/链表/p-linklist-basic-l203/","link":"","permalink":"https://cs0522.github.io/practices/%E9%93%BE%E8%A1%A8/p-linklist-basic-l203/","excerpt":"给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。","text":"给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 思路 学习点 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; // 处理下一个元素，这样避免特殊处理最后一个元素 while (head != nullptr &amp;&amp; head-&gt;val == val) &#123; head = head-&gt;next; &#125; if (head == nullptr) &#123; return head; &#125; // 此时 head 元素不为 val // pointer ListNode* p = head; while (p-&gt;next != nullptr) &#123; // 移除元素 if (p-&gt;next-&gt;val == val) &#123; auto temp = p-&gt;next; // 链接下下个元素 p-&gt;next = p-&gt;next-&gt;next; // 释放下个元素 delete temp; &#125; else &#123; p = p-&gt;next; &#125; &#125; return head; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"链表","slug":"practices/链表","permalink":"https://cs0522.github.io/categories/practices/%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"链表","slug":"链表","permalink":"https://cs0522.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【刷题日记】数组-螺旋矩阵II-L59-Medium","slug":"p-array-spiralMatrix-l59","date":"2024-06-10T12:40:12.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/数组-螺旋矩阵/p-array-spiralMatrix-l59/","link":"","permalink":"https://cs0522.github.io/practices/%E6%95%B0%E7%BB%84-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/p-array-spiralMatrix-l59/","excerpt":"给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。","text":"给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 思路 直接模拟过程，顺时针方向。用二维数组 directions 保存顺时针方向，当超过范围或遇到访问过元素时，改变方向 学习点 directions[0]、[1]、[2]、[3] 分别表示 4 个方向，二维分别为 row 和 col 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; // directions // 顺时针方向 // 一维为某个方向，二维为 row 和 col int directions[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;; // 最大的数 int max_num = n * n; // results vector&lt;vector&lt;int&gt;&gt; spiral_metrix(n, vector&lt;int&gt;(n, 0)); // 当前的数 int curr_num = 1; int row = 0, col = 0; // 当前的方向 int curr_direct = 0; // 按数填充 while (curr_num &lt;= max_num) &#123; spiral_metrix[row][col] = curr_num; ++curr_num; // 计算下一个要填充的数的 row 和 col int next_row = row + directions[curr_direct][0]; int next_col = col + directions[curr_direct][1]; // 当超出范围或者碰到已经访问过的，则改变方向 if (next_row &gt;= n || next_col &gt;= n || next_row &lt; 0 || next_col &lt; 0 || spiral_metrix[next_row][next_col] != 0) &#123; // change direction curr_direct = (curr_direct + 1) % 4; &#125; // 重新计算 next_row = row + directions[curr_direct][0]; next_col = col + directions[curr_direct][1]; row = next_row; col = next_col; &#125; return spiral_metrix; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"数组 - 螺旋矩阵","slug":"practices/数组-螺旋矩阵","permalink":"https://cs0522.github.io/categories/practices/%E6%95%B0%E7%BB%84-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"数组","slug":"数组","permalink":"https://cs0522.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"螺旋矩阵","slug":"螺旋矩阵","permalink":"https://cs0522.github.io/tags/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"}]},{"title":"【刷题日记】数组-水果成篮-L904-Medium","slug":"p-array-moveWindow-l904","date":"2024-06-10T07:30:02.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/数组-滑动窗口/p-array-moveWindow-l904/","link":"","permalink":"https://cs0522.github.io/practices/%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/p-array-moveWindow-l904/","excerpt":"你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果。","text":"你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。 你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果。 904. 水果成篮 思路 采用滑动窗口。考虑：窗口内是啥？什么时候移动 start？什么时候移动end？ 刚开始不成熟的想法是，end 初始指向 start 后一个，然后依次遍历；窗口内是目标元素；当 count &gt; 2，移动 start。想法与正解差不多，但问题出在 start 该向右移动多少元素的地方。我的想法就是简单的当 start != start + 1，（即当满足这个条件后 count 就减少 1）再移动一次后停止了，这样会导致移动的位置过少，譬如：[3,3,3,1,2,1,1,2,3,3,4]，问题体现在当 end 指向 fruits[8] = 3 时，通过我的想法 start 只会前进到 fruits[4] = 2 上进而停止了。正确的位置应该是 fruits[7] = 2 上。所以正确的停止条件是当 unordered_map 中记录的键值对减少为 2 后，才停止 学习点 用哈希表 unordered_map 记录键值对(ele, count) unordered_map 与 map 相比不需要排序 unordered_map 的增删改查： 123456789101112131415161718192021222324 //插入votes[&quot;小明&quot;]++; //直接添加（值为int类型时才这么用）votes[&quot;李华&quot;]++; //当不存在该key时，会自动添加该新项votes[&quot;小明&quot;]++; //当已经存在该key时，则直接对value进行自增pair&lt;string, int&gt; vote1(&quot;小方&quot;, 4); //新建单个pairvotes.insert(vote1); //插入创建的pairvotes.emplace(&quot;陈一&quot;, 7); //效果同insert，但是votes.insert(&quot;陈一&quot;, 7)会报错votes.insert(make_pair&lt;string, int&gt;(&quot;张三&quot;, 3)); //查找 auto vote3 = votes.find(&quot;王五&quot;); if (vote3 == votes.end()) //等于end表示没有找到该key cout &lt;&lt; &quot;没找到&quot; &lt;&lt; endl;else cout &lt;&lt; &quot;找到 &quot; &lt;&lt; vote3-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; vote3-&gt;second &lt;&lt; endl; //删除 votes.erase(&quot;张三&quot;); //通过key删除votes.erase(votes.begin()); //通过位置删除votes.erase(vote3); //通过迭代器删除，这里，vote3即上面查找的王五 //修改 votes[&quot;刘二&quot;] = 3; //修改方式1votes.at(&quot;李四&quot;) = 6; //修改方式2 代码 错误答案： 我的错误想法 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public: int totalFruit(vector&lt;int&gt;&amp; fruits) &#123; int n = fruits.size(); int start = 0, end = start + 1; int maxLen = 1; // 记录窗口内不同种类的个数 int count = 1; // 记录窗口内是否存在该种类 vector&lt;bool&gt; exist(n, false); exist[fruits[start]] = true; while (end &lt; n &amp;&amp; start &lt; end) &#123; if (fruits[end] != fruits[end - 1]) &#123; // 如果end指向的元素不存在 if (!exist[fruits[end]]) &#123; count++; exist[fruits[end]] = true; &#125; // 新加这个种类后种类大于2 /** * 这里有问题 */ // start前进 while (count &gt; 2) &#123; if (fruits[start] != fruits[start + 1]) &#123; count--; exist[fruits[start]] = false; &#125; start++; &#125; &#125; maxLen = max(maxLen, end - start + 1); end++; &#125; return maxLen; &#125;&#125;; 正确答案： 1234567891011121314151617181920212223242526272829303132// 滑动窗口class Solution &#123;public: int totalFruit(vector&lt;int&gt;&amp; fruits) &#123; int n = fruits.size(); // 对应种类和出现次数 unordered_map&lt;int, int&gt; count; int start = 0; int maxLen = 0; for (int end = 0; end &lt; n; ++end) &#123; // 加入当前键值 ++count[fruits[end]]; // 当种类超过2 while (count.size() &gt; 2) &#123; // 迭代器取得fruits中最左边的数 // 删除这个元素，start指针对应前进 auto it = count.find(fruits[start]); --it-&gt;second; if (it-&gt;second == 0) &#123; count.erase(it); &#125; ++start; &#125; maxLen = max(maxLen, end - start + 1); &#125; return maxLen; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"数组 - 滑动窗口","slug":"practices/数组-滑动窗口","permalink":"https://cs0522.github.io/categories/practices/%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"数组","slug":"数组","permalink":"https://cs0522.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://cs0522.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"【刷题日记】数组-长度最小的子数组-L209-Medium","slug":"p-array-moveWindow-l209","date":"2024-06-10T04:09:55.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/数组-滑动窗口/p-array-moveWindow-l209/","link":"","permalink":"https://cs0522.github.io/practices/%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/p-array-moveWindow-l209/","excerpt":"给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。","text":"给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 思路 双指针，一个起点，一个末点，不必要的遍历次数较多 滑动窗口，当不满足条件时，end前进，扩大窗口；当满足条件后，start前进，缩小窗口，找到最小长度 学习点 第一次考虑滑动窗口的时候，思路是窗口长度定长，每次循环根据窗口长度，这样复杂度较高 动态长度的滑动窗口，满足条件后缩小窗口长度，减少很多遍历次数 原理就是，当满足条件后，以 start 开头的满足条件的子数组最小的必是这个数组，因此可以不需要比较之后的以 start 开头的子数组，所以移动 start 指针 实现滑动窗口，主要确定如下三点： 窗口内是什么？ 如何移动窗口的起始位置？ 如何移动窗口的结束位置？ 代码 123456789101112131415161718192021222324252627// 暴力解法class Solution &#123;public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int minLen = n; bool found = false; // 快慢指针 for (int slow = 0; slow &lt; n; slow++) &#123; int currSum = 0; for (int fast = slow; fast &lt; n; fast++) &#123; currSum += nums[fast]; // 找到了 if (currSum &gt;= target) &#123; found = true; if (minLen &gt; (fast - slow + 1)) minLen = fast - slow + 1; &#125; &#125; &#125; return (found ? minLen : 0); &#125;&#125;; update：滑动窗口 12345678910111213141516171819202122232425262728293031323334// 滑动窗口class Solution &#123;public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123; // move window int n = nums.size(); int minLen = n; int start = 0; int end = 0; int sum = 0; bool found = false; while (end &lt; n &amp;&amp; start &lt;= end) &#123; sum += nums[end]; // 不满足条件，end前进 if (sum &lt; target) &#123; end++; &#125; // 满足条件，start前进，为了找到最小长度 else &#123; found = true; // 若更小，update minLen if ((end - start + 1) &lt; minLen) minLen = end - start + 1; sum -= nums[start] + nums[end]; start++; &#125; &#125; return (found ? minLen : 0); &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"数组 - 滑动窗口","slug":"practices/数组-滑动窗口","permalink":"https://cs0522.github.io/categories/practices/%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"数组","slug":"数组","permalink":"https://cs0522.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://cs0522.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"【刷题日记】数组-有序数组的平方-L977-Easy","slug":"p-array-doubleP-l977","date":"2024-06-09T14:22:50.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/数组-双指针/p-array-doubleP-l977/","link":"","permalink":"https://cs0522.github.io/practices/%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/p-array-doubleP-l977/","excerpt":"给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。","text":"给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 思路 左右指针 注意非递减排序条件，存在负数，那么可能中间存在 0，他的左边从左到右为递减，他的右边从右到左为递减，可以采用左右指针，类似于归并的思路进行排序 学习点 左右指针 注意边界条件！！ 代码 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123; // **非递减顺序** int len = nums.size(); vector&lt;int&gt; res(len); // 左右指针 int left = 0; int right = len - 1; int pos = len - 1; // left &lt;= right，这样才是写入了 5 次数据 // 如果是 left &lt; right， // 这时候循环内最后加入的数只能是 left 或者 right // 有一个还没有被处理 for (; left &lt;= right; ) &#123; int left_square = nums[left] * nums[left]; int right_square = nums[right] * nums[right]; if (left_square &gt; right_square) &#123; res[pos] = left_square; left++; &#125; else &#123; res[pos] = right_square; right--; &#125; pos--; &#125; return res; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"数组 - 双指针","slug":"practices/数组-双指针","permalink":"https://cs0522.github.io/categories/practices/%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"数组","slug":"数组","permalink":"https://cs0522.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"双指针","slug":"双指针","permalink":"https://cs0522.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"【刷题日记】数组-比较含退格的字符串-L844-Easy","slug":"p-array-doubleP-l844","date":"2024-06-09T13:14:28.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/数组-双指针/p-array-doubleP-l844/","link":"","permalink":"https://cs0522.github.io/practices/%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/p-array-doubleP-l844/","excerpt":"给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true。# 代表退格字符。","text":"给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true。# 代表退格字符。 844. 比较含退格的字符串 思路 栈。时间空间复杂度较高 快慢指针。分别处理 学习点 在原始 s 和 t 上进行修改，只需要额外的 O(1) 空间复杂度和 O(2*n) 时间复杂度。快指针查找，慢指针写入 代码 栈 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 栈class Solution &#123;public: bool backspaceCompare(string s, string t) &#123; string s_res = &quot;&quot;; string t_res = &quot;&quot;; stack&lt;char&gt; ss; stack&lt;char&gt; ts; for (int i = 0; i &lt; s.size(); i++) &#123; if (s[i] != &#x27;#&#x27;) &#123; ss.push(s[i]); &#125; else &#123; if (!ss.empty()) ss.pop(); &#125; &#125; while (!ss.empty()) &#123; s_res += ss.top(); ss.pop(); &#125; // reverse(s_res.begin(), s_res.end()); for (int i = 0; i &lt; t.size(); i++) &#123; if (t[i] != &#x27;#&#x27;) &#123; ts.push(t[i]); &#125; else &#123; if (!ts.empty()) ts.pop(); &#125; &#125; while (!ts.empty()) &#123; t_res += ts.top(); ts.pop(); &#125; // reverse(t_res.begin(), t_res.end()); return (s_res == t_res); &#125;&#125;; 快慢指针 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 快慢指针class Solution &#123;public: bool backspaceCompare(string s, string t) &#123; // 快慢指针 int s_slow = 0; for (int fast = 0; fast &lt; s.size(); ++fast) &#123; // not &#x27;#&#x27; if (s[fast] != &#x27;#&#x27;) s[s_slow++] = s[fast]; // is &#x27;#&#x27; else &#123; if (s_slow &gt; 0) &#123; s_slow--; &#125; &#125; &#125; // 新 s 长度为 s_slow int t_slow = 0; for (int fast = 0; fast &lt; t.size(); ++fast) &#123; // not &#x27;#&#x27; if (t[fast] != &#x27;#&#x27;) t[t_slow++] = t[fast]; // is &#x27;#&#x27; else &#123; if (t_slow &gt; 0) &#123; t_slow--; &#125; &#125; &#125; // 新 t 长度为 t_slow // length is not equal if (s_slow != t_slow) return false; // length is equal else &#123; for (int i = 0; i &lt; s_slow; i++) &#123; // 存在一个不一样 if (s[i] != t[i]) return false; &#125; return true; &#125; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"数组 - 双指针","slug":"practices/数组-双指针","permalink":"https://cs0522.github.io/categories/practices/%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"数组","slug":"数组","permalink":"https://cs0522.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"双指针","slug":"双指针","permalink":"https://cs0522.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"【刷题日记】记录题型思路","slug":"p-note","date":"2024-06-09T13:06:05.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/p-note/","link":"","permalink":"https://cs0522.github.io/practices/p-note/","excerpt":"记录下遇到的题型，可以首先往哪个方向去考虑。","text":"记录下遇到的题型，可以首先往哪个方向去考虑。 数组 二分查找 【刷题日记】数组-二分查找-L704-Easy 【刷题日记】数组-在排序数组中查找元素的第一个和最后一个位置-L34-Medium 【刷题日记】数组-x的平方根-L69-Easy 循环边界条件 通过区间来判定： [left, right]: while(left &lt;= right), left = mid + 1, right = mid - 1 [left, right): while(left &lt; right), left = mid + 1, right = mid (left, right): while (left &lt; right - 1), left = mid, right = mid 双指针 【刷题日记】数组-删除有序数组中的重复项-L29-Easy 【刷题日记】数组-移除元素-L27-Easy 【刷题日记】数组-移动零-L283-Easy 【刷题日记】数组-比较含退格的字符串-L844-Easy 【刷题日记】数组-有序数组的平方-L977-Easy 快慢指针 快指针：用于遍历，查找元素 慢指针：用于写入，更新元素。题目一般需要在这一步进行不一样的处理 左右指针 注意从两边向中间指针移动的时候，最后的边界条件。可以看在最后一次处理的时候，数组的所有元素是否都已经处理完毕 滑动窗口 【刷题日记】数组-长度最小的子数组-L209-Medium 【刷题日记】数组-水果成篮-L904-Medium 与指针有点类似。窗口长度固定或者不固定。看作一个区间，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。 实现滑动窗口，主要确定如下三点： * 窗口内是什么？ * 如何移动窗口的起始位置？ * 如何移动窗口的结束位置？ 螺旋矩阵 【刷题日记】数组-螺旋矩阵II-L59-Medium 直接模拟，注意循环条件，找到循环时同一的操作。 链表 创建虚拟头节点 【刷题日记】链表-设计链表-L707-Medium 【刷题日记】链表-删除链表的倒数第N个节点-L19-Medium 【刷题日记】链表-两两交换链表中的节点-L24-Medium 在操作当前节点必须要找前一个节点才能操作的情况时，就会导致遇到头节点的时候，需要进行特殊的处理。 因此，对头节点前加入虚拟节点后，可以使得头节点和其他的节点进行统一的处理，不需要单独进行处理。 新建节点并移动指针 【刷题日记】链表-反转链表-L206-Easy ans = new ListNode(x.val, ans)，当前指向节点A（或 null），构建新节点 B，其 next 指针指向节点 A（或 null），同时指针指向新节点 B。 栈存储指针 【刷题日记】链表-删除链表的倒数第N个节点-L19-Medium 【刷题日记】链表-反转链表-L206-Easy 栈存在先进后出的特性，如果需要倒着数链表，可以尝试使用栈。 哈希表 unordered_set 存储指针 【刷题日记】链表-链表相交-L160-Easy 【刷题日记】链表-环形链表II-L142-Medium 哈希表存储已出现过的指针，用 count(p) 函数找出已出现过的元素。 哈希表 需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法！！ target - x 【刷题日记】哈希表-两数之和-L1-Easy 【刷题日记】哈希表-四数相加II-L454-Medium 与正常查找 x + y = target 不同，先用哈希表存储已经出现过的元素；然后再遍历数组，查找当前元素 x 的 target - x。 字符串匹配 KMP 算法 见到一次就背一次，多背。 栈与队列 用栈的情况 先进后出，后进先出 如果操作数据的方向与原始数据遍历的方向相反，考虑用栈 用队列的情况 先进先出，后进后出 队列的模板用法： 123456789qe.push(a);while (!qe.empty())&#123; auto tmp = qe.front(); qe.pop(); // 处理 // ... qe.push(...);&#125; 递归 递归三要素： 确定递归函数的参数和返回值：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。 确定终止条件：写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。 确定单层递归的逻辑：确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。 二叉树 二叉树的深度遍历 使用（栈）递归法，或者迭代法。递归法更简单。 二叉树的广度（层序）遍历 使用队列，模板： 12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) &#123; int size = que.size(); vector&lt;int&gt; vec; // 这里一定要使用固定大小 size，不要使用 que.size()，因为 que.size 是不断变化的 for (int i = 0; i &lt; size; i++) &#123; TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; result.push_back(vec); &#125; return result; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"}]},{"title":"【刷题日记】数组-移动零-L283-Easy","slug":"p-array-doubleP-l283","date":"2024-06-09T09:27:10.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/数组-双指针/p-array-doubleP-l283/","link":"","permalink":"https://cs0522.github.io/practices/%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/p-array-doubleP-l283/","excerpt":"给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意，必须在不复制数组的情况下原地对数组进行操作。","text":"给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意，必须在不复制数组的情况下原地对数组进行操作。 283. 移动零 思路 局部左右指针，实际上存在很多不必要的交换和比较，复杂度为O(n^2) update：快慢指针 慢指针指向当前已经处理好的序列的尾部，快指针指向待处理序列的头部 慢指针写入，快指针查找 当快指针所指元素不为 0，交换快慢指针元素（交换是因为慢指针指的元素可能不为 0） 学习点 快慢指针 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); // 局部左右指针 int left = 0; while (left &lt; len) &#123; // left != 0 // left 指针前进 if (nums[left] != 0) &#123; left++; &#125; // left == 0 // right 指针从 left + 1 开始查找， // 找到第一个不为 0 的元素，并交换 else &#123; int right = left + 1; while (right &lt; len) &#123; if (nums[right] == 0) &#123; right++; &#125; else &#123; // 找到第一个不为 0 的元素 break; &#125; &#125; if (right &gt;= len) &#123; // 一直到结束都是 0，所有比较已完毕 break; &#125; // 交换 nums[left++] = nums[right]; nums[right] = 0; &#125; &#125; &#125;&#125;; update：快慢指针 12345678910111213141516171819class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); // 快慢指针 int slow = 0; int fast = 0; while (fast &lt; len) &#123; // 右边不是 0，交换 if (nums[fast] != 0) &#123; swap(nums[slow], nums[fast]); slow++; &#125; fast++; &#125; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"数组 - 双指针","slug":"practices/数组-双指针","permalink":"https://cs0522.github.io/categories/practices/%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"数组","slug":"数组","permalink":"https://cs0522.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"双指针","slug":"双指针","permalink":"https://cs0522.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"【刷题日记】数组-删除有序数组中的重复项-L29-Easy","slug":"p-array-doubleP-l26","date":"2024-06-09T04:35:11.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/数组-双指针/p-array-doubleP-l26/","link":"","permalink":"https://cs0522.github.io/practices/%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/p-array-doubleP-l26/","excerpt":"给你一个 非严格递增排列 的数组 nums，请你原地删除重复出现的元素，使每个元素 只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。然后返回 nums 中唯一元素的个数。","text":"给你一个 非严格递增排列 的数组 nums，请你原地删除重复出现的元素，使每个元素 只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。然后返回 nums 中唯一元素的个数。 思路 采用 27 题类似的思路快慢指针，并存储上一个比较的元素。如果和上一个相同，则 fast 指针前进，slow 指针不动 因为本题是非严格递增序列，可以采用如此思路。如果不是非严格递增、递减序列，该思路不可行 学习点 快慢指针 代码 123456789101112131415161718192021class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; // 快慢指针 int slow = 1; // 存储上一个比较元素 int temp = nums[0]; for (int fast = 1; fast &lt; nums.size();fast++) &#123; // 非重复元素 if (nums[fast] != temp) &#123; nums[slow++] = nums[fast]; temp = nums[fast]; &#125; // 重复元素 // fast 指针前进 &#125; return slow; &#125;&#125;; update: 官方解法 思路一致，优化在不需要 temp 额外存储 123456789101112131415class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int index = 1; int len = nums.size(); for(int i = 1; i &lt; len; i++) &#123; if(nums[i] != nums[i - 1]) &#123; nums[index++] = nums[i]; &#125; &#125; return index; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"数组 - 双指针","slug":"practices/数组-双指针","permalink":"https://cs0522.github.io/categories/practices/%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"数组","slug":"数组","permalink":"https://cs0522.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"双指针","slug":"双指针","permalink":"https://cs0522.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"【刷题日记】数组-移除元素-L27-Easy","slug":"p-array-doubleP-l27","date":"2024-06-09T03:17:18.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/数组-双指针/p-array-doubleP-l27/","link":"","permalink":"https://cs0522.github.io/practices/%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/p-array-doubleP-l27/","excerpt":"给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。","text":"给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。 思路 使用左右双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列 update: 快慢指针 通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作 快指针：寻找新数组的元素，新数组就是不含有目标元素的数组 慢指针：指向更新 新数组下标的位置 学习点 右指针 right 初始为 nums.size() - 1，但此时 right 并没有被遍历（被处理），因此完全遍历 nums 数组的条件为 left &lt;= right，此时 left 指针会处理 right 可能会存在 nums[right] == val，因此在赋值前找到合适的 right 位置，减少赋值操作 update: 快慢指针 slow 指针用于写入，fast 指针用于查找 当 val == fast，慢指针不动，快指针前进；当 val != fast，快慢指针同时前进 代码 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; // val 是要删除的元素 // 左右指针 int left = 0; int right = nums.size() - 1; while (left &lt;= right) &#123; if (nums[left] == val) &#123; // 可能会存在 nums[right] == val while (nums[right] == val) &#123; right--; if (right &lt; left) &#123; return left; &#125; &#125; // 查找 right 合适位置 nums[left] = nums[right]; right--; &#125; else &#123; left++; &#125; &#125; return left; &#125;&#125;; update: 快慢指针 1234567891011121314151617181920212223class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; // val 是要删除的元素 // 快慢指针 // slow 用于写入 // fast 用于查找 int slow = 0; int fast = 0; for (; fast &lt; nums.size(); fast++) &#123; // 当 val != fast，慢指针写入快指针数值 // 快慢指针同时前进 if (nums[fast] != val) &#123; nums[slow++] = nums[fast]; &#125; // 当 al == fast，慢指针不写入 // 慢指针不动，快指针前进 &#125; return slow; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"数组 - 双指针","slug":"practices/数组-双指针","permalink":"https://cs0522.github.io/categories/practices/%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"数组","slug":"数组","permalink":"https://cs0522.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"双指针","slug":"双指针","permalink":"https://cs0522.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"【论文随记】HNSW 论文 + hnswlib 代码浅读","slug":"l-hnsw","date":"2024-05-16T12:17:11.000Z","updated":"2025-01-17T18:57:47.089Z","comments":false,"path":"learnings/ANN/l-hnsw/","link":"","permalink":"https://cs0522.github.io/learnings/ANN/l-hnsw/","excerpt":"文章主要是记录 HNSW 原理以及 Search 过程代码的学习。","text":"文章主要是记录 HNSW 原理以及 Search 过程代码的学习。 论文浅读 目前已有较详细的解析，附上参考链接： 大白话理解 HNSW 【论文笔记】HNSW（Hierarchical Navigable Small World graphs） 近似最近邻算法 HNSW 学习笔记（二） 主要算法伪代码分析 Search 过程代码 从 hnswlib 库中截取部分代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143// hnswlib/hnswalg.h// KNN 搜索函数/** * 目前来看，这里与伪代码中不太一致 * 伪代码中将每次搜索 layer 单独写成一个函数 * 实现中没有单独写成一个函数，仅写了一个 search base layer 函数 * 实现中通过取消 check deletions 和忽略 stop conditions 提高性能*/std::priority_queue&lt;std::pair&lt;dist_t, labeltype &gt;&gt;searchKnn(const void *query_data, size_t k, BaseFilterFunctor* isIdAllowed = nullptr) const &#123; std::priority_queue&lt;std::pair&lt;dist_t, labeltype &gt;&gt; result; if (cur_element_count == 0) return result; // currObj: 进入 base layer 的 enterpoint tableint currObj = enterpoint_node_; dist_t curdist = fstdistfunc_(query_data, getDataByInternalId(enterpoint_node_),dist_func_param_); // 与 pseudo code 中从最高层遍历至倒数第二层的逻辑一致 for (int level = maxlevel_; level &gt; 0; level--) &#123; bool changed = true; while (changed) &#123; changed = false; unsigned int *data; // 获取了当前 level 的数据 data = (unsigned int *) get_linklist(currObj, level); int size = getListCount(data); metric_hops++; metric_distance_computations+=size; tableint *datal = (tableint *) (data + 1); // 比较当前 level 的点 for (int i = 0; i &lt; size; i++) &#123; tableint cand = datal[i]; if (cand &lt; 0 || cand &gt; max_elements_) throw std::runtime_error(&quot;cand error&quot;); dist_t d = fstdistfunc_(query_data, getDataByInternalId(cand), dist_func_param_); // 如果当前层（非 base layer）存在更近的点 // 改变 currObj，继续遍历当前层 /** 没搞懂：changed = true 后，while 继续循环，这一层重新遍历一遍？ */ if (d &lt; curdist) &#123; curdist = d; currObj = cand; changed = true; &#125; &#125; &#125; &#125; std::priority_queue&lt;std::pair&lt;dist_t, tableint&gt;, std::vector&lt;std::pair&lt;dist_t,tableint&gt;&gt;, CompareByFirst&gt; top_candidates; bool bare_bone_search = !num_deleted_ &amp;&amp; !isIdAllowed; if (bare_bone_search) &#123; // 搜索底层函数 top_candidates = searchBaseLayerST&lt;true&gt;( currObj, query_data, std::max(ef_, k), isIdAllowed); &#125; else &#123; top_candidates = searchBaseLayerST&lt;false&gt;( currObj, query_data, std::max(ef_, k), isIdAllowed); &#125; while (top_candidates.size() &gt; k) &#123; top_candidates.pop(); &#125; while (top_candidates.size() &gt; 0) &#123; std::pair&lt;dist_t, tableint&gt; rez = top_candidates.top(); result.push(std::pair&lt;dist_t, labeltype&gt;(rez.first, getExternalLabel(rez.second))); top_candidates.pop(); &#125; return result;&#125;// 搜索底层函数// bare_bone_search means there is no check for deletions and stop condition is ignoredin return of extra performancetemplate &lt;bool bare_bone_search = true, bool collect_metrics = false&gt;std::priority_queue&lt;std::pair&lt;dist_t, tableint&gt;, std::vector&lt;std::pair&lt;dist_t,tableint&gt;&gt;, CompareByFirst&gt;searchBaseLayerST( tableint ep_id, const void *data_point, size_t ef, BaseFilterFunctor* isIdAllowed = nullptr, BaseSearchStopCondition&lt;dist_t&gt;* stop_condition = nullptr) const &#123; VisitedList *vl = visited_list_pool_-&gt;getFreeVisitedList(); vl_type *visited_array = vl-&gt;mass; vl_type visited_array_tag = vl-&gt;curV; std::priority_queue&lt;std::pair&lt;dist_t, tableint&gt;, std::vector&lt;std::pair&lt;dist_t,tableint&gt;&gt;, CompareByFirst&gt; top_candidates; std::priority_queue&lt;std::pair&lt;dist_t, tableint&gt;, std::vector&lt;std::pair&lt;dist_t,tableint&gt;&gt;, CompareByFirst&gt; candidate_set; dist_t lowerBound; if (bare_bone_search || (!isMarkedDeleted(ep_id) &amp;&amp; ((!isIdAllowed) || (*isIdAllowed)(getExternalLabel(ep_id))))) &#123; char* ep_data = getDataByInternalId(ep_id); dist_t dist = fstdistfunc_(data_point, ep_data, dist_func_param_); lowerBound = dist; top_candidates.emplace(dist, ep_id); if (!bare_bone_search &amp;&amp; stop_condition) &#123; stop_condition-&gt;add_point_to_result(getExternalLabel(ep_id), ep_data, dist); &#125; candidate_set.emplace(-dist, ep_id); &#125; else &#123; lowerBound = std::numeric_limits&lt;dist_t&gt;::max(); candidate_set.emplace(-lowerBound, ep_id); &#125; visited_array[ep_id] = visited_array_tag; while (!candidate_set.empty()) &#123; std::pair&lt;dist_t, tableint&gt; current_node_pair = candidate_set.top(); dist_t candidate_dist = -current_node_pair.first; bool flag_stop_search; if (bare_bone_search) &#123; flag_stop_search = candidate_dist &gt; lowerBound; &#125; else &#123; if (stop_condition) &#123; flag_stop_search = stop_condition-&gt;should_stop_search(candidate_dist, lowerBound); &#125; else &#123; flag_stop_search = candidate_dist &gt; lowerBound &amp;&amp; top_candidates.size() == ef; &#125; &#125; if (flag_stop_search) &#123; break; &#125; candidate_set.pop(); tableint current_node_id = current_node_pair.second; int *data = (int *) get_linklist0(current_node_id); size_t size = getListCount((linklistsizeint*)data); // bool cur_node_deleted = isMarkedDeleted(current_node_id); if (collect_metrics) &#123; metric_hops++; metric_distance_computations+=size; &#125; // 未完... &#125;&#125;","categories":[{"name":"论文随记","slug":"learnings","permalink":"https://cs0522.github.io/categories/learnings/"},{"name":"ANN","slug":"learnings/ANN","permalink":"https://cs0522.github.io/categories/learnings/ANN/"}],"tags":[{"name":"论文","slug":"论文","permalink":"https://cs0522.github.io/tags/%E8%AE%BA%E6%96%87/"},{"name":"HNSW","slug":"HNSW","permalink":"https://cs0522.github.io/tags/HNSW/"},{"name":"ANN","slug":"ANN","permalink":"https://cs0522.github.io/tags/ANN/"}]},{"title":"【学习笔记】Linux C++ 性能分析","slug":"n-performance-stats","date":"2024-05-09T09:15:54.000Z","updated":"2025-01-17T18:57:47.133Z","comments":false,"path":"notes/C/n-performance-stats/","link":"","permalink":"https://cs0522.github.io/notes/C/n-performance-stats/","excerpt":"C++ 项目需要统计性能指标，学习并使用性能分析工具。","text":"C++ 项目需要统计性能指标，学习并使用性能分析工具。 Valgrind Valgrind 是一种开源工具套件，旨在帮助开发人员调试、分析和优化程序的内存使用和执行性能。Valgrind 包括多个工具：Memcheck、Cachegrind、Callgrind、Helgrind、DRD、Massif 等。这些工具可用于检测内存泄漏、越界读写、未初始化变量、线程竞争、函数调用关系、缓存使用情况、内存使用情况等问题。这些问题通常是程序崩溃或性能下降的主要原因。Valgrind 的主要优点是它可以帮助开发人员快速找到并解决程序中的内存和性能问题。它是开发和测试过程中的有用工具，特别是对于大型和复杂的代码库。缺点是 Valgrind 会降低程序的性能，因此不建议在生产环境中使用它。 Valgrind 工具集包含以下几个主要工具： Memcheck: 用于检测内存泄漏、内存错误等问题。 Cachegrind: 用于检测程序中的缓存命中率、分支预测错误等问题。 Callgrind: 用于生成函数调用图和性能分析报告。 Helgrind: 用于检测多线程程序中的竞争条件、死锁等问题。 DRD: 用于检测多线程程序中的并发错误。 Massif: 用于检测程序中的内存使用情况。 Valgrind 命令 Valgrind Docs 1valgrind [valgrind-options] your-prog [your-prog-options] valgrind-options: * --tool=: choose which tool to use, like --tool=challvalgrind --trace-children=&lt;yes|no&gt;: 跟踪到子进程里去，默认请况不跟踪 --log-file=filename: 将输出的信息写入到 filename.PID 的文件里 --log-file-exactly=filename: 指定就输出到 filename 文件 --separate-threads=yes: 多线程 Callgrind 使用 cpp 源文件 1// test_wadg_search.cpp 编译 编译时加上 -g 参数，方便显示行数，如： 1g++ -O0 -g -std=c++11 -lpthread test_wadg_search.cpp -o test_wadg_search 本项目中是 CMake，如： 1set(CMAKE_CXX_FLAGS_DEBUG &quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -O0 -g&quot;) 运行 callgrind 1valgrind --tool=callgrind --separate-threads=yes ./build/tests/test_wadg_search ./dataset/sift/sift_base.fvecs ./dataset/sift/sift_query.fvecs ./nsg_graph/sift.nsg 200 200 ./search_result/sift_200nn.ivecs 得到 callgrind.out.PID 文件。 callgrind_annotate 分析文件 使用 callgrind_annotate 获取 callgrind 生成的输出文件，并以易于阅读的形式打印信息。 1callgrind_annotate [options] &lt;callgrind.out.PID&gt; options 可以包括： --tree=both: 显示调用树的入口和出口视图。 --inclusive=yes: 显示包括调用子函数在内的总时间。 --threshold=&lt;percentage&gt;: 只显示占总时间超过某个百分比的函数。 想要一个包含子函数时间的更详细的报告，可以运行： 1callgrind_annotate --tree=both --inclusive=yes &lt;callgrind.out.PID&gt; kcachegrind 分析文件 本人 Ubuntu 22.04 电脑上运行存在问题，“打开”不显示文件。 使用 gprof2dot 可视化 安装 gprof2dot &amp; graphviz： 1234conda create -n &quot;gprof2dot-env&quot; python==3.7conda activate &quot;gprof2dot-env&quot;pip install gprof2dotpip install graphviz 转化为 png 图片： 123456789# 一定注意是原始的 callgrind.out.* 文件# 转化为 dot 脚本gprof2dot -f callgrind callgrind.out.PID &gt; callgrind.dot# 输出为 pngdot -Tpng callgrind.dot -o callgrind.png# 可以简写prof2dot -f callgrind callgrind.out.PID | dot -Tpng -o callgrind.png gprof Gprof 是 Linux 下一个强有力的程序分析工具。它能够以“日志”的形式记录程序运行时的统计信息：程序运行中各个函数消耗的时间和函数调用关系，以及每个函数被调用的次数等等。 gprof 缺陷 只能分析应用程序在运行过程中所消耗掉的用户时间，无法得到程序内核空间的运行时间，如 sleep() gprof 不支持多线程应用，多线程下只能采集主线程性能数据。原因是 gprof 采用 ITIMER_PROF 信号，在多线程内只有主线程才能响应该信号。但是有一个简单的方法可以解决这一问题：http://sam.zoy.org/writings/programming/gprof.html gprof 使用 cpp 源文件 1// test_wadg_search.cpp 编译 编译时，加上 -pg 参数，如： 1g++ -O0 -pg -std=c++11 -lpthread test_wadg_search.cpp -o test_wadg_search 本项目中是 CMake，如： 1set(CMAKE_CXX_FLAGS_DEBUG &quot;$&#123;CMAKE_CXX_FLAGS_DEBUG&#125; -O0 -pg&quot;) 运行程序 1test_wadg_search [args] 运行后在当前工作目录下产生 gmon.out 文件。 运行 gprof 将生成的 gmon.out 文件输出为可读的文本文件。 1gprof ./build/tests/test_wadg_search ./anals/gmon.out &gt; gprof.profile gprof 报告说明 %time Cumulative seconds Self seconds Calls Self TS/call Total TS/call name 该函数消耗时间占程序所有时间百分比 程序的累积执行时间（只是包括gprof能够监控到的函数） 该函数本身执行时间（所有被调用次数的合共时间） 函数被调用次数 函数平均执行时间（不包括被调用时间）（函数的单次执行时间） 函数平均执行时间（包括被调用时间）（函数的单次执行时间） 函数名 Call Graph 字段含义： Index %time Self Children Called Name 索引值 函数消耗时间占所有时间百分比 函数本身执行时间 执行子函数所用时间 被调用次数 函数名 使用 gprof2dot 可视化 安装 gprof2dot &amp; graphviz： 1234conda create -n &quot;gprof2dot-env&quot; python==3.7conda activate &quot;gprof2dot-env&quot;pip install gprof2dotpip install graphviz 转化为 png 图片： 123456789# 一定注意是生成后的 utf-8 文本文件，不是原来的 gmon.out 文件# 转化为 dot 脚本gprof2dot gprof.profile &gt; gprof.dot# 输出为 pngdot -Tpng gprof.dot -o gprof.png# 可以简写prof2dot gprof.profile | dot -Tpng -o gprof.png strace strace 使用 12345strace -f -o output.log &lt;program&gt; [args]strace -f -o test_nndescent_bm.log ./build/tests/test_nndescent_bm /home/frank/Workspace/Test/big_memory/dataset/bigann_learn_small.bvecs ./knn_graph/bigann_learn_small.graph 200 200 20 20 100strace -f -o test_nndescent_bm.log -e trace=memory &lt;program&gt; gdb gdb 使用 1234567gdb [--args] &lt;program&gt; [args]# 编译时开启 -g 参数，或者 -DCMAKE_BUILD_TYPE=Debuggdb --args build/tests/test_nndescent_bm ../WADG_ANN/dataset/bigann/bigann_learn.bvecs ./knn_graph/bigann_learn.graph 200 200 20 20 100(gdb)run(gdb)bt","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"C++","slug":"notes/C","permalink":"https://cs0522.github.io/categories/notes/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"https://cs0522.github.io/tags/Linux/"}]},{"title":"【文档小记】记录 VSCode + CMake 多可执行文件配置","slug":"d-ubuntu-vscode-cmake","date":"2024-05-06T04:24:38.000Z","updated":"2025-01-17T18:57:47.089Z","comments":false,"path":"docs/d-ubuntu-vscode-cmake/","link":"","permalink":"https://cs0522.github.io/docs/d-ubuntu-vscode-cmake/","excerpt":"记录 Ubuntu 下配置 VSCode + CMake 过程，存在多个可执行文件。","text":"记录 Ubuntu 下配置 VSCode + CMake 过程，存在多个可执行文件。 前期准备 Ubuntu 22.04 VSCode 1.83 g++ 11.4 cmake 3.22.1 VSCode Extension C/C++ 1.19.9 CMake 0.0.17 不安装 CMake Tools CMake 项目，其中包含多个可执行文件，存在 CMake 嵌套 CMake 项目 目录结构 12345678910111213141516171819202122232425262728.├── CMakeLists.txt├── include│ └── efanna2e│ ├── distance.h│ ├── dkm.hpp│ ├── dkm.hpp.bak│ ├── exceptions.h│ ├── index.h│ ├── index_nsg.h│ ├── index_wadg.h│ ├── lru_cache.h│ ├── neighbor.h│ ├── parameters.h│ └── util.h├── src│ ├── CMakeLists.txt│ ├── index.cpp│ ├── index_nsg.cpp│ ├── index_wadg.cpp│ ├── lru_cache.cpp├── tests│ ├── CMakeLists.txt│ ├── test_cal_top_K_precision.cpp│ ├── test_nsg_index.cpp│ ├── test_nsg_optimized_search.cpp│ ├── test_nsg_search.cpp│ └── test_wadg_search.cpp 存在 CMake 的多级嵌套，其中 ./tests 文件夹中的源文件都存在 main 函数，需要分别编译为可执行文件。 编译命令 123mkdir build &amp;&amp; cd buildcmake -DCMAKE_BUILD_TYPE=Release ..make -j 执行命令 12345test_wadg_search ../../dataset/sift/sift_base.fvecs ../../dataset/sift/sift_query.fvecs ../../nsg_graph/sift.nsg 200 200 ../../search_result/sift_200nn.ivecstest_nsg_search ../../dataset/sift/sift_base.fvecs ../../dataset/sift/sift_query.fvecs ../../nsg_graph/sift.nsg 200 200 ../../search_result/sift_200nn.ivecstest_cal_top_K_precision ../../search_result/sift_200nn.ivecs ../../dataset/sift/sift_groundtruth.ivecs 100 VSCode 配置 编译可以使用 CMake Tools 插件，但是这样的话 launch.json 和 tasks.json 不起作用，所以打算手动配置。 加入头文件路径 配置 c_cpp_properties.json 文件。 123456789101112131415161718// .vscode/c_cpp_properties.json&#123; &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ &quot;$&#123;workspaceFolder&#125;/**&quot;, // 加入项目中的头文件 &quot;$&#123;workspaceFolder&#125;/include&quot; ], &quot;defines&quot;: [], &quot;cStandard&quot;: &quot;c17&quot;, &quot;cppStandard&quot;: &quot;gnu++17&quot;, &quot;intelliSenseMode&quot;: &quot;linux-gcc-x64&quot; &#125; ], &quot;version&quot;: 4&#125; 编译 配置 tasks.json 文件，自定义任务，使用CMake 编译命令编译程序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445// .vscode/tasks.json&#123; &quot;version&quot;: &quot;2.0.0&quot;, &quot;options&quot;: &#123; // 指定工作目录 &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;/build&quot; &#125;, &quot;tasks&quot;: [ // 任务 1 &#123; &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;cmake&quot;, // 命令 &quot;command&quot;: &quot;cmake&quot;, // 参数 &quot;args&quot;: [ // Release, Debug &quot;-DCMAKE_BUILD_TYPE=Debug&quot;, &quot;..&quot; ] &#125;, // 任务 2 &#123; &quot;label&quot;: &quot;make&quot;, &quot;group&quot;: &#123; &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true &#125;, // 命令 &quot;command&quot;: &quot;make&quot;, // 参数 &quot;args&quot;: [ &quot;-j&quot; ] &#125;, &#123; &quot;label&quot;: &quot;Build&quot;, // 依赖于上面两个 task 命令 &quot;dependsOn&quot;: [ // 与 label 一致 &quot;cmake&quot;, &quot;make&quot; ] &#125; ]&#125; 运行调试 配置 launch.json 文件，读取可执行文件。需要进行修改地方的是指定运行的文件，其次我们还可以在里面添加 build 任务，用于调试，添加命令行参数执行程序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ // 配置 1，运行可执行文件 1 &#123; // name 可自定义 &quot;name&quot;: &quot;test_wadg_search&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, // 需要运行的可执行文件 &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/tests/test_wadg_search&quot;, // 需要输入的命令行参数 &quot;args&quot;: [ // data_file &quot;./dataset/sift/sift_base.fvecs&quot;, // query_file &quot;./dataset/sift/sift_query.fvecs&quot;, // nsg_path &quot;./nsg_graph/sift.nsg&quot;, // search_L &quot;200&quot;, // search_K &quot;200&quot;, // result_path &quot;./search_result/sift_200nn.ivecs&quot; ], &quot;stopAtEntry&quot;: false, // 指定工作目录。如果参数包含文件路径，需要注意相对路径 &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], // 终端 &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;preLaunchTask&quot;: &quot;Build&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125;, &#123; &quot;description&quot;: &quot;将反汇编风格设置为 Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true &#125; ] &#125;, // 配置 2，运行可执行文件 2 &#123; &quot;name&quot;: &quot;test_nsg_search&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/tests/test_nsg_search&quot;, &quot;args&quot;: [ // data_file &quot;./dataset/sift/sift_base.fvecs&quot;, // query_file &quot;./dataset/sift/sift_query.fvecs&quot;, // nsg_path &quot;./nsg_graph/sift.nsg&quot;, // search_L &quot;200&quot;, // search_K &quot;200&quot;, // result_path &quot;./search_result/sift_200nn.ivecs&quot; ], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;preLaunchTask&quot;: &quot;Build&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125;, &#123; &quot;description&quot;: &quot;将反汇编风格设置为 Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true &#125; ] &#125;, // 配置 3，运行可执行文件 3 &#123; &quot;name&quot;: &quot;test_cal_top_K_precision&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/build/tests/test_cal_top_K_precision&quot;, &quot;args&quot;: [ &quot;./search_result/sift_200nn.ivecs&quot;, &quot;./dataset/sift/sift_groundtruth.ivecs&quot;, &quot;100&quot; ], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;preLaunchTask&quot;: &quot;Build&quot;, &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125;, &#123; &quot;description&quot;: &quot;将反汇编风格设置为 Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true &#125; ] &#125; ]&#125; 运行选择右上角的图标，选择相应的可执行文件配置运行即可。","categories":[{"name":"文档小记","slug":"docs","permalink":"https://cs0522.github.io/categories/docs/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://cs0522.github.io/tags/Ubuntu/"},{"name":"VSCode","slug":"VSCode","permalink":"https://cs0522.github.io/tags/VSCode/"},{"name":"CMake","slug":"CMake","permalink":"https://cs0522.github.io/tags/CMake/"}]},{"title":"【刷题日记】数组-在排序数组中查找元素的第一个和最后一个位置-L34-Medium","slug":"p-array-erfen-l34","date":"2024-04-25T12:52:53.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/数组-二分查找/p-array-erfen-l34/","link":"","permalink":"https://cs0522.github.io/practices/%E6%95%B0%E7%BB%84-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/p-array-erfen-l34/","excerpt":"给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。","text":"给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 思路 执行 2 次二分查找，第一次查找第一个位置，第二次查找第二个位置 第一次查找 first，mid 找到后，往左区间继续查找直到找到第一个位置 first，注意与普通二分查找不同的是找到后 while 循环也不结束，直到 left &gt; right 第二次查找 last 同理，往右区间查找 学习点 注意二分查找的 while 循环边界条件： * 之前解答中为 while (left &lt; right - 1)，因为在循环中 left = mid, right = mid，而 mid 已经验证过不等于 target 这里为 while (left &lt;= right)，因为在循环中 left = mid + 1, right = mid - 1，left 和 right 没有验证是否等于 target，所以在最后一次循环 left = right 时，验证 mid(=left=right) 位置是否等于 target 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; // empty if (nums.size() == 0) &#123; return vector&lt;int&gt; &#123;-1, -1&#125;; &#125; vector&lt;int&gt; res(2); int left = 0; int right = nums.size() - 1; // 提前赋值 int first = -1; int last = -1; // 分两次查找 // 查找第一个 while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; first = mid; // 往左边找，找到第一个位置 right = mid - 1; &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; // 查找第二个 left = 0; right = nums.size() - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; last = mid; // 往右边找，找到最后一个位置 left = mid + 1; &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; res[0] = first; res[1] = last; return res; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"数组 - 二分查找","slug":"practices/数组-二分查找","permalink":"https://cs0522.github.io/categories/practices/%E6%95%B0%E7%BB%84-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"数组","slug":"数组","permalink":"https://cs0522.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"二分查找","slug":"二分查找","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"【刷题日记】数组-x的平方根-L69-Easy","slug":"p-array-erfen-l69","date":"2024-04-25T12:42:46.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/数组-二分查找/p-array-erfen-l69/","link":"","permalink":"https://cs0522.github.io/practices/%E6%95%B0%E7%BB%84-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/p-array-erfen-l69/","excerpt":"给你一个非负整数 x，计算并返回 x 的算术平方根。由于返回类型是整数，结果只保留整数部分，小数部分将被舍去。","text":"给你一个非负整数 x，计算并返回 x 的算术平方根。由于返回类型是整数，结果只保留整数部分，小数部分将被舍去。 思路 官方解答思路： * 只要mid &lt;= x/mid，left左边界就会一直向右移动，ans 就会一直更新（变大），直到不在满足 mid &lt;= x/mid 的条件为止，ans 就会停止更新，永远停在满足 mid&lt;=x/mid 条件下面的最后一次更新，即满足 ans * ans &lt;= mid 的最大值 * 为什么要加上=的判断条件，因为将左指针和右指针相同的时候，就是判断指针本身和目标值是否相等。每当这里想不清楚的时候，就拿最简单的例子：1，2，3来做推理。要想知道3在不在他们中间，先比较3和2，然后3比2大，left = mid + 1 = 3，right = right = 3；这时候left 和 right相等，他们的中间也就是3,3=3，于是3在他们中间，如果left &lt; right 就返回，就会返回错误的答案。 代码 1234567891011121314151617181920212223class Solution &#123;public: int mySqrt(int x) &#123; int low = 0; int high = x; int ans = -1; while (low &lt;= high) &#123; long mid = (low + high) / 2; long mid_square = mid * mid; if (mid_square &lt;= x) &#123; ans = mid; low = mid + 1; &#125; else &#123; high = mid - 1; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"数组 - 二分查找","slug":"practices/数组-二分查找","permalink":"https://cs0522.github.io/categories/practices/%E6%95%B0%E7%BB%84-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"数组","slug":"数组","permalink":"https://cs0522.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"二分查找","slug":"二分查找","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"【刷题日记】数组-二分查找-L704-Easy","slug":"p-array-erfen-l704","date":"2024-04-25T11:58:50.000Z","updated":"2025-01-17T18:57:47.137Z","comments":false,"path":"practices/数组-二分查找/p-array-erfen-l704/","link":"","permalink":"https://cs0522.github.io/practices/%E6%95%B0%E7%BB%84-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/p-array-erfen-l704/","excerpt":"开始刷题了。从基础开始重新学，记录一下重新学习的知识点以及做题的思路。跟着《代码随想录》学习。 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。","text":"开始刷题了。从基础开始重新学，记录一下重新学习的知识点以及做题的思路。跟着《代码随想录》学习。 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 704. 二分查找 思路 nums 中无重复元素且有序，可以二分查找，结果唯一 当 left &lt; right - 1 的时候循环，每次取 mid = (left + right) / 2 的值记为中点 mid &lt; target，则 target 在右边；否则在左边 结束条件为 left == right - 1，此时 left 和 right 紧挨着，这说明仍没有找到 target，因为如果找到了，while 中就 return 了 学习点 循环边界条件 通过区间来判定。 [left, right]: while(left &lt;= right), left = mid + 1, right = mid - 1 [left, right): while(left &lt; right), left = mid + 1, right = mid (left, right): while (left &lt; right - 1), left = mid, right = mid 代码 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0; int right = nums.size() - 1; // left bound if (nums[left] == target) &#123; return left; &#125; // right bound if (nums[right] == target) &#123; return right; &#125; // binary search while (left &lt; right - 1) &#123; int mid = (left + right) / 2; if (nums[mid] &lt; target) &#123; left = mid; &#125; else if (nums[mid] &gt; target) &#123; right = mid; &#125; else &#123; return mid; &#125; &#125; // not found return -1; &#125;&#125;;","categories":[{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"数组 - 二分查找","slug":"practices/数组-二分查找","permalink":"https://cs0522.github.io/categories/practices/%E6%95%B0%E7%BB%84-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"数组","slug":"数组","permalink":"https://cs0522.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"二分查找","slug":"二分查找","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"【学习笔记】记录 Python 中使用过的有用代码","slug":"d-python-used-codes","date":"2024-04-02T16:55:17.000Z","updated":"2025-01-24T08:36:07.965Z","comments":false,"path":"notes/d-python-used-codes/","link":"","permalink":"https://cs0522.github.io/notes/d-python-used-codes/","excerpt":"记录 Python 中使用过的有用代码，以后应该还用的上。","text":"记录 Python 中使用过的有用代码，以后应该还用的上。 平滑对比曲线图 1234567891011121314151617181920212223242526272829303132333435363738394041424344import matplotlib.pyplot as plt# 平滑曲线图from scipy.interpolate import make_interp_splineimport numpy as npdef comparison_line_chart(self): x1 = [0.1, 0.2, 0.5, 0.6, 0.8, 0.9] x2 = [0.2, 0.3, 0.4, 0.7, 0.8, 0.9, 1] y1 = [1, 3, 4, 5, 7, 9] y2 = [2, 4, 5, 6, 7, 8, 9] # list 转换为 array # 需要 min()，max() 函数 x1_array = np.array(x1) x2_array = np.array(x2) y1_array = np.array(y1) y2_array = np.array(y2) # 平滑 x1_smooth = np.linspace(x1_array.min(), x1_array.max(), 300) x2_smooth = np.linspace(x2_array.min(), x2_array.max(), 300) y1_smooth = make_interp_spline(x1_array, y1_array)(x1_smooth) y2_smooth = make_interp_spline(x2_array, y2_array)(x2_smooth) # 子绘图 1 # subplot(rows, cols, index) # 绘图一行两个 # plt.subplot(1, 2, 1) # 设置字体 plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;Times New Roman&#x27;] # x轴标题 plt.xlabel(&#x27;index&#x27;) plt.xlim(0, 1) # y轴标题 plt.ylabel(&#x27;search time&#x27;) # 绘制平滑曲线图，添加数据点，设置点的大小 plt.plot(x1_smooth, y1_smooth, label = &#x27;NSG&#x27;) plt.plot(x2_smooth, y2_smooth, label = &#x27;WADG&#x27;) # 曲线上打点 plt.scatter(x1_array, y1_array) plt.scatter(x2_array, y2_array) # 设置曲线名称 plt.legend([&#x27;NSG&#x27;, &#x27;WADG&#x27;],) plt.grid(linestyle = &#x27;--&#x27;, alpha = 0.5) plt.title(&#x27;SIFT Search Time Comparision&#x27;) plt.show() 对比柱状图 1234567891011121314151617181920212223def comparision_histogram(self): base = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;] x1 = [5, 10, 20] x2 = [6, 8, 15] # 设置字体 plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;Times New Roman&#x27;] # 绘制柱状图 # x轴标题 # plt.xlabel(&#x27;SIFT&#x27;) # y轴标题 plt.ylabel(&#x27;Avg Search Time&#x27;) base_ticks = range(len(base)) plt.bar(base_ticks, x1, width = 0.1, label = &#x27;NSG&#x27;) plt.bar([i + 0.1 for i in base_ticks], x2, width = 0.1, label = &#x27;WADG&#x27;) # 修改 base 刻度 plt.xticks(base_ticks, base) # 添加网格显示 plt.grid(linestyle = &#x27;--&#x27;, alpha = 0.5) #5、标题 plt.title(&quot;SIFT Average Search Time Comparision&quot;) plt.show() 设置图例位置 1plt.legend(loc = &#x27;upper right&#x27;) plot 全局设定 12plt.rcParams[&#x27;figure.dpi&#x27;] = 300plt.rcParams[&#x27;figure.figsize&#x27;] = (8, 6) 转换 array: reshape() 12345678910import numpy as np# 转换为 1 行df.reshape(1, -1)# 转换为 2 行df.reshape(2, -1)# 转换为 1 列df.reshape(-1, 1)# 转换为 2 列df.reshape(-1, 2) 计算向量距离: pairwise_distances() 123456789101112131415161718192021222324252627from sklearn.metrics import pairwise_distances# dist 得到的是 X, Y array 中的每对向量的距离# dist 也是一个 arraydist = pairwise_distances(X, Y, metric = &#x27;euclidean&#x27;)# sum(dist) 得到的是 X，Y 的距离Dist = np.sum(dist)# exampleX = np.array([[2, 3], [3, 5], [5, 8]])Y = np.array([[1, 0], [2, 1]])dist = pairwise_distances(X, Y, metric = &#x27;euclidean&#x27;)print(dist)Dist = np.sum(dist)print(Dist)# output[[3.16227766 2. ] [5.38516481 4.12310563] [8.94427191 7.61577311]]31.230593108783612 计算向量距离: cdist(), pdist() 在 scripy.spatial.distance 库下。 cdist() 用于两个数组（矩阵）之间，pdist() 用于一个数组中。 cdist(): X = m * n, Y = a * n, res = cdist(X, Y) = m * a 可以看作是 X 为 m 个 n 维向量，Y 为 a 个 n 维向量， cdist() 求 X 中每个向量到 Y 中每个向量的距离，可以用来计算分离度。 123456789101112131415X=np.array([[9,3,7],[5,7,9]]) # 即便是 X 中只有一组数据跟 Y 的两组数据分别求欧氏距离，# 也需要写成二维数组的形式，如 X=np.array([[5,3,6]])Y = np.array([[4,6,5],[4,2,3]])res = cdist(X, Y, metric=&#x27;euclidean&#x27;)print(res)# output[[a b] [c d]]# a 为向量 [9, 3, 7] 到 [4, 6, 5] 的距离# b 为向量 [9, 3, 7] 到 [4, 2, 3] 的距离# c 为向量 [5, 7, 9] 到 [4, 6, 5] 的距离# d 为向量 [5, 7, 9] 到 [4, 2, 3] 的距离 pdist() and squareform(): X = m * n, res = pdist(X) = m * m, 其中 res 为对称距离矩阵，对角线元素为 0。 pdist() 可以看作是求 X 中 m 个 n 维向量之间的距离，可以用来计算内聚度。 squareform() 和 pdist() 配套使用，用来压缩矩阵（或者还原矩阵）。 12345678910111213141516x = np.array([[ 0, 2, 3, 4], [ 2, 0, 7, 8], [ 3, 7, 0, 12], [ 4, 8, 12, 0]])y = dist.squareform(x)print(y)# output[ 2, 3, 4, 7, 8, 12]x = dist.squareform(y)print(x)# output[[ 0, 2, 3, 4], [ 2, 0, 7, 8], [ 3, 7, 0, 12], [ 4, 8, 12, 0]] 从列表或 array 中随机采样: random.choice() 12345678910111213141516171819202122232425262728293031323334353637383940414243import numpy as np&#x27;&#x27;&#x27;base = [[x1, x2, ..., xn] [y1, y2, ..., yn] ... [z1, z2, ..., zn]]&#x27;&#x27;&#x27;# shape[0]: base 第一维的长度，多少行# choice(选择的数字范围, 结果的个数，是否有放回抽取)choices = np.random.choice(base.shape[0], size = len(queries), replace = False)# choices 是长度为 size 列表，里面是抽取的数字（即抽取第几行）# base[choices, :]: 抽取行数在 choices 中的行base_random_sample = base[choices, :]# exampleimport numpy as npA = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 7, 6], [3, 2, 2], [0, 1, 0], [1, 3, 1], [0, 4, 1], [2, 4, 2], [3, 6, 1]])print(A.shape)choices = np.random.choice(A.shape[0], size = 4, replace = False)print(&#x27;choices:&#x27;, choices)B = A[choices, :]print(B)# output(10, 3)choices: [3 6 4 9][[9 7 6] [1 3 1] [3 2 2] [3 6 1]] 从 array 中选取特定行 1234567891011121314151617181920212223242526import numpy as npfrom sklearn.cluster import KMeansqueries = np.array([[1, 2, 3, 3], [2, 2, 4, 5], [3, 4, 5, 2], [2, 3, 6, 7], [5, 6, 4, 3], [1, 1, 2, 1]])kmeans = KMeans(n_clusters = 3)kmeans.fit(queries)cluster_centers = kmeans.cluster_centers_labels = kmeans.labels_print(labels)# labels 下标与 queries 行下标对应i = 2# 选取 label 为 2 的 queryres = queries[labels == i]print(res)# output[0 2 1 2 1 0][[2 2 4 5] [2 3 6 7]] 去重: unique() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import numpy as npA = [1, 2, 2, 5, 3, 4, 3]a = np.unique(A)print(a)# output[1 2 3 4 5]# 返回新列表元素在旧列表中的位置（下标）a, indices = np.unique(A, return_index=True)print(a) # 列表print(indices) # 下标# output[1 2 3 4 5][0 1 4 5 3]# 旧列表的元素在新列表的位置a, indices = np.unique(A, return_inverse=True) print(a)print(indices)print(a[indices]) # 使用下标重构原数组# output[1 2 3 4 5][0 1 1 4 2 3 2][1 2 2 5 3 4 3]# 每个元素在旧列表里各自出现了几次a, indices = np.unique(A, return_counts=True) print(a)print(indices)# output[1 2 3 4 5][1 2 2 1 1]# 向量去重B = np.array([1, 2, 3, 4] [1, 2, 3, 4] [2, 3, 4, 6])b = np.unique(B, axis = 0)# output[[1, 2, 3, 4] [2, 3, 4, 6]] 可遍历对象组合为索引序列: enurmerate() 12345678seasons = [&#x27;Spring&#x27;, &#x27;Summer&#x27;, &#x27;Fall&#x27;, &#x27;Winter&#x27;]list(enumerate(seasons))# output[(0, &#x27;Spring&#x27;), (1, &#x27;Summer&#x27;), (2, &#x27;Fall&#x27;), (3, &#x27;Winter&#x27;)]list(enumerate(seasons, start=1)) # 下标从 1 开始# output[(1, &#x27;Spring&#x27;), (2, &#x27;Summer&#x27;), (3, &#x27;Fall&#x27;), (4, &#x27;Winter&#x27;)] numpy 初始化生成相同元素值的数组 使用 numpy.full() 函数 12345678910111213print(np.full(3, 100, dtype = np.int32))# [100 100 100]print(np.full(3, np.pi))# [ 3.14159265 3.14159265 3.14159265]print(np.full((2, 3), 100))# [[100 100 100]# [100 100 100]]print(np.full((2, 3), np.pi))# [[ 3.14159265 3.14159265 3.14159265]# [ 3.14159265 3.14159265 3.14159265]] numpy 数组添加一列/一行 使用 numpy.insert() 函数 1234567891011121314151617import numpy as npa = np.array([[1,2,3],[4,5,6],[7,8,9]]) b = np.array([2,5,8])# 2代表下标，这里代表插入到第三列，axis=1，插入一列，axis=0，插入一行print(np.insert(a, 2, b, axis=1))#插入多列c = np.array([[1,4,7],[2,5,8]]).Tprint(np.insert(a, [0,1], c, axis=1)) 输出：[[1 2 2 3] [4 5 5 6] [7 8 8 9]] [[1 1 2 2 3] [4 4 5 5 6] [7 7 8 8 9]]","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://cs0522.github.io/tags/Python/"}]},{"title":"【学习笔记】DiskSim 学习（五）：RAID 磁盘数据分布策略","slug":"n-disksim-05","date":"2023-11-10T00:17:11.000Z","updated":"2025-01-17T18:57:47.125Z","comments":false,"path":"notes/DiskSim/n-disksim-05/","link":"","permalink":"https://cs0522.github.io/notes/DiskSim/n-disksim-05/","excerpt":"DiskSim 的 RAID 磁盘数据分布策略的参数设置以及源码修改","text":"DiskSim 的 RAID 磁盘数据分布策略的参数设置以及源码修改 原论文中 Disk Array Data Organizations 部分 因为磁盘阵列 Data Organizations 可以用于多个组件（例如，设备驱动程序和智能存储控制器）， 逻辑地址映射被实现为单独的模块（logorg 模块），并通过适当与其他组件联合。 由 data distribution scheme 和 redundancy mechanism 构成的 logorg 模块支持大多数逻辑数据组织。 logorg 模块将一个新到达的 logical request 转换为合适的一组 physical accesses（以 components 的视角）（如使用了 disk striping 和/或基于副本的冗余）， 并返回其中的子集。 一个 logorg 模块的实例可以由多个 parameters 配置，parameters 介绍参考后两节。 Manual 中 Disk Array Data Organizations 部分 DiskSim 可以模拟各种 logical organization，包括 striping 和各种 RAID 体系结构。尽管 DiskSim 被组织为允许在系统级别（即，在设备驱动程序的前端）和控制器级别进行这样的组织，但在 version1.0 中仅支持系统级别的组织。每个 logical organization 都配置在一个 logorg 模块中。 参数含义： Addressing mode 指定了 logical data organization 的寻址方式。 Array：整个 logical organization 只有一个逻辑设备编号 Parts：后端存储设备的寻址方式就像没有逻辑组织一样，并且请求被适当地重新映射 Distribution scheme 指定了数据分发方案（与冗余方案正交：可以单独使用，或者组合使用）。 Asis：没有重新映射 Striped：数据在磁盘上分条 Random：为每个请求选择一个随机磁盘。 N.B.：只能与用于负载平衡实验的 constant access-time 磁盘一起使用 Ideal：理想化的数据分布（从负载平衡的角度来看）应该通过以循环方式向磁盘分配请求来模拟 最后两种方案没有对实际数据布局进行建模。特别是，对同一块的两个请求通常会发送到不同的设备。这些数据分布方案对于研究各种负载平衡技术非常有用。 Redundancy scheme 指定了冗余方案（与数据分发方案正交）。 Noredun：不采用冗余 Shadowed：维护每个数据磁盘的一个或多个副本 Parity disk：其中一个物理磁盘包含根据其他磁盘的内容计算的奇偶校验信息 Parity rotated：一个磁盘容量大小（分布在所有磁盘上），专用于保存奇偶校验信息，以保护 N 磁盘组织中其他 N-1 个磁盘的信息 Stripe unit 指定条带单元的大小。0 表示细粒度条带化（例如，位或字节条带化），其中逻辑组织中的所有数据磁盘包含每个可寻址数据单元的相等部分。 Parity stripe unit 指定用于奇偶校验旋转冗余方案的条带单元大小。对于其他方案，此参数将被忽略。奇偶校验条带单元大小不必等于条带单元的大小，但其中一个必须是另一个的倍数。 Parity rotation type 指定如何在逻辑组织的磁盘之间轮换奇偶校验。4 个选项：1 - 左对称、2 - 左不对称、3 - 右不对称、4 - 右对称。除非选择了奇偶校验旋转冗余，否则此参数将被忽略。 parv 参数文件中 RAID 参数 synthraid5.parv 123456789101112131415161718192021222324252627282930313233343536disksim_syncset sync0 &#123; devices = [ disk0 .. disk8 ] &#125;# Disk Array Data Organizations（磁盘阵列逻辑数据组织形式）# 每一种逻辑结构都可以在 logory 块中配置# RAID-5disksim_logorg org0 &#123; # 逻辑数据组织的编址方式（值为：Array（编成一个统一逻辑设备）或 Parts） Addressing mode = Array, # 数据分布策略，体现负载均衡能力（值为：Striped，Random，N.B. 或 Ideal） Distribution scheme = Striped, # 冗余方案（值为：Noredun，Shadowed，Parity_disk 或 Parity_rotated） Redundancy scheme = Parity_rotated, # 当前逻辑组织中包含的设备名称列表 devices = [ disk0 .. disk8 ], # stripe 单元的大小 Stripe unit = 64, Synch writes for safety = 0, # 每个数据磁盘的备份数（仅当 Redundancy scheme = shadowed 时才有效） Number of copies = 2, # 哪个副本负责响应（仅当 Redundancy scheme = shadowed 时才有效） Copy choice on read = 6, RMW vs. reconstruct = 0.5, # stripe 单元的大小（仅当 Redundancy scheme = Parity_rotated 时才有效） Parity stripe unit = 64, # parity 在磁盘中旋转的方式（仅当 Redundancy scheme = Parity_rotated 时才有效） Parity rotation type = 1, # time stamps 之间的间隔 Time stamp interval = 0.000000, # 第一个 time stamp 的模拟时间（相对于模拟开始的时间） Time stamp start time = 60000.000000, # 最后一个 time stamp 的模拟时间（相对于模拟开始的时间） Time stamp stop time = 10000000000.000000, Time stamp file name = stamps&#125; # end of logorg org0 spec DiskSim src 源码部分 四个文件： disksim_logorg_param.h：加载 logorg 模块参数的头文件 disksim_logorg_param.c：加载 logorg 模块参数的源文件 disksim_logorg.h：定义各种结构体和函数 disksim_logorg.c：logorg 模块的实现 设置参数流程 以 Distribution Scheme 参数为例： disksim_logorg_param.h: extern void * DISKSIM_LOGORG_loaders[] disksim_logorg_param.c: void * DISKSIM_LOGORG_loaders[] = {.. (void *)DISKSIM_LOGORG_DISTRIBUTION_SCHEME_loader, ..} disksim_logorg_param.c: static void DISKSIM_LOGORG_DISTRIBUTION_SCHEME_loader(struct logorg * result, char *s) disksim_logorg.c: int logorg_distn(logorg result, char s) 以 Distribution Scheme 参数为例 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 1. disksim_logorg_param.h: 34extern void * DISKSIM_LOGORG_loaders[];// 2. disksim_logorg_param.c: 172void * DISKSIM_LOGORG_loaders[] = &#123;...,(void *)DISKSIM_LOGORG_DISTRIBUTION_SCHEME_loader,...&#125;// 3. disksim_logorg_param.c: 18static void DISKSIM_LOGORG_DISTRIBUTION_SCHEME_loader(struct logorg * result, char *s) &#123; if (! (!logorg_distn(result, s))) &#123; // foo &#125; &#125;// 4. disksim_logorg.c: 1529int logorg_distn(logorg *result, char *s) &#123; if(!strcmp(s, &quot;Asis&quot;)) &#123; result-&gt;maptype = ASIS; &#125; else if(!strcmp(s, &quot;Striped&quot;)) &#123; result-&gt;maptype = STRIPED; &#125; else if(!strcmp(s, &quot;Random&quot;)) &#123; fprintf(stderr, &quot;*** warning: Random logorg distribution is only &quot; &quot;to be used with constant access-time disks &quot; &quot;for load-balancing experiments \\n&quot;); result-&gt;maptype = RANDOM; &#125; else if(!strcmp(s, &quot;Ideal&quot;)) &#123; result-&gt;maptype = IDEAL; &#125; else &#123; fprintf(stderr, &quot;*** error: %s is not a valid argument for logorg addressing mode\\n&quot;, s); return -1; &#125; return 0;&#125; 开始运行到发请求至 RAID 流程 初始化流程： disksim_main.c: disksim_setup_disksim(argc, argv); disksim.c: initialize(); disksim.c: io_initialize(val); disksim_iosim.c: iodriver_initialize(standalone); disksim_iodriver.c: logorg_initialize(...); disksim_logorg.c: 1104: logorg_initialize(...) 声明 RAID 请求重新映射流程： disksim_main.c: disksim_run_simulation(); disksim.c: disksim_simulate_event(event_count); disksim.c: io_internal_event(ioreq_event *curr); disksim_iosim.c: iodriver_request(0, curr); disksim_iodriver.c: logorg_maprequest(sysorgs, numsysorgs, curr); disksim_logorg.c:695: logorg_maprequest(...) 声明 disksim_logorg.h 主要关注与 Distribution Scheme 和 Redundancy 有关的代码。 很多宏定义（用整型来表示参数的各个值）和预定义的结构体。主要是 logorgstat 和 logorg 结构体。 logorgstat 包含 RAID 的状态，logorg 包含 RAID 各种参数设置。 logorgstat 结构体 1234567891011121314151617181920212223242526272829303132333435typedef struct &#123; double outtime; double runouttime; int outstanding; int readoutstanding; int maxoutstanding; double nonzeroouttime; int reads; int gens[NUMGENS]; int seqdiskswitches; int locdiskswitches; int numlocal; int critreads; int critwrites; int seqreads; int seqwrites; int distavgdiff[10]; int distmaxdiff[10]; double idlestart; double lastarr; double lastread; double lastwrite; int *blocked; int *aligned; int *lastreq; int *intdist; statgen resptimestats; statgen idlestats; statgen sizestats; statgen readsizestats; statgen writesizestats; statgen intarrstats; statgen readintarrstats; statgen writeintarrstats;&#125; logorgstat; logorg 结构体 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051typedef struct logorg &#123; char *name; outstand * hashoutstand[HASH_OUTSTAND]; int outstandqlen; int opid; int addrbyparts; // distribution scheme int maptype; // redundancy int reduntype; int numdisks; int actualnumdisks; int arraydisk; int writesync; int copies; int copychoice; double rmwpoint; int parityunit; int rottype; int blksperpart; int actualblksperpart; int stripeunit; int sectionunit; int tablestripes; tableentry *table; int tablesize; int partsperstripe; int idealno; int reduntoggle; int lastdiskaccessed; int numfull; int *sizes; int *redunsizes; int printlocalitystats; int printblockingstats; int printinterferestats; int printidlestats; int printintarrstats; int printstreakstats; int printstampstats; int printsizestats; double stampinterval; double stampstart; double stampstop; FILE * stampfile; logorgdev *devs; logorgstat stat; /* rcohen&#x27;s additions */ int startdev; int enddev;&#125; logorg; 以及其他一些相关函数的声明。 disksim_logorg.c 主要关注与 Distribution Scheme 和 Redundancy 有关的代码。 logorg_maprequest() 函数 1","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"DiskSim","slug":"notes/DiskSim","permalink":"https://cs0522.github.io/categories/notes/DiskSim/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cs0522.github.io/tags/Linux/"},{"name":"DiskSim","slug":"DiskSim","permalink":"https://cs0522.github.io/tags/DiskSim/"}]},{"title":"【学习笔记】DiskSim 学习（四）：参数文件","slug":"n-disksim-04","date":"2023-11-08T00:17:11.000Z","updated":"2025-01-17T18:57:47.125Z","comments":false,"path":"notes/DiskSim/n-disksim-04/","link":"","permalink":"https://cs0522.github.io/notes/DiskSim/n-disksim-04/","excerpt":"DiskSim 的 .parv 参数文件","text":"DiskSim 的 .parv 参数文件 DiskSim 使用 libparam 输入参数文件。在参数文件中有三种内容： blocks delimited by &#123;&#125;，块的定义 instantiations，实例化 topology specifications，拓扑结构说明 一个 block 由多个 &quot;name=value&quot; 赋值组成。名称可能包含空格，并且区分大小写。 值可以是整数（包括前缀为 0x 的十六进制）、浮点数、字符串、块和由 [] 分隔的列表。 组件不能在定义前引用。每个参数文件必须包含 Global 和 States 块， 使用合成跟踪发生器仿真还必须定义 proc 和 synthio 块 （disksim_pf { }：Process-Flow Parameters 合成负载的一些参数，disksim_synthio { }：SyntheticWorkloads 合成负载）。 在一个典型的配置中，接着还会再定义一定的总线（bus）、控制器（controller）、和输入输出驱动（iodriver）， 然后定义或引用一些存储设备的说明，之后实例化，最后模拟存储仿真的拓扑结构规范定义这些组件之间的互连。 磁盘阵列的数据组织是在 logorg 块中描述的。每一个请求都必须属于一个 logorg，所以至少有一个 logorg 块被定义。 设备的 Rotational syncrhonization 可以选择性的在 syncset 块中定义。 adjusting the time scale 和 remapping requests from a trace 可以在 iosim 块中定义。 synthraid5.parv 参数文件 主要包括以下几个部分： Global block Stats block 具体设备参数设定 device drivers buses controllers storage devices 实例化 拓扑结构 RAID 磁盘阵列 设置 workload Global block 12345678910disksim_global Global &#123; # 每次模拟开始时会由 randomnumber generator 产生一个 initial seed，决定系统 configuration。# 若希望实验可还原，可使用相同的 Init SeedInit Seed = 42,# 决定系统的 workload 的初始随机数，# 当保持 Init Seed 不变而改变 Real Seed 时，可得到相同系统 configuration 下不同 workload 的实验结果 Real Seed = 42,# Statistic warm-up period = 0.0 seconds,Stat definition file = statdefs&#125; Stats block 包含五个子块：iodriver、bus、ctlr、device、process flow，参数全由 0 或 1 表示。 1 和 0 分别表示这些参数是否需要 print 到输出文件中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748disksim_stats Stats &#123;iodriver stats = disksim_iodriver_stats &#123; Print driver size stats = 1, Print driver locality stats = 1, Print driver blocking stats = 1, Print driver interference stats = 1, Print driver queue stats = 1, Print driver crit stats = 1, Print driver idle stats = 1, Print driver intarr stats = 1, Print driver streak stats = 1, Print driver stamp stats = 1, Print driver per-device stats = 1 &#125;,bus stats = disksim_bus_stats &#123; Print bus idle stats = 1, Print bus arbwait stats = 1 &#125;,ctlr stats = disksim_ctlr_stats &#123; Print controller cache stats = 1, Print controller size stats = 1, Print controller locality stats = 1, Print controller blocking stats = 1, Print controller interference stats = 1, Print controller queue stats = 1, Print controller crit stats = 1, Print controller idle stats = 1, Print controller intarr stats = 1, Print controller streak stats = 1, Print controller stamp stats = 1, Print controller per-device stats = 1 &#125;,device stats = disksim_device_stats &#123; Print device queue stats = 1, Print device crit stats = 1, Print device idle stats = 1, Print device intarr stats = 1, Print device size stats = 1, Print device seek stats = 1, Print device latency stats = 1, Print device xfer stats = 1, Print device acctime stats = 1, Print device interfere stats = 1, Print device buffer stats = 1 &#125;,process flow stats = disksim_pf_stats &#123; Print per-process stats = 1, Print per-CPU stats = 1, Print all interrupt stats = 1, Print sleep stats = 1&#125;&#125; # end of stats block 具体设备参数设定 注：以下设备参数取自 atlas_III.parv 参数文件 12345678910111213141516171819202122232425# Device Driverdisksim_iodriver DRIVER0 &#123; type = 1, # 决定每个 request 的访问时间和队列时间是否一致，还是由下面 disk 根据自身情况自行计算 Constant access time = 0.0, Scheduler = disksim_ioqueue &#123; # Scheduling 算法，如何选择下一个将要处理的 request，1 代表“先来先服务” Scheduling policy = 1, Cylinder mapping strategy = 1, Write initiation delay = 0.0, Read initiation delay = 0.0, Sequential stream scheme = 0, Maximum concat size = 128, Overlapping request scheme = 0, Sequential stream diff maximum = 0, Scheduling timeout scheme = 0, Timeout time/weight = 6, Timeout scheduling = 4, Scheduling priority scheme = 0, Priority scheduling = 4 &#125;, # end of Scheduler # 设备驱动是否在任何时候都允许两个或者更多的请求存在存储子系统中 Use queueing in subsystem = 1&#125; # end of DRV0 spec 12345678910111213141516171819# Busesdisksim_bus BUS0 &#123; # bus 类型：1，独占式总线；2，共享式总线 type = 1, Arbitration type = 1, Arbitration time = 0.0, Read block transfer time = 0.0, Write block transfer time = 0.0, Print stats = 0&#125; # end of BUS0 specdisksim_bus BUS1 &#123; type = 1, Arbitration type = 1, Arbitration time = 0.0, Read block transfer time = 0.0, Write block transfer time = 0.0, Print stats = 1&#125; # end of BUS1 spec 12345678# controllerdisksim_ctlr CTLR0 &#123; type = 1, Scale for delays = 0.0, Bulk sector transfer time = 0.0, Maximum queue length = 0, Print stats = 1&#125; # end of CTLR0 spec 123# HP_C3323A# source 类似于预处理指令source hp_c3323a.diskspecs 实例化 实例化的语法格式：instantiate &lt;name list&gt; as &lt;instance name&gt; 12345678# component instantiationinstantiate [ statfoo ] as Statsinstantiate [ ctlr0 .. ctlr8 ] as CTLR0instantiate [ bus0 ] as BUS0instantiate [ disk0 .. disk8 ] as HP_C3323Ainstantiate [ driver0 ] as DRIVER0instantiate [ bus1 .. bus9 ] as BUS1# end of component instantiation 拓扑结构 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# system topologytopology disksim_iodriver driver0 [ disksim_bus bus0 [ disksim_ctlr ctlr0 [ disksim_bus bus1 [ disksim_disk disk0 [] # end of bus1 ] # end of ctlr0 ], disksim_ctlr ctlr1 [ disksim_bus bus2 [ disksim_disk disk1 [] # end of bus2 ] # end of ctlr1 ], disksim_ctlr ctlr2 [ disksim_bus bus3 [ disksim_disk disk2 [] # end of bus3 ] # end of ctlr2 ], disksim_ctlr ctlr3 [ disksim_bus bus4 [ disksim_disk disk3 [] # end of bus4 ] # end of ctlr3 ], disksim_ctlr ctlr4 [ disksim_bus bus5 [ disksim_disk disk4 [] # end of bus5 ] # end of ctlr4 ], disksim_ctlr ctlr5 [ disksim_bus bus6 [ disksim_disk disk5 [] # end of bus6 ] # end of ctlr5 ], disksim_ctlr ctlr6 [ disksim_bus bus7 [ disksim_disk disk6 [] # end of bus7 ] # end of ctlr6 ], disksim_ctlr ctlr7 [ disksim_bus bus8 [ disksim_disk disk7 [] # end of bus8 ] # end of ctlr7 ], disksim_ctlr ctlr8 [ disksim_bus bus9 [ disksim_disk disk8 [] # end of bus9 ] # end of ctlr8 ] # end of bus0 ] # end of system topology] RAID 磁盘阵列 1234567891011121314151617181920212223242526272829303132333435363738disksim_syncset sync0 &#123; devices = [ disk0 .. disk8 ] &#125;# 重要！！！这里应该涉及到磁盘阵列的数据分布# Disk Array Data Organizations（磁盘阵列逻辑数据组织形式）# 每一种逻辑结构都可以在 logory 块中配置# RAID-5disksim_logorg org0 &#123; # 逻辑数据组织的编址方式（值为：Array（编成一个统一逻辑设备）或 Parts） Addressing mode = Array, # 数据分布策略，体现负载均衡能力（值为：Striped，Random，N.B. 或 Ideal） Distribution scheme = Striped, # 冗余方案（值为：Noredun，Shadowed，Parity_disk 或 Parity_rotated） Redundancy scheme = Parity_rotated, # 当前逻辑组织中包含的设备名称列表 devices = [ disk0 .. disk8 ], # stripe 单元的大小 Stripe unit = 64, Synch writes for safety = 0, # 每个数据磁盘的备份数（仅当 Redundancy scheme = shadowed 时才有效） Number of copies = 2, # 哪个副本负责响应（仅当 Redundancy scheme = shadowed 时才有效） Copy choice on read = 6, RMW vs. reconstruct = 0.5, # stripe 单元的大小（仅当 Redundancy scheme = Parity_rotated 时才有效） Parity stripe unit = 64, # parity 在磁盘中旋转的方式（仅当 Redundancy scheme = Parity_rotated 时才有效） Parity rotation type = 1, # time stamps 之间的间隔 Time stamp interval = 0.000000, # 第一个 time stamp 的模拟时间（相对于模拟开始的时间） Time stamp start time = 60000.000000, # 最后一个 time stamp 的模拟时间（相对于模拟开始的时间） Time stamp stop time = 10000000000.000000, Time stamp file name = stamps&#125; # end of logorg org0 spec 设置 Workload 下面设置 workload，可有多个 generator，每个 generator 每过一段 think time 后发出一个 request， 包括 time-criticalreques（generator 需等上一个 request 完成再进入下一个 think time） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394disksim_pf Proc &#123; Number of processors = 5, Process-Flow Time Scale = 1.0&#125; # end of process flow specdisksim_synthio Synthio &#123; Number of I/O requests to generate = 10000, Maximum time of trace generated = 1000.0, System call/return with each request = 0, Think time from call to request = 0.0, Think time from request to return = 0.0, Generators = [ disksim_synthgen &#123; # generator 0 Storage capacity per device = 16448064, devices = [ org0 ], Blocking factor = 8, Probability of sequential access = 0.2, Probability of local access = 0.3, Probability of read access = 0.66, Probability of time-critical request = 0.1, Probability of time-limited request = 0.3, Time-limited think times = [ normal, 30.0, 100.0 ], General inter-arrival times = [ exponential, 0.0, 10.0 ], Sequential inter-arrival times = [ exponential, 0.0, 10.0 ], Local inter-arrival times = [ exponential, 0.0, 10.0 ], Local distances = [ normal, 0.0, 40000.0 ], Sizes = [ exponential, 0.0, 8.0 ] &#125;, # end of generator 0 disksim_synthgen &#123; # generator 0 Storage capacity per device = 16448064, devices = [ org0 ], Blocking factor = 8, Probability of sequential access = 0.2, Probability of local access = 0.3, Probability of read access = 0.66, Probability of time-critical request = 0.1, Probability of time-limited request = 0.3, Time-limited think times = [ normal, 30.0, 100.0 ], General inter-arrival times = [ exponential, 0.0, 10.0 ], Sequential inter-arrival times = [ exponential, 0.0, 10.0 ], Local inter-arrival times = [ exponential, 0.0, 10.0 ], Local distances = [ normal, 0.0, 40000.0 ], Sizes = [ exponential, 0.0, 8.0 ] &#125;, # end of generator 0 disksim_synthgen &#123; # generator 0 Storage capacity per device = 16448064, devices = [ org0 ], Blocking factor = 8, Probability of sequential access = 0.2, Probability of local access = 0.3, Probability of read access = 0.66, Probability of time-critical request = 0.1, Probability of time-limited request = 0.3, Time-limited think times = [ normal, 30.0, 100.0 ], General inter-arrival times = [ exponential, 0.0, 10.0 ], Sequential inter-arrival times = [ exponential, 0.0, 10.0 ], Local inter-arrival times = [ exponential, 0.0, 10.0 ], Local distances = [ normal, 0.0, 40000.0 ], Sizes = [ exponential, 0.0, 8.0 ] &#125;, # end of generator 0 disksim_synthgen &#123; # generator 0 Storage capacity per device = 16448064, devices = [ org0 ], Blocking factor = 8, Probability of sequential access = 0.2, Probability of local access = 0.3, Probability of read access = 0.66, Probability of time-critical request = 0.1, Probability of time-limited request = 0.3, Time-limited think times = [ normal, 30.0, 100.0 ], General inter-arrival times = [ exponential, 0.0, 10.0 ], Sequential inter-arrival times = [ exponential, 0.0, 10.0 ], Local inter-arrival times = [ exponential, 0.0, 10.0 ], Local distances = [ normal, 0.0, 40000.0 ], Sizes = [ exponential, 0.0, 8.0 ] &#125;, # end of generator 0 disksim_synthgen &#123; # generator 0 Storage capacity per device = 16448064, devices = [ org0 ], Blocking factor = 8, Probability of sequential access = 0.2, Probability of local access = 0.3, Probability of read access = 0.66, Probability of time-critical request = 0.1, Probability of time-limited request = 0.3, Time-limited think times = [ normal, 30.0, 100.0 ], General inter-arrival times = [ exponential, 0.0, 10.0 ], Sequential inter-arrival times = [ exponential, 0.0, 10.0 ], Local inter-arrival times = [ exponential, 0.0, 10.0 ], Local distances = [ normal, 0.0, 40000.0 ], Sizes = [ exponential, 0.0, 8.0 ] &#125; # end of generator 0 ] # end of generator list &#125; # end of synthetic workload spec","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"DiskSim","slug":"notes/DiskSim","permalink":"https://cs0522.github.io/categories/notes/DiskSim/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cs0522.github.io/tags/Linux/"},{"name":"DiskSim","slug":"DiskSim","permalink":"https://cs0522.github.io/tags/DiskSim/"}]},{"title":"【学习笔记】DiskSim 学习（三）：程序流程","slug":"n-disksim-03","date":"2023-11-06T07:17:11.000Z","updated":"2025-01-17T18:57:47.125Z","comments":false,"path":"notes/DiskSim/n-disksim-03/","link":"","permalink":"https://cs0522.github.io/notes/DiskSim/n-disksim-03/","excerpt":"DiskSim 的 main 函数","text":"DiskSim 的 main 函数 disksim_main.c DiskSim 的 main 函数位于 disksim-4.0/src/disksim_main.c 文件里。代码如下： 12345678910111213141516171819202122232425int main (int argc, char **argv)&#123; int len;#ifndef _WIN32 setlinebuf(stdout); setlinebuf(stderr);#endif if(argc == 2) &#123; disksim_restore_from_checkpoint (argv[1]); &#125; else &#123; // disksim.c:120 disksim = calloc(1, sizeof(struct disksim)); // 初始化结构体 disksim_initialize_disksim_structure(disksim); // 设置 disksim // disksim.c:911 disksim_setup_disksim (argc, argv); &#125; disksim_run_simulation (); disksim_cleanup_and_printstats (); exit(0);&#125; 主要分为以下几个步骤。 给全局变量 disksim 分配内存 代码中 disksim 变量没有声明而直接使用，因为他是一个全局变量，在 disksim.c:120 有其初始化的语句： 12// disksim_global.h:342disksim_t *disksim = NULL; 初始化 disksim 结构体 调用 disksim_initialize_disksim_structure(disksim) 函数，函数定义在 disksim.c:1117： 12345678910int disksim_initialize_disksim_structure (struct disksim *disksim)&#123; disksim-&gt;closedthinktime = 0.0; warmuptime = 0.0; /* gets remapped to disksim-&gt;warmuptime */ simtime = 0.0; /* gets remapped to disksim-&gt;warmuptime */ disksim-&gt;lastphystime = 0.0; disksim-&gt;checkpoint_interval = 0.0; return 0;&#125; 建立 disksim 调用 disksim_setup_disksim (argc, argv)，主要是对 disksim 做一些初始化操作。 大致功能：设置对齐方式（大端对齐还是小端对齐）、设置输出文件、设置 trace 的格式、 设置输入的 trace 数据的文件、判断是否启用 synthgen、设置重写的参数、根据配置文件设置参数、 iosim_info 的初始化，最后为开始模拟磁盘做准备。后面继续学习这个函数。 开始模拟 这里开始模拟磁盘的操作， 通过 disksim_run_simulation () 函数来开始模拟；没有传入任何参数，可以看出模拟的是全局的 disksim。 模拟结束后释放内存并打印输出结果。","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"DiskSim","slug":"notes/DiskSim","permalink":"https://cs0522.github.io/categories/notes/DiskSim/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cs0522.github.io/tags/Linux/"},{"name":"DiskSim","slug":"DiskSim","permalink":"https://cs0522.github.io/tags/DiskSim/"}]},{"title":"【学习笔记】DiskSim 学习（二）：简单使用","slug":"n-disksim-02","date":"2023-11-06T00:17:11.000Z","updated":"2025-01-17T18:57:47.125Z","comments":false,"path":"notes/DiskSim/n-disksim-02/","link":"","permalink":"https://cs0522.github.io/notes/DiskSim/n-disksim-02/","excerpt":"DiskSim 的简单使用方法以及命令的各个参数","text":"DiskSim 的简单使用方法以及命令的各个参数 DiskSim 包含许多存储元件的模型：device drivers, buses, controllers, adapters, disk drives。 在 disksim-4.0/valid 和 disksim-4.0/ssdmodel/valid/ 下都有 runvalid 脚本，里面有可以参考的运行命令示例。 整个系统里面有两个文件包含可以运行的主函数： disksim.c 和 syssim_driver.c。 disksim.c disksim-4.0/src 目录下的 disksim 为可执行程序。运行的命令格式为： 123disksim &lt;parfile&gt; &lt;outfile&gt; &lt;tracetype&gt; &lt;tracefile&gt; &lt;synthgen&gt; [par_override…]# 示例disksim atlas_III.parv atlas_III.outv validate atlas_III.trace 0 parfile 参数文件，包括仿真器各个参数的配置。后续文章继续学习。 outfile 输出文件，outfile 的项目内容可在 parfile 中设置，以去掉不需要的内容。 tracetype 确定输入 trace 的格式。比如：ASCII HPL HPL2 DEC VALIDATE RAW ATABUS IPEAK P OSTGRES EMCSYMM DEFAULT(ASCII) 等等。 Disksim 本身支持的 trace 类型是有限的，如果不支持实验使用的 trace，则需要修改 disksim 源程序以添加新的 trace 类型，添加方法如下： 在 disksim_global.h 中预定义 trace 类型常量 在 disksim_iotrace.c 文件的 iotrace_set_format 函数中添加相应的 if 判断语句 在 disksim_iotrace.c 文件中仿照 iotrace_ascii_get_ioreq_event 函数添加 iotrace_spc_get_ioreq_event 函数处理相应的 trace 文件。如果 trace 文件中包含一定的头信息，则需要在 disksim_iotrace.c 文件中添加 iotrace_xxxx_initialize_file 函数，并在 iotrace_initialize_file 函数中调用。 具体方法参照官方手册。后续文章继续学习。 tracefile 输入的 trace 文件。如果为 0 的话表示使用系统自动生成的 trace 数据。如果这个参数为 0，那么 synthgen 参数必须要大于 0，表示开启合成负载。 trace 每一行包含 5 个参数值（用空格隔开）来描述一个磁盘请求: 请求到达时间（double 型，表示从模拟开始到请求发生的时间，必须按时间上升的顺序 设备号（int 型，指定设备号，如果有设备映射，被加到该值） 块号（int 型，表示请求的第一个设备地址，其值为逻辑设备可访问的单元） 请求大小（int 型） 请求标志（十六进制整数，有效值在 disksim_global.h 中定义） synthgen 决定合成负载部分的模拟器是否打开（除 0 外的数表示开启） 当 synthgen 参数不为 0 时，那么 tracefile 参数就需要设置为 0，synthgen 的值就表示了用多少个 generator 来生成 trace，一个 generator 代表一个产生io请求的进程。每个 generator 的行为要在参数文件里面设置 模块可以配置为生成多钟合成的工作负载，与磁盘位置访问和请求到达时间相关。每一个合成器在简单系统模型里作为一个进程，在一定的“think time”后发出I/O请求，并等待完成。 对于特定的需求，实验时需要调整参数文件中 disksim_synthgen 配置或修改 disksim_synthetic.c 文件中的函数 synthio_generatenextio 以满足特定的请求特征（如访问的hot/cold 特征，zipfan 分布等），然后编译运行，获得实验结果。 Disksim提供了 uniform，normal，possion，expontenial，twovalue 等概率分布，可以灵活运用这些分布生成具有特定特征的请求，如符合 zipfan 分布的请求 par_override 允许默认参数值或者 parfile 文件中的参数值替换为命令行指定的值。 parameter overrides 的格式为 (component, param name, param value) 三元组： 1&lt;component&gt; &lt;parameter&gt; &lt;new value&gt; component 是需要被覆盖参数的目标组件。支持多个修改和通配符。用 &quot;&quot; 包裹。如：&quot;disk0 .. disk5&quot;、&quot;driver*&quot;（* 通配 0 或多个数字而不是字符） parameter 是需要被覆盖的参数。最好用 &quot;&quot; 包裹，因为可能会有空格。如：&quot;Scheduler:Scheduling policy&quot; new value 是新的值 Examples 1234# 格式disksim &lt;parfile&gt; &lt;outfile&gt; &lt;tracetype&gt; &lt;tracefile&gt; &lt;synthgen&gt; [par_override…]disksim parms.1B stdout ascii t.Jan6 0 &quot;disk1 .. disk16&quot; &quot;Segment size (in blks)&quot; 64 &quot;disk*&quot; &quot;Scheduler:Scheduling policy&quot; 4 运行后： 从文件 parms.1B 中读取初始化参数 output 发送至 stdout 读取 ascii 格式的 trace 文件 t.Jan6 无合成工作负载 disk1 ~ disk16 的 cache segment size 参数值被覆盖为 64 所有匹配 disk* 的组件的 scheduling plicy 值被覆盖为 4（对应为 SSTF 调度算法）","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"DiskSim","slug":"notes/DiskSim","permalink":"https://cs0522.github.io/categories/notes/DiskSim/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cs0522.github.io/tags/Linux/"},{"name":"DiskSim","slug":"DiskSim","permalink":"https://cs0522.github.io/tags/DiskSim/"}]},{"title":"【学习笔记】一个用 Python 2 + SimPy 2 实现的 DiskSim","slug":"n-disksim-simpy","date":"2023-11-05T07:46:05.000Z","updated":"2025-01-17T18:57:47.125Z","comments":false,"path":"notes/SimPy/n-disksim-simpy/","link":"","permalink":"https://cs0522.github.io/notes/SimPy/n-disksim-simpy/","excerpt":"学习一个用 Python 2 + SimPy 2 实现的 DiskSim 磁盘模拟器项目","text":"学习一个用 Python 2 + SimPy 2 实现的 DiskSim 磁盘模拟器项目 项目包含两个脚本： DiskSim.py：实现模拟器的主要功能 ReadQueue.py：实现 ReadQueue 队列，根据算法调整 项目环境为以下： Python 2.7 SimPy 2.3.1 numpy 1.7.1 matplotlib 1.2.1 (no support for Python 3+) 打算按照这个项目进行修改，从 Python 2 + SimPy 2 迁移至 Python 3 + SimPy 4，并添加其他的功能 FCFS、SSTF、Elevator/SCAN 磁盘调度算法 参考图解五种磁盘调度算法, FCFS, SSTF, SCAN, C-SCAN, LOOK FCFS 先来先服务（FCFS）算法。虽然这种算法比较公平，但是它通常并不提供最快的服务。 磁盘队列 I/O 请求块的柱面的顺序：98,183,37,122,14,124,65,67 调度如下图： 从 122 到 14 再到 124 的大摆动说明了这种调度的问题。如果对柱面 37 和 14 的请求一起处理，不管是在 122 和 124 之前或之后，总的磁头移动会大大减少，并且性能也会因此得以改善。 SSTF 最短寻道优先 SSTF 算法选择处理距离当前磁头位置的最短寻道时间的请求。换句话说，SSTF 选择最接近磁头位置的待处理请求。 对于上面请求队列的示例，与开始磁头位置（53）的最近请求位于柱面 65。一旦位于柱面 65，下个最近请求位于柱面 67。从那里，由于柱面 37 比 98 还要近，所以下次处理 37。如此，会处理位于柱面 14 的请求，接着 98，122，124，最后183（图 2）。这种调度算法的磁头移动只有 236 个柱面。 SSTF 调度本质上是一种最短作业优先（SJF）调度；与 SJF 调度一样，它可能会导致一些请求的饥饿。假设在队列中有两个请求，分别针对柱面 14 和 186，而当处理来自 14 的请求时，另一个靠近 14 的请求来了，这个新的请求会下次处理，这样位于 186 的请求需要等待。而当这样的新的请求足够多的话，186 的请求就得不到服务。 SSTF 的算法并非最优。从 53 到 37 再到 14，移动的柱面总数更少，为 208。 Elevator/SCAN 磁臂从磁盘的一端开始，向另一端移动；在移过每个柱面时，处理请求。当到达磁盘的另一端时，磁头移动方向反转，并继续处理。磁头连续来回扫描磁盘。 如图所示。在采用 SCAN 来调度柱面 98、183、37、122、14、124、65 和 67 的请求之前，除了磁头的当前位置，还需知道磁头的移动方向。 假设磁头朝 0 移动并且磁头初始位置还是 53，磁头接下来处理 37，然后 14。在柱面 0 时，磁头会反转，移向磁盘的另一端，并处理柱面 65、67、98、122、124、183（图 3）上的请求。如果请求刚好在磁头前方加入队列，则它几乎马上就会得到服务；如果请求刚好在磁头后方加入队列，则它必须等待，直到磁头移到磁盘的另一端，反转方向，并返回。 C-SCAN LOOK DiskSim.py 实现模拟器的主要功能 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185from SimPy.Simulation import *from random import expovariateimport argparseimport ReadQueueimport numpy as npimport matplotlib.pyplot as pltMOV_TIME = .4NUM_ALGS = 3NUM_TESTS = 4BYTES_PER_SEC = 256SECTORS = 128DISK_REQUESTS = 1000MEAN_READ_LENGTH = 4MAXTIME = 1000000.0 class Controller(Process): &quot;&quot;&quot;Disk controller generates DISK_REQUESTS # of requests for read head, distributed uniformly with average interarrival time specified by the user.&quot;&quot;&quot; def generate(self, mean): for i in range(DISK_REQUESTS): req = ReadRequest(name=&quot;Request%03d&quot; % (i), sim=self.sim) self.sim.activate(req, req.request()) nextReq = random.uniform(0, mean*2) if (i == 100): self.sim.byteMon.reset() self.sim.seekMon.reset() self.sim.accessMon.reset() self.sim.rotMon.reset() self.sim.diskMov.reset() yield hold, self, nextReq class ReadRequest(Process): &quot;&quot;&quot;ReadRequest class simulates a disk head read request sent to the arm&quot;&quot;&quot; def request(self): self.trackNum = int(random.uniform(0, 100)) readLength = expovariate(1.0/MEAN_READ_LENGTH) self.sim.byteMon.observe(readLength*BYTES_PER_SEC) yield request,self,self.sim.head,self.trackNum trackDis = abs(self.sim.head.pos - self.trackNum) self.sim.diskMov.observe(trackDis) seekTime = trackDis * MOV_TIME self.sim.seekMon.observe(seekTime) self.sim.head.pos = self.trackNum rotTime = (float(SECTORS)/float(self.sim.head.diskRpm)) * readLength self.sim.rotMon.observe(rotTime) accessTime = seekTime + rotTime self.sim.accessMon.observe(accessTime) yield hold,self,accessTime yield release,self,self.sim.headclass DiskSim(Simulation): &quot;&quot;&quot;Main Simulation class. Accepts command line input from the user, specifying which algorithm to run, the average inter arrival time, and the maximum rpm speed of the disk. Optionally, a test mode can be invoked to test all variants and graphically display their results. Usage from command line: python DiskSim.py -a FCFS -i 25 -r 7000 --- python DiskSim.py -test True &quot;&quot;&quot; def __init__(self): &quot;&quot;&quot;Constructor for DiskSim simulation&quot;&quot;&quot; parser = argparse.ArgumentParser(description=&#x27;Hard Disk Simulation&#x27;) parser.add_argument(&#x27;-test&#x27;,default=False,help=&quot;&quot;&quot;test mode will run through the 12 standard test for the disk simulator.&quot;&quot;&quot;) parser.add_argument(&#x27;-a&#x27;, choices=[&#x27;FCFS&#x27;,&#x27;SSF&#x27;,&#x27;SCAN&#x27;],default=&#x27;SCAN&#x27;, help=&quot;&quot;&quot;the algorithm used by the read head when selecting the next sector. Choices are FCFS, SSF, or SCAN. Default is FCFS&quot;&quot;&quot;) parser.add_argument(&#x27;-i&#x27;, default=5, type=int, help=&quot;&quot;&quot;average inter-arrival times of disk requests. Will be uniformly distributed; default is 150&quot;&quot;&quot;) parser.add_argument(&#x27;-r&#x27;, default=7200, type=int, help=&quot;&quot;&quot;maximum rotations per minute achieveable by the hard disk. Default is 7200&quot;&quot;&quot;) args = parser.parse_args() if (args.test): runTests() print(&quot;\\nAlgorithm: %s&quot;%args.a) print(&quot;Inter-arrival: %d&quot;%args.i) print(&quot;Disk RPM: %d&quot;%args.r) self.initialize() self.accessMon = Monitor(&#x27;Access time (Seek + Rotation)&#x27;, sim=self) self.seekMon = Monitor(&#x27;Seek time&#x27;, sim=self) self.rotMon = Monitor(&#x27;Rotational latency monitor&#x27;, sim=self) self.diskMov = Monitor(&#x27;Disk arm movement&#x27;, sim=self) self.byteMon = Monitor(&#x27;Total bytes read&#x27;, sim=self) self.head = Resource(name=&quot;ReadHead&quot;,qType= ReadQueue.ReadQ, sim=self) self.head.algorithm = args.a self.head.diskRpm = args.r self.head.pos = 0 controller = Controller(&#x27;Controller&#x27;,sim=self) self.activate(controller, controller.generate(mean=args.i), at=0.0) self.simulate(until=MAXTIME) print(&quot;Average seek time: %f&quot; %self.seekMon.mean()) print(&quot;Average rotational latency: %F&quot;%self.rotMon.mean()) print(&quot;Average access time: %f&quot;%self.accessMon.mean()) print(&quot;Total seek time: %f&quot;%self.accessMon.total()) print(&quot;Total disk arm movement: %d&quot;%self.diskMov.total()) print(&quot;Throughput: %f&quot;%(self.byteMon.total()/self.now())) print(&quot;Total execution time: %f&quot;%self.now())def runTests(): &quot;&quot;&quot;Testing method invoked from user command line option. Tests all the algorithms with all possible standard specifications and displays results to the command line. Also provides a graphical representation of test results.&quot;&quot;&quot; sims = [] rects = [] sys.argv=[&#x27;DiskSim&#x27;, &#x27;-a&#x27;, &#x27;FCFS&#x27;, &#x27;-i&#x27;,&#x27;150&#x27;, &#x27;-r&#x27;,&#x27;10000&#x27;] sims.append(DiskSim()) sys.argv=[&#x27;DiskSim&#x27;, &#x27;-a&#x27;, &#x27;SSF&#x27;, &#x27;-i&#x27;,&#x27;150&#x27;, &#x27;-r&#x27;, &#x27;10000&#x27;] sims.append(DiskSim()) sys.argv=[&#x27;DiskSim&#x27;, &#x27;-a&#x27;,&#x27;SCAN&#x27;, &#x27;-i&#x27;,&#x27;150&#x27;, &#x27;-r&#x27;, &#x27;10000&#x27;] sims.append(DiskSim()) sys.argv=[&#x27;DiskSim&#x27;, &#x27;-a&#x27;, &#x27;FCFS&#x27;, &#x27;-i&#x27;,&#x27;150&#x27;, &#x27;-r&#x27;,&#x27;7200&#x27;] sims.append(DiskSim()) sys.argv=[&#x27;DiskSim&#x27;, &#x27;-a&#x27;, &#x27;SSF&#x27;, &#x27;-i&#x27;,&#x27;150&#x27;, &#x27;-r&#x27;, &#x27;7200&#x27;] sims.append(DiskSim()) sys.argv=[&#x27;DiskSim&#x27;, &#x27;-a&#x27;,&#x27;SCAN&#x27;, &#x27;-i&#x27;,&#x27;150&#x27;, &#x27;-r&#x27;, &#x27;7200&#x27;] sims.append(DiskSim()) sys.argv=[&#x27;DiskSim&#x27;, &#x27;-a&#x27;, &#x27;FCFS&#x27;, &#x27;-i&#x27;,&#x27;5&#x27;, &#x27;-r&#x27;,&#x27;10000&#x27;] sims.append(DiskSim()) sys.argv=[&#x27;DiskSim&#x27;, &#x27;-a&#x27;, &#x27;SSF&#x27;, &#x27;-i&#x27;,&#x27;5&#x27;, &#x27;-r&#x27;, &#x27;10000&#x27;] sims.append(DiskSim()) sys.argv=[&#x27;DiskSim&#x27;, &#x27;-a&#x27;,&#x27;SCAN&#x27;, &#x27;-i&#x27;,&#x27;5&#x27;, &#x27;-r&#x27;, &#x27;10000&#x27;] sims.append(DiskSim()) sys.argv=[&#x27;DiskSim&#x27;, &#x27;-a&#x27;, &#x27;FCFS&#x27;, &#x27;-i&#x27;,&#x27;5&#x27;, &#x27;-r&#x27;,&#x27;7200&#x27;] sims.append(DiskSim()) sys.argv=[&#x27;DiskSim&#x27;, &#x27;-a&#x27;, &#x27;SSF&#x27;, &#x27;-i&#x27;,&#x27;5&#x27;, &#x27;-r&#x27;, &#x27;7200&#x27;] sims.append(DiskSim()) sys.argv=[&#x27;DiskSim&#x27;, &#x27;-a&#x27;,&#x27;SCAN&#x27;, &#x27;-i&#x27;,&#x27;5&#x27;, &#x27;-r&#x27;, &#x27;7200&#x27;] sims.append(DiskSim()) ind = np.arange(4) width = 0.30 fig = plt.figure() ax = fig.add_subplot(111) f_res = [[]*NUM_TESTS for x in xrange(NUM_ALGS)] s_res = [[]*NUM_TESTS for x in xrange(NUM_ALGS)] e_res = [[]*NUM_TESTS for x in xrange(NUM_ALGS)] for i in range(4): f_res[0].append(sims[(NUM_ALGS*i+0)].seekMon.mean()) f_res[1].append(sims[(NUM_ALGS*i+0)].rotMon.mean()) f_res[2].append(sims[(NUM_ALGS*i+0)].byteMon.total()/sims[(NUM_ALGS*i+0)].now()) s_res[0].append(sims[(NUM_ALGS*i+1)].seekMon.mean()) s_res[1].append(sims[(NUM_ALGS*i+1)].rotMon.mean()) s_res[2].append(sims[(NUM_ALGS*i+1)].byteMon.total()/sims[(3*i+1)].now()) e_res[0].append(sims[(NUM_ALGS*i+2)].seekMon.mean()) e_res[1].append(sims[(NUM_ALGS*i+2)].rotMon.mean()) e_res[2].append(sims[(NUM_ALGS*i+2)].byteMon.total()/sims[(NUM_ALGS*i+2)].now()) rects.append(ax.bar((ind+width), f_res[0], width, color=&#x27;red&#x27;)) rects.append(ax.bar((ind+width*2), s_res[0], width, color=&#x27;green&#x27;)) rects.append(ax.bar((ind+width*3), e_res[0], width, color=&#x27;blue&#x27;)) ax.set_ylabel(&#x27;Milliseconds&#x27;) ax.set_title(&#x27;Average Seek Time&#x27;) ax.set_xticks(ind+width*2) ax.set_xticklabels((&#x27;150/10000&#x27;,&#x27;150/7200&#x27;,&#x27;5/10000&#x27;,&#x27;5/7200&#x27;)) ax.legend((rects[0][0],rects[1][0],rects[2][0]), (&#x27;FCFS&#x27;, &#x27;SSF&#x27;,&#x27;Elevator/SCAN&#x27;)) plt.show() # Rotational Latency Display fig = plt.figure() ax = fig.add_subplot(111) rects.append(ax.bar((ind+width), f_res[1], width, color=&#x27;red&#x27;)) rects.append(ax.bar((ind+width*2), s_res[1], width, color=&#x27;green&#x27;)) rects.append(ax.bar((ind+width*3), e_res[1], width, color=&#x27;blue&#x27;)) ax.set_ylabel(&#x27;Milliseconds&#x27;) ax.set_title(&#x27;Average Rotational Latency&#x27;) ax.set_xticks(ind+width*2) ax.set_xticklabels((&#x27;150/10000&#x27;,&#x27;150/7200&#x27;,&#x27;5/10000&#x27;,&#x27;5/7200&#x27;)) ax.legend((rects[0][0],rects[1][0],rects[2][0]), (&#x27;FCFS&#x27;, &#x27;SSF&#x27;,&#x27;Elevator/SCAN&#x27;)) plt.show() # Throughput Display fig = plt.figure() ax = fig.add_subplot(111) rects.append(ax.bar((ind+width), f_res[2], width, color=&#x27;red&#x27;)) rects.append(ax.bar((ind+width*2), s_res[2], width, color=&#x27;green&#x27;)) rects.append(ax.bar((ind+width*3), e_res[2], width, color=&#x27;blue&#x27;)) ax.set_ylabel(&#x27;Milliseconds&#x27;) ax.set_title(&#x27;Average Throughput&#x27;) ax.set_xticks(ind+width*2) ax.set_xticklabels((&#x27;150/10000&#x27;,&#x27;150/7200&#x27;,&#x27;5/10000&#x27;,&#x27;5/7200&#x27;)) ax.legend((rects[0][0],rects[1][0],rects[2][0]), (&#x27;FCFS&#x27;, &#x27;SSF&#x27;,&#x27;Elevator/SCAN&#x27;)) plt.show() sys.exit()if __name__ == &quot;__main__&quot;: DiskSim() 定义全局变量 12345678910111213141516171819202122232425# 导入库from SimPy.Simulation import *from random import expovariateimport argparse# 编写的脚本import ReadQueueimport numpy as npimport matplotlib.pyplot as plt# MOV_TIME = .4# NUM_ALGS = 3# NUM_TESTS = 4# 每秒读取的字节数BYTES_PER_SEC = 256# 扇区大小SECTORS = 128# 磁盘请求数DISK_REQUESTS = 1000# 平均读取长度MEAN_READ_LENGTH = 4# 模拟时长MAXTIME = 1000000.0 Controller 类 磁盘控制器产生读磁头请求的 DISK_REQUESTS，以用户指定的平均到达时间均匀分布。 1234567891011121314class Controller(Process): def generate(self, mean): for i in range(DISK_REQUESTS): req = ReadRequest(name=&quot;Request%03d&quot; % (i), sim=self.sim) # 产生请求 self.sim.activate(req, req.request()) nextReq = random.uniform(0, mean*2) if (i == 100): self.sim.byteMon.reset() self.sim.seekMon.reset() self.sim.accessMon.reset() self.sim.rotMon.reset() self.sim.diskMov.reset() yield hold, self, nextReq ReadRequest 类 ReadRequest 类模拟发送到 arm 的磁盘头读取请求 12345678910111213141516171819202122232425class ReadRequest(Process): def request(self): self.trackNum = int(random.uniform(0, 100)) # 返回：随机 index 分布浮点数 readLength = expovariate(1.0/MEAN_READ_LENGTH) # 读取的总字节数 self.sim.byteMon.observe(readLength*BYTES_PER_SEC) yield request,self,self.sim.head,self.trackNum # 磁道的移动距离 trackDis = abs(self.sim.head.pos - self.trackNum) self.sim.diskMov.observe(trackDis) # 寻道时间 seekTime = trackDis * MOV_TIME self.sim.seekMon.observe(seekTime) # 磁头移动到磁道位置 self.sim.head.pos = self.trackNum # 磁盘旋转时间 rotTime = (float(SECTORS)/float(self.sim.head.diskRpm)) * readLength self.sim.rotMon.observe(rotTime) # 请求响应时间 = 寻道时间 + 磁盘旋转时间 accessTime = seekTime + rotTime self.sim.accessMon.observe(accessTime) yield hold,self,accessTime # 请求完毕，release yield release,self,self.sim.head DiskSim 类 主模拟类。接受用户的命令行输入，指定运行哪种算法、平均到达时间和磁盘最大 rpm 速度。 可选地，可以调用测试模式来测试所有参数，并以图形方式显示它们的结果。 Usage from command line： 12python DiskSim.py -a FCFS -i 25 -r 7000python DiskSim.py -test True 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class DiskSim(Simulation): def __init__(self): # Constructor for DiskSim simulation # 1. 创建一个 ArgumentParser 对象。description: 帮助信息 parser = argparse.ArgumentParser(description=&#x27;Hard Disk Simulation&#x27;) # 2. 添加参数 parser.add_argument(&#x27;-test&#x27;,default=False,help=&quot;&quot;&quot;test mode will run through the 12 standard test for the disk simulator.&quot;&quot;&quot;) parser.add_argument(&#x27;-a&#x27;, choices=[&#x27;FCFS&#x27;,&#x27;SSF&#x27;,&#x27;SCAN&#x27;],default=&#x27;SCAN&#x27;, help=&quot;&quot;&quot;the algorithm used by the read head when selecting the next sector. Choices are FCFS, SSF, or SCAN. Default is FCFS&quot;&quot;&quot;) parser.add_argument(&#x27;-i&#x27;, default=5, type=int, help=&quot;&quot;&quot;average inter-arrival times of disk requests. Will be uniformly distributed; default is 150&quot;&quot;&quot;) parser.add_argument(&#x27;-r&#x27;, default=7200, type=int, help=&quot;&quot;&quot;maximum rotations per minute achieveable by the hard disk. Default is 7200&quot;&quot;&quot;) # 3. 解析参数 args = parser.parse_args() if (args.test): runTests() # 以上是设置输入参数 # 打印参数 print(&quot;\\nAlgorithm: %s&quot;%args.a) print(&quot;Inter-arrival: %d&quot;%args.i) print(&quot;Disk RPM: %d&quot;%args.r) # SimPy 2 的环境初始化 self.initialize() # SimPy 2 Monitor 监视器 self.accessMon = Monitor(&#x27;Access time (Seek + Rotation)&#x27;, sim=self) self.seekMon = Monitor(&#x27;Seek time&#x27;, sim=self) self.rotMon = Monitor(&#x27;Rotational latency monitor&#x27;, sim=self) self.diskMov = Monitor(&#x27;Disk arm movement&#x27;, sim=self) self.byteMon = Monitor(&#x27;Total bytes read&#x27;, sim=self) # qType 设置队列的类型，作者进行了 readqueue 的重新实现 # qType 类的实现可以参照 SimPy 中的源码 self.head = Resource(name=&quot;ReadHead&quot;,qType= ReadQueue.ReadQ, sim=self) # 设置 算法、rpm、磁头位置等参数 self.head.algorithm = args.a self.head.diskRpm = args.r self.head.pos = 0 # Controller 类上面自己定义的产生 disk requests controller = Controller(&#x27;Controller&#x27;,sim=self) # 生成 disk requests self.activate(controller, controller.generate(mean=args.i), at=0.0) self.simulate(until=MAXTIME) print(&quot;Average seek time: %f&quot; %self.seekMon.mean()) print(&quot;Average rotational latency: %F&quot;%self.rotMon.mean()) print(&quot;Average access time: %f&quot;%self.accessMon.mean()) print(&quot;Total seek time: %f&quot;%self.accessMon.total()) print(&quot;Total disk arm movement: %d&quot;%self.diskMov.total()) print(&quot;Throughput: %f&quot;%(self.byteMon.total()/self.now())) print(&quot;Total execution time: %f&quot;%self.now()) SimPy 2 Monitor 类 监控变量的类，即允许收集简单统计信息的变量。 Monitor 是列表的子类，可以对其执行列表操作。使用 m=Monitor(name='...') 建立对象。 可以为其指定一个唯一的名称，用于调试和跟踪，以及用于标记图形的 ylab 和 tlab 字符串。 成员函数： setHistogram(self, name, low, high, nbins)：设置直方图参数；需要在 getHistogram() 前调用 observe(self, y, t)：记录 y 和 t reset(self, t)：重置变量的总和和计数 total(self)：y 的总和 mean(self)：变量的简单平均 getHistogram(self)：返回一个直方图对象；需要在 setHistogram() 后调用 printHistogram(self, fmt)：输出直方图，fmt 为格式；需要在 setHistogram() 后调用 runTests() 函数 略 ReadQueue.py 实现 ReadQueue 队列，根据算法调整 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from SimPy.Lib import *MAX_PRIORITY = 200# Creates enum functionalitydef enum(**enums): return type(&#x27;Enum&#x27;, (), enums)Dir = enum(FORWARD=1, BACK=2)class ReadQ(Queue): &quot;&quot;&quot;ReadQueue simulates the internal request queue&#x27;ing capabilities of the heard disk read head. Queues used and priority depend on specified algorithm&quot;&quot;&quot; def __init__(self, res, moni): &quot;&quot;&quot;Constructor for ReadQ data structure&quot;&quot;&quot; self.direction = Dir.FORWARD Queue.__init__(self, res, moni) def enter(self, obj): &quot;&quot;&quot;Add a read request to the waiting queue. Called by Simulator.&quot;&quot;&quot; self.append(obj) if self.monit: self.moni.observe(len(self),t = self.moni.sim.now()) def scanDistance(self, read): &quot;&quot;&quot;Prioritizes reads according to the SCAN/ELEVATOR algorithm&quot;&quot;&quot; if (self.direction == Dir.FORWARD): if (self.resource.pos &gt; read.trackNum): return (MAX_PRIORITY-read.trackNum) return read.trackNum elif (self.direction == Dir.BACK): if (self.resource.pos &lt; read.trackNum): return (MAX_PRIORITY+read.trackNum) return -read.trackNum def leave(self): &quot;&quot;&quot;Determines which read to service next according to algorithm, and returns it. Changes the direction of reads when appropriate for SCAN algorithm. Called by Simulator.&quot;&quot;&quot; if (self.resource.algorithm == &#x27;SSF&#x27;): self.sort(key=lambda read: abs(read.trackNum-self.resource.pos)) elif (self.resource.algorithm == &#x27;SCAN&#x27;): if (self.direction == Dir.FORWARD): self.sort(key=self.scanDistance) if (self.resource.pos &gt; self[0].trackNum): self.direction = Dir.BACK elif (self.direction == Dir.BACK): self.sort(key=self.scanDistance) if (self.resource.pos &lt; self[0].trackNum): self.direction = Dir.FORWARD ele = self.pop(0) if self.monit: self.moni.observe(len(self),t = self.moni.sim.now()) return ele 定义全局变量 12# 最大优先级 200MAX_PRIORITY = 200 定义枚举 定义了一个函数。可以用 Enum 和类来实现枚举数据类型：class MyEnum(Enum):。 12345# 磁头方向def enum(**enums): return type(&#x27;Enum&#x27;, (), enums)Dir = enum(FORWARD=1, BACK=2) ReadQ 类 ReadQueue 模拟磁盘读磁头的内部请求排队功能。使用的队列和优先级取决于指定的算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# 仿照 SimPy 的 FIFO 类class ReadQ(Queue): &quot;&quot;&quot; ReadQueue 模拟磁盘读磁头的内部请求排队功能。使用的队列和优先级取决于指定的算法 &quot;&quot;&quot; def __init__(self, res, moni): # 初始磁头方向为前进 self.direction = Dir.FORWARD Queue.__init__(self, res, moni) def enter(self, obj): &quot;&quot;&quot; 加入一个 read request 到 wait queue 中 由 Simulator 调用 &quot;&quot;&quot; self.append(obj) if self.monit: self.moni.observe(len(self),t = self.moni.sim.now()) # 自定义的函数 def scanDistance(self, read): &quot;&quot;&quot; 根据 SCAN/ELEVATOR 算法确定读取优先级 数值越小、优先级越高 如果要读取的 trackNum 与当前磁头移动方向一致，优先级更高；否则优先级更低 &quot;&quot;&quot; # trackNum ~ (0, 100) if (self.direction == Dir.FORWARD): if (self.resource.pos &gt; read.trackNum): # MAX_PRIORITY-trackNum ~ (100, 200) return (MAX_PRIORITY-read.trackNum) return read.trackNum elif (self.direction == Dir.BACK): if (self.resource.pos &lt; read.trackNum): # MAX_PRIORITY+trackNum ~ (200, 300) return (MAX_PRIORITY+read.trackNum) return -read.trackNum def leave(self): &quot;&quot;&quot; 根据算法确定下一个要服务的 read 并返回 在 SCAN 算法的情况下更改读取方向 由 Simulator 调用 &quot;&quot;&quot; # FCFS 直接根据进入 Queue 顺序 # SSF 根据 trackNum 距离磁头的位置进行 read 排序 if (self.resource.algorithm == &#x27;SSF&#x27;): self.sort(key=lambda read: abs(read.trackNum-self.resource.pos)) # SCAN 根据磁头方向以及 scanDistance() 中确定的优先级进行 read 排序 elif (self.resource.algorithm == &#x27;SCAN&#x27;): if (self.direction == Dir.FORWARD): self.sort(key=self.scanDistance) # self[0] ==&gt; self.__getItem__(0) # ReadQueue 类继承自 Queue 类继承自 list 类，list 类中有 __getItem__() 函数 # 这里不是达到磁盘的 track 一端再反向， # 而是当磁头位置大于/小于数值最小（优先级最高）时反向 if (self.resource.pos &gt; self[0].trackNum): # 反向 self.direction = Dir.BACK elif (self.direction == Dir.BACK): self.sort(key=self.scanDistance) if (self.resource.pos &lt; self[0].trackNum): # 反向 self.direction = Dir.FORWARD ele = self.pop(0) if self.monit: self.moni.observe(len(self),t = self.moni.sim.now()) return ele","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"SimPy","slug":"notes/SimPy","permalink":"https://cs0522.github.io/categories/notes/SimPy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://cs0522.github.io/tags/Python/"},{"name":"DiskSim","slug":"DiskSim","permalink":"https://cs0522.github.io/tags/DiskSim/"},{"name":"SimPy","slug":"SimPy","permalink":"https://cs0522.github.io/tags/SimPy/"}]},{"title":"【学习笔记】SimPy 学习（六）：监视","slug":"n-simpy-06","date":"2023-11-02T14:27:58.000Z","updated":"2025-01-17T18:57:47.133Z","comments":false,"path":"notes/SimPy/n-simpy-06/","link":"","permalink":"https://cs0522.github.io/notes/SimPy/n-simpy-06/","excerpt":"SimPy Monitoring","text":"SimPy Monitoring Monitor processes 在一个或多个状态变量每次更改时或以离散的间隔监视它们的值，并将其存储在某个位置（例如，内存、数据库或文件中） 在以下例子中，只需使用一个列表，并在每次更改时附加所需的值。 123456789101112131415import simpydata = [] # This list will hold all collected datadef test_process(env, data): val = 0 for i in range(5): val += env.now data.append(val) # Collect data yield env.timeout(1)env = simpy.Environment()p = env.process(test_process(env, data))env.run(p)print(&#x27;Collected&#x27;, data) 1Collected [0, 1, 3, 6, 10] 如果要监视多个变量，可以将 (named)tuples 附加到数据列表中。 如果将数据存储在 NumPy 数组或数据库中，可以通过将数据缓冲在 Python 列表中，并且只向数据库写入较大的块（或完整的数据集）。 Resource usage 资源的监视有很多种可能的情况，比如： 一段时间内的资源利用率， 一次使用资源的进程数 container 的 level store 中的 item 数量 这可以在离散的时间步长中进行监控，也可以在每次发生变化时进行监控 一段时间内（put | get）队列中的进程数（以及平均值）。也可以在离散的时间步长或每次发生变化时进行监控 对于 PreemptiveResource，可能需要测量一段时间内发生抢占的频率 没有直接的访问资源的代码，但可以通过 Monkey-patching 方法收集。 以下是一个示例，演示了如何向在 get/request 或 put/release 事件之前或之后被调用的资源添加回调： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from functools import partial, wrapsimport simpydef patch_resource(resource, pre=None, post=None): &quot;&quot;&quot;Patch *resource* so that it calls the callable *pre* before each put/get/request/release operation and the callable *post* after each operation. The only argument to these functions is the resource instance. &quot;&quot;&quot; def get_wrapper(func): # Generate a wrapper for put/get/request/release @wraps(func) def wrapper(*args, **kwargs): # This is the actual wrapper # Call &quot;pre&quot; callback if pre: pre(resource) # Perform actual operation ret = func(*args, **kwargs) # Call &quot;post&quot; callback if post: post(resource) return ret return wrapper # Replace the original operations with our wrapper for name in [&#x27;put&#x27;, &#x27;get&#x27;, &#x27;request&#x27;, &#x27;release&#x27;]: if hasattr(resource, name): setattr(resource, name, get_wrapper(getattr(resource, name)))def monitor(data, resource): &quot;&quot;&quot;This is our monitoring callback.&quot;&quot;&quot; item = ( resource._env.now, # The current simulation time resource.count, # The number of users len(resource.queue), # The number of queued processes ) data.append(item)def test_process(env, res): with res.request() as req: yield req yield env.timeout(1)env = simpy.Environment()res = simpy.Resource(env, capacity=1)data = []# Bind *data* as first argument to monitor()# see https://docs.python.org/3/library/functools.html#functools.partialmonitor = partial(monitor, data)patch_resource(res, post=monitor) # Patches (only) this resource instancep = env.process(test_process(env, res))env.run(p)print(data) 1[(0, 1, 0), (1, 0, 0)] 查看一次有多少个 processes 在等待同一个资源： 12345678910111213141516171819202122232425262728import simpyclass MonitoredResource(simpy.Resource): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.data = [] def request(self, *args, **kwargs): self.data.append((self._env.now, len(self.queue))) return super().request(*args, **kwargs) def release(self, *args, **kwargs): self.data.append((self._env.now, len(self.queue))) return super().release(*args, **kwargs)def test_process(env, res): with res.request() as req: yield req yield env.timeout(1)env = simpy.Environment()res = MonitoredResource(env, capacity=1)p1 = env.process(test_process(env, res))p2 = env.process(test_process(env, res))env.run()print(res.data) 1[(0, 0), (0, 0), (1, 1), (2, 0)] Event tracing 跟踪事件的创建、触发和处理时间，哪个进程创建了事件，哪些进程等待了事件。 Environment.step()：处理所有事件 Environment.schedule()：安排所有事件、插入 SimPy 事件队列中 Environment.step() 跟踪所有处理的事件： 123456789101112131415161718192021222324252627282930313233343536373839404142from functools import partial, wrapsimport simpydef trace(env, callback): &quot;&quot;&quot;Replace the ``step()`` method of *env* with a tracing function that calls *callbacks* with an events time, priority, ID and its instance just before it is processed. &quot;&quot;&quot; def get_wrapper(env_step, callback): &quot;&quot;&quot;Generate the wrapper for env.step().&quot;&quot;&quot; @wraps(env_step) def tracing_step(): &quot;&quot;&quot;Call *callback* for the next event if one exist before calling ``env.step()``.&quot;&quot;&quot; if len(env._queue): t, prio, eid, event = env._queue[0] callback(t, prio, eid, event) return env_step() return tracing_step env.step = get_wrapper(env.step, callback)def monitor(data, t, prio, eid, event): data.append((t, eid, type(event)))def test_process(env): yield env.timeout(1)data = []# Bind *data* as first argument to monitor()# see https://docs.python.org/3/library/functools.html#functools.partialmonitor = partial(monitor, data)env = simpy.Environment()trace(env, monitor)p = env.process(test_process(env))env.run(until=p)for d in data: print(d) 123(0, 0, &lt;class &#x27;simpy.events.Initialize&#x27;&gt;)(1, 1, &lt;class &#x27;simpy.events.Timeout&#x27;&gt;)(1, 2, &lt;class &#x27;simpy.events.Process&#x27;&gt;) SimPy 学习 【学习笔记】SimPy 学习（一）：基础 【学习笔记】SimPy 学习（二）：进程交互 【学习笔记】SimPy 学习（三）：资源共享 【学习笔记】SimPy 学习（四）：实时模拟与时间调度 【学习笔记】SimPy 学习（五）：SimPy 版本迁移 【学习笔记】SimPy 学习（六）：监视","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"SimPy","slug":"notes/SimPy","permalink":"https://cs0522.github.io/categories/notes/SimPy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://cs0522.github.io/tags/Python/"},{"name":"SimPy","slug":"SimPy","permalink":"https://cs0522.github.io/tags/SimPy/"}]},{"title":"【学习笔记】SimPy 学习（五）：SimPy 版本迁移","slug":"n-simpy-05","date":"2023-10-29T14:27:58.000Z","updated":"2025-01-17T18:57:47.133Z","comments":false,"path":"notes/SimPy/n-simpy-05/","link":"","permalink":"https://cs0522.github.io/notes/SimPy/n-simpy-05/","excerpt":"SimPy 版本迁移：SimPy 2 -&gt; SimPy 3 -&gt; SimPy 4","text":"SimPy 版本迁移：SimPy 2 -&gt; SimPy 3 -&gt; SimPy 4 API Reference SimPy 2 to 3 Imports SimPy 3 的 import 被简化。SimPy 2 需要根据模拟环境选择需要导入的模块，SimPy 3 大部分情况下只用导入 simpy 12# SimPy 2from Simpy.Simulation import Simulation, Process, hold 12# SimPy 3import simpy Simulation* classes SimPy 3 的 Environment 替换 Simulation，RealtimeEnvironment 替换 SimulationRT。 1234567891011121314# SimPy 2# Procedural APIfrom SimPy.Simulation import initialize, simulateinitialize()# Start processessimulate(until=10)# Object-oriented APIfrom SimPy.Simulation import Simulationsim = Simulation()# Start processessim.simulate(until=10) 123456# SimPy 3import simpyenv = simpy.Environment()# Start processesenv.run(until=10) Defining a Process SimPy 3 中的 Process 是一个封装在进程实例中的 Python 生成器（无论它是在模块级定义的还是作为实例方法定义的）。生成器通常需要对环境的引用才能与之交互，但这是可选的。 进程可以通过创建一个进程实例并将生成器传递给它来启动。环境为此提供了一个快捷方式：process()。 1234567891011121314151617181920212223242526272829303132# SimPy 2# Procedural APIfrom Simpy.Simulation import Processclass MyProcess(Process): def __init__(self, another_param): super().__init__() self.another_param = another_param def generator_function(self): &quot;&quot;&quot;Implement the process&#x27; behavior.&quot;&quot;&quot; yield somethinginitialize()proc = Process(&#x27;Spam&#x27;)activate(proc, proc.generator_function())# Object-oriented APIfrom SimPy.Simulation import Simulation, Processclass MyProcess(Process): def __init__(self, sim, another_param): super().__init__(sim=sim) self.another_param = another_param def generator_function(self): &quot;&quot;&quot;Implement the process&#x27; behaviour.&quot;&quot;&quot; yield somethingsim = Simulation()proc = Process(sim, &#x27;Spam&#x27;)sim.activate(proc, proc.generator_function()) 123456789# SimPy 3import simpydef generator_function(env, another_param): &quot;&quot;&quot;Implement the process&#x27; behavior.&quot;&quot;&quot; yield somethingenv = simpy.Environment()proc = env.process(generator_function(env, &#x27;Spam&#x27;)) SimPy Keywords SimPy 3中，可以直接生成事件。可以直接实例化事件，也可以使用 Environment 提供的快捷方式。 通常，每当一个进程产生一个事件时，该进程的执行都会被挂起，并在事件被触发后重新开始。为了激发这种理解，一些活动被重新命名。例如，hold 关键字意味着等待一段时间。就事件而言，这意味着发生了超时。因此，hold 已被 Timeout 事件取代。 12345678910# SimPy 2yield hold, self, durationyield passivate, selfyield request, self, resourceyield release, self, resourceyield waitevent, self, eventyield waitevent, self, [event_a, event_b, event_c]yield queueevent, self, event_listyield get, self, level, amountyield put, self, level, amount 123456789101112131415# SimPy 3yield env.timeout(duration) # hold: renamedyield env.event() # passivate: renamedyield resource.request() # Request is now bound to class Resourceresource.release() # Release no longer needs to be yieldedyield event # waitevent: just yield the eventyield env.all_of([event_a, event_b, event_c]) # waiteventyield env.any_of([event_a, event_b, event_c]) # queueventyield container.get(amount) # Level is now called Containeryield container.put(amount)yield event_a | event_b # Wait for either a or b. This is new.yield event_a &amp; event_b # Wait for a and b. This is new.yield env.process(calculation(env)) # Wait for the process calculation to # to finish. Interrupts SimPy 3 中，可以对进程调用 interrupt()。一个中断被抛出到进程中，进程必须通过 try...except simpy.Interrupt 处理中断。 1234567891011121314151617# SimPy 2class Interrupter(Process): def __init__(self, victim): super().__init__() self.victim = victim def run(self): yield hold, self, 1 self.interrupt(self.victim_proc) self.victim_proc.interruptCause = &#x27;Spam&#x27;class Victim(Process): def run(self): yield hold, self, 10 if self.interrupted: cause = self.interruptCause self.interruptReset() 12345678910# SimPy 3def interrupter(env, victim_proc): yield env.timeout(1) victim_proc.interrupt(&#x27;Spam&#x27;)def victim(env): try: yield env.timeout(10) except Interrupt as interrupt: cause = interrupt.cause SimPy 3 to 4 Python &gt;= 3.6 Environment Subclasses BaseEnvironment 类已在 SimPy 4 中移除。Environment 类现在是最基本的类。任何从 BaseEnvironment 继承的代码都应该修改为从 Environment 继承。 1234567# SimPy 3class MyEnv(SimPy.BaseEnvironment): ...# SimPy 4class MyEnv(SimPy.Environment): ... Returning from Process Generators 在下面的示例中，Environment.exit() 用于返回 the first needle。当将 SimPy 3 与 Python 2 一起使用时，这是从流程生成器返回值的唯一方法。 123456789# SimPy 3 + Python 2 def find_first_needle(env, store): while True: item = yield store.get() if is_needle(item): env.exit(item) # Python2 generators cannot use returndef proc(env, store): needle = yield env.process(find_first_needle(env, store)) 在 SimPy 4 与 Python 3 下，可以写为： 12345def find_first_needle(env, store): while True: item = yield store.get() if is_needle(item): return item # A Python3 generator can return SimPy 学习 【学习笔记】SimPy 学习（一）：基础 【学习笔记】SimPy 学习（二）：进程交互 【学习笔记】SimPy 学习（三）：资源共享 【学习笔记】SimPy 学习（四）：实时模拟与时间调度 【学习笔记】SimPy 学习（五）：SimPy 版本迁移 【学习笔记】SimPy 学习（六）：监视","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"SimPy","slug":"notes/SimPy","permalink":"https://cs0522.github.io/categories/notes/SimPy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://cs0522.github.io/tags/Python/"},{"name":"SimPy","slug":"SimPy","permalink":"https://cs0522.github.io/tags/SimPy/"}]},{"title":"【学习笔记】SimPy 学习（四）：实时模拟与时间调度","slug":"n-simpy-04","date":"2023-10-28T14:41:08.000Z","updated":"2025-01-17T18:57:47.133Z","comments":false,"path":"notes/SimPy/n-simpy-04/","link":"","permalink":"https://cs0522.github.io/notes/SimPy/n-simpy-04/","excerpt":"Simpy 的 Real-time simulations，即设置模拟的时间步长","text":"Simpy 的 Real-time simulations，即设置模拟的时间步长 Real-time-simulation 不以快的速度执行模拟，与现实的时钟时间同步（他是真的执行了这么长时间。如设置 1 分钟，执行 1 分钟）。 hardware-in-the-loop 模拟中存在交互 分析算法的实时行为 APIs simpy.rt.RealtimeEnvironment(initial_time=0, factor=1.0, strict=True) factor 定义模拟时间步长。设置为 0.1，模拟时间单位 1/10 秒；设置为 60，模拟时间单位 1 分钟 strict 严格判断模拟时间步长内的计算所花费的时间是否超过 factor 所允许的时间。如果超过了发生中断 Example 4.1 简单实时模拟的例子 123456789101112131415161718import timeimport simpydef example(env): start = time.perf_counter() # 时延 1 个单位，也就是 1 个 factor yield env.timeout(1) end = time.perf_counter() print(&#x27;Duration of one simulation time unit: %.2fs&#x27; % (end - start))env = simpy.Environment()proc = env.process(example(env))env.run(until=proc)import simpy.rtenv = simpy.rt.RealtimeEnvironment(factor=10)proc = env.process(example(env))env.run(until=proc) 查看结果 12Duration of one simulation time unit: 0.00sDuration of one simulation time unit: 10.01s Time and Scheduling SimPy 是一个单线程、确定性的库，按顺序逐个处理事件。如果同时安排两个事件，则首先安排的事件也将是最先处理的事件（FIFO）。 模拟环境中的进程是并行运行，但当模拟在 CPU 上运行时，所有事件会按顺序进行确定处理。如果多次运行模拟（不使用 random 情况下），则总会得到相同的结果。 SimPy 的事件队列被实现为堆队列。因此，将事件作为元组 (t, event)（t 是计划时间）插入其中，那么队列中的第一个元素将始终是t最小的元素，下一个元素将被处理。 如果同时调度两个事件，则存储 (t, event) 元组将不起作用。为了解决这个问题，SimPy 还存储了一个严格递增的事件 id: (t, eid, event)。这样，如果两个事件被安排在同一时间，那么首先被安排的事件（id 更小）将始终被首先处理。 SimPy 学习 【学习笔记】SimPy 学习（一）：基础 【学习笔记】SimPy 学习（二）：进程交互 【学习笔记】SimPy 学习（三）：资源共享 【学习笔记】SimPy 学习（四）：实时模拟与时间调度 【学习笔记】SimPy 学习（五）：SimPy 版本迁移 【学习笔记】SimPy 学习（六）：监视","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"SimPy","slug":"notes/SimPy","permalink":"https://cs0522.github.io/categories/notes/SimPy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://cs0522.github.io/tags/Python/"},{"name":"SimPy","slug":"SimPy","permalink":"https://cs0522.github.io/tags/SimPy/"}]},{"title":"【学习笔记】SimPy 学习（三）：资源共享","slug":"n-simpy-03","date":"2023-10-27T08:24:09.000Z","updated":"2025-01-17T18:57:47.133Z","comments":false,"path":"notes/SimPy/n-simpy-03/","link":"","permalink":"https://cs0522.github.io/notes/SimPy/n-simpy-03/","excerpt":"SimPy 的资源共享，Resource、Container、Store 等","text":"SimPy 的资源共享，Resource、Container、Store 等 仿真中涉及的人力资源以及工艺上的物料消耗都会抽象用 Resource 来表达，主要的 method 是 request。Store 处理各种优先级的队列问题，表现跟 queue 一致，通过 get()/put() 存放 item。 123456BaseResource(capacity): put_queue get_queue put(): event get(): event 每个资源都有一个最大容量和两个队列：一个队列用于要向其中放入内容的进程，另一个队列则用于要取出内容的进程。put() 和 get() 方法都返回一个在相应操作成功时触发的事件。 SimPy 定义了三类资源： Resources：一次可由有限数量的过程使用的资源（例如，具有有限数量燃油泵的加油站） 资源或限制条件：simpy.Resource(env, capacity) 优先级、不可打断正在服务的进程：simpy.PriorityResource 优先级、可以打断正在服务的进程：simpy.PreemptiveResource Containers：模拟同质、未分散的生产、消费资源。它可以是连续的（如水）或离散的（如苹果） 连续不可分的元素：simpy.Container Stores：允许生产和使用 Python 对象的资源 存取 Item、遵循先来后到：simpy.Store 添加优先级：simpy.PriorityStore 存在分类：simpy.FilterStore Resources APIs simpy.Resource(env, capacity = ) simpy.Resource.request(priority = ) simpy.Resource.release() Example 3.1 电动汽车使用两个充电桩中间的一个进行充电。如果这两个点都在使用，汽车将等待其中一个点直至其再次可用，然后开始给充电，完成后离开充电站 123456789101112131415161718192021222324import simpydef car(env, name, bcs, driving_time, charge_duration): # 驶向充电站 yield env.timeout(driving_time) print(&#x27;%s 到达时间 %d&#x27; % (name, env.now)) # 请求充电桩 with bcs.request() as req: yield req print(&#x27;%s 充电开始时间 %d&#x27; % (name, env.now)) yield env.timeout(charge_duration) print(&#x27;%s 充电结束并驶离时间 %d&#x27; % (name, env.now))env = simpy.Environment()# bcs 充电桩资源bcs = simpy.Resource(env, capacity = 2)# 创建汽车进程for i in range(4): env.process(car(env, &#x27;第 %d 辆车&#x27; % (i + 1), bcs, i * 2, 5))env.run() 资源 resource 的 request() 方法生成一个事件 event， 该事件会等待直至资源可用。之后一直拥有资源，直至资源被释放。 在代码中使用 with 构造资源的请求使用，资源在使用后将自动释放。如果没通过 with 使用 request()，需要自行使用 release() 释放资源。 释放资源后，下一个等待的进程将激活，占用资源。资源的排队规则遵循先进先出 FIFO策略。 查看结果 123456789101112第 1 辆车 到达时间 0第 1 辆车 充电开始时间 0第 2 辆车 到达时间 2第 2 辆车 充电开始时间 2第 3 辆车 到达时间 4第 1 辆车 充电结束并驶离时间 5第 3 辆车 充电开始时间 5第 4 辆车 到达时间 6第 2 辆车 充电结束并驶离时间 7第 4 辆车 充电开始时间 7第 3 辆车 充电结束并驶离时间 10第 4 辆车 充电结束并驶离时间 12 Example 3.2 银行排队服务例子：一个柜台对客户进行服务，服务耗时，客户等候过长会离开柜台 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&quot;&quot;&quot;银行排队服务例子：一个柜台对客户进行服务，服务耗时，客户等候过长会离开柜台&quot;&quot;&quot;import simpyimport randomRANDOM_SEED = 42NEW_CUSTOMERS = 5 # 客户数INTERVAL_CUSTOMERS = 10.0 # 客户到达的间距时间MIN_PATIENCE = 1 # 客户等待时间, 最小MAX_PATIENCE = 3 # 客户等待时间, 最大# 生成客户def source(env, number, interval, counter): for i in range(number): c = customer(env, &#x27;Customer%02d&#x27; % i, counter, time_in_bank = 12.0) env.process(c) t = random.expovariate(1.0 / interval) yield env.timeout(t)# 客户到达、服务、离开def customer(env, name, counter, time_in_bank): arrive = env.now print(&#x27;%7.4f %s: Here I am&#x27; % (arrive, name)) with counter.request() as req: patience = random.uniform(MIN_PATIENCE, MAX_PATIENCE) # 等待柜员服务或者超出忍耐时间离开队伍 results = yield req | env.timeout(patience) wait = env.now - arrive if req in results: # 到达柜台 print(&#x27;%7.4f %s: Waited %6.3f&#x27; % (env.now, name, wait)) tib = random.expovariate(1.0 / time_in_bank) yield env.timeout(tib) print(&#x27;%7.4f %s: Finished&#x27; % (env.now, name)) else: # 没有服务到位 print(&#x27;%7.4f %s: RENEGED after %6.3f&#x27; % (env.now, name, wait))# Setup and start the simulationprint(&#x27;Bank renege&#x27;)random.seed(RANDOM_SEED)env = simpy.Environment()# Start processes and runcounter = simpy.Resource(env, capacity = 1)env.process(source(env, NEW_CUSTOMERS, INTERVAL_CUSTOMERS, counter))env.run() 查看结果 123456789101112131415Bank renege 0.0000 Customer00: Here I am 0.0000 Customer00: Waited 0.000 3.8595 Customer00: Finished10.2006 Customer01: Here I am10.2006 Customer01: Waited 0.00012.7265 Customer02: Here I am13.9003 Customer02: RENEGED after 1.17423.7507 Customer01: Finished34.9993 Customer03: Here I am34.9993 Customer03: Waited 0.00037.9599 Customer03: Finished40.4798 Customer04: Here I am40.4798 Customer04: Waited 0.00043.1401 Customer04: Finished Example 3.3 PriorityResource 优先资源。此资源子类允许请求进程为每个请求提供优先级。更重要的请求将比不重要的请求更早地访问资源。优先级用整数表示；较小的数字意味着较高的优先级。 优先资源例子 123456789101112131415161718import simpydef resource_user(name, env, resource, wait, prio): print(f&#x27;&#123;name&#125; 在 &#123;env.now&#125; 到达，优先级是 &#123;prio&#125;&#x27;) print(f&#x27;&#123;name&#125; 挂起...&#x27;) yield env.timeout(wait) with resource.request(priority=prio) as req: print(f&#x27;&#123;name&#125; requesting at &#123;env.now&#125; with priority=&#123;prio&#125;&#x27;) yield req print(f&#x27;&#123;name&#125; got resource at &#123;env.now&#125;&#x27;) yield env.timeout(3) env = simpy.Environment()res = simpy.PriorityResource(env, capacity=1)p2 = env.process(resource_user(2, env, res, wait=1, prio=0))p1 = env.process(resource_user(1, env, res, wait=0, prio=0))p3 = env.process(resource_user(3, env, res, wait=2, prio=-1))env.run() 查看结果 1234567891011122 在 0 到达，优先级是 02 挂起...1 在 0 到达，优先级是 01 挂起...3 在 0 到达，优先级是 -13 挂起...1 requesting at 0 with priority=01 got resource at 02 requesting at 1 with priority=03 requesting at 2 with priority=-13 got resource at 32 got resource at 6 Example 3.4 PreemptiveResource 抢占资源。 抢占资源例子 12345678910111213141516171819202122232425import simpydef resource_user(name, env, resource, wait, prio): print(f&#x27;&#123;name&#125; 在 &#123;env.now&#125; 到达，优先级是 &#123;prio&#125;&#x27;) print(f&#x27;&#123;name&#125; 挂起...&#x27;) yield env.timeout(wait) with resource.request(priority=prio) as req: print(f&#x27;&#123;name&#125; requesting at &#123;env.now&#125; with priority=&#123;prio&#125;&#x27;) yield req print(f&#x27;&#123;name&#125; got resource at &#123;env.now&#125;&#x27;) try: yield env.timeout(3) except simpy.Interrupt as interrupt: by = interrupt.cause.by usage = env.now - interrupt.cause.usage_since print(f&#x27;&#123;name&#125; got preempted by &#123;by&#125; at &#123;env.now&#125;&#x27; f&#x27; after &#123;usage&#125;&#x27;) env = simpy.Environment()res = simpy.PreemptiveResource(env, capacity=1)p3 = env.process(resource_user(3, env, res, wait=2, prio=-1))p1 = env.process(resource_user(1, env, res, wait=0, prio=0))p2 = env.process(resource_user(2, env, res, wait=1, prio=0))env.run() 查看结果 123456789101112133 在 0 到达，优先级是 -13 挂起...1 在 0 到达，优先级是 01 挂起...2 在 0 到达，优先级是 02 挂起...1 requesting at 0 with priority=01 got resource at 02 requesting at 1 with priority=03 requesting at 2 with priority=-11 got preempted by &lt;Process(resource_user) object at 0x7fa733116898&gt; at 2 after 23 got resource at 22 got resource at 5 Example 3.5 抢占请求不允许跳过优先级更高的请求。以下示例显示，在队列中，抢占式的低优先级请求无法插队非抢占式的高优先级请求。 抢占式低优先级不允许跳过例子 12345678910111213141516171819202122import simpydef user(name, env, res, prio, preempt): with res.request(priority=prio, preempt=preempt) as req: try: print(f&#x27;&#123;name&#125; requesting at &#123;env.now&#125;&#x27;) assert isinstance(env.now, int), type(env.now) yield req assert isinstance(env.now, int), type(env.now) print(f&#x27;&#123;name&#125; got resource at &#123;env.now&#125;&#x27;) yield env.timeout(3) except simpy.Interrupt: print(f&#x27;&#123;name&#125; got preempted at &#123;env.now&#125;&#x27;) env = simpy.Environment()res = simpy.PreemptiveResource(env, capacity=1)A = env.process(user(&#x27;A&#x27;, env, res, prio=0, preempt=True))env.run(until=1) # Give A a head startB = env.process(user(&#x27;B&#x27;, env, res, prio=-2, preempt=False))C = env.process(user(&#x27;C&#x27;, env, res, prio=-1, preempt=True))env.run() 处理 A 请求优先级为 0 的资源。它立即成为用户 进程 B 请求优先级为 -2 的资源，但将 preempt 设置为 False。它会排队等候 进程 C 请求优先级为 -1 的资源，但保留 preempt 为 True。通常情况下，它会抢占 A，但在这种情况下，B 在 C 之前排队，并阻止 C 抢占 A。由于 B 的优先级不够高，C 也不能抢占 B 由于进程B的优先级较高，在本例中不发生抢占。优先级为 -3 的请求可以抢占 A。 查看结果 123456A requesting at 0A got resource at 0B requesting at 1C requesting at 1B got resource at 3C got resource at 6 Containers APIs simpy.Container(env, init = , capacity = ) simpy.Container.level simpy.Container.put() simpy.Container.get() Example 3.6 模拟加油站的 tank。Tanker 增加了 tank 中的汽油量，而 Car 则减少了汽油量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import simpyclass GasStation: def __init__(self, env): # 2 个加油机 self.fuel_dispensers = simpy.Resource(env, capacity=2) # tank 容量为 1000，初始 100 self.gas_tank = simpy.Container(env, init=100, capacity=1000) self.mon_proc = env.process(self.monitor_tank(env)) # 监视是否需要加油 def monitor_tank(self, env): while True: if self.gas_tank.level &lt; 100: print(f&#x27;Calling tanker at &#123;env.now&#125;&#x27;) env.process(tanker(env, self)) yield env.timeout(15)def tanker(env, gas_station): yield env.timeout(10) # Need 10 Minutes to arrive print(f&#x27;Tanker arriving at &#123;env.now&#125;&#x27;) # tank 加满 amount = gas_station.gas_tank.capacity - gas_station.gas_tank.level yield gas_station.gas_tank.put(amount)def car(name, env, gas_station): print(f&#x27;Car &#123;name&#125; arriving at &#123;env.now&#125;&#x27;) with gas_station.fuel_dispensers.request() as req: yield req print(f&#x27;Car &#123;name&#125; starts refueling at &#123;env.now&#125;&#x27;) yield gas_station.gas_tank.get(40) yield env.timeout(5) print(f&#x27;Car &#123;name&#125; done refueling at &#123;env.now&#125;&#x27;)def car_generator(env, gas_station): for i in range(4): env.process(car(i, env, gas_station)) yield env.timeout(5)env = simpy.Environment()gas_station = GasStation(env)car_gen = env.process(car_generator(env, gas_station))env.run(35) 加油站具有数量有限的加油机（建模为 Resource）和油箱（建模为 Container）。可以检查其当前液位及其容量（GasStation.monitor_tank() 和 tanker()）。可以通过 put_queue 和 get_queue属性（类似于Resource.queue）访问等待事件列表。 查看结果 1234567891011121314Car 0 arriving at 0Car 0 starts refueling at 0Car 1 arriving at 5Car 0 done refueling at 5Car 1 starts refueling at 5Car 2 arriving at 10Car 1 done refueling at 10Car 2 starts refueling at 10Calling tanker at 15Car 3 arriving at 15Car 3 starts refueling at 15Tanker arriving at 25Car 2 done refueling at 30Car 3 done refueling at 30 Stores 使用 Stores 可以对具体对象的生产和消费进行建模。单个 Store 甚至可以包含多种类型的对象。 APIs simpy.Store(env, capcity = ) simpy.Store.get() simpy.Store.put() simpy.PriorityStore() simpy.PriorityItem(priority, item) Example 3.7 一般生产者/消费者场景 123456789101112131415161718192021222324import simpydef producer(env, store): for i in range(100): yield env.timeout(2) yield store.put(f&#x27;spam &#123;i&#125;&#x27;) print(f&#x27;Produced spam at&#x27;, env.now)def consumer(name, env, store): while True: yield env.timeout(1) print(name, &#x27;requesting spam at&#x27;, env.now) item = yield store.get() print(name, &#x27;got&#x27;, item, &#x27;at&#x27;, env.now)env = simpy.Environment()store = simpy.Store(env, capacity=2)prod = env.process(producer(env, store))consumers = [env.process(consumer(i, env, store)) for i in range(2)]env.run(until=10) 查看结果 12345678910111213140 requesting spam at 11 requesting spam at 1Produced spam at 20 got spam 0 at 20 requesting spam at 3Produced spam at 41 got spam 1 at 41 requesting spam at 5Produced spam at 60 got spam 2 at 60 requesting spam at 7Produced spam at 81 got spam 3 at 81 requesting spam at 9 Example 3.8 PriorityStore 具有优先级的 Store。 inspector process 发现并记录单独的 maintainer process 按优先级顺序修复的问题。 1234567891011121314151617181920212223import simpyenv = simpy.Environment()issues = simpy.PriorityStore(env)def inspector(env, issues): for issue in [simpy.PriorityItem(&#x27;P2&#x27;, &#x27;#0000&#x27;), simpy.PriorityItem(&#x27;P0&#x27;, &#x27;#0001&#x27;), simpy.PriorityItem(&#x27;P3&#x27;, &#x27;#0002&#x27;), simpy.PriorityItem(&#x27;P1&#x27;, &#x27;#0003&#x27;)]: yield env.timeout(1) print(env.now, &#x27;log&#x27;, issue) yield issues.put(issue)def maintainer(env, issues): while True: yield env.timeout(3) issue = yield issues.get() print(env.now, &#x27;repair&#x27;, issue)_ = env.process(inspector(env, issues))_ = env.process(maintainer(env, issues))env.run() 查看结果 123456781 log PriorityItem(priority=&#x27;P2&#x27;, item=&#x27;#0000&#x27;)2 log PriorityItem(priority=&#x27;P0&#x27;, item=&#x27;#0001&#x27;)3 log PriorityItem(priority=&#x27;P3&#x27;, item=&#x27;#0002&#x27;)3 repair PriorityItem(priority=&#x27;P0&#x27;, item=&#x27;#0001&#x27;)4 log PriorityItem(priority=&#x27;P1&#x27;, item=&#x27;#0003&#x27;)6 repair PriorityItem(priority=&#x27;P1&#x27;, item=&#x27;#0003&#x27;)9 repair PriorityItem(priority=&#x27;P2&#x27;, item=&#x27;#0000&#x27;)12 repair PriorityItem(priority=&#x27;P3&#x27;, item=&#x27;#0002&#x27;) SimPy 学习 【学习笔记】SimPy 学习（一）：基础 【学习笔记】SimPy 学习（二）：进程交互 【学习笔记】SimPy 学习（三）：资源共享 【学习笔记】SimPy 学习（四）：实时模拟与时间调度 【学习笔记】SimPy 学习（五）：SimPy 版本迁移 【学习笔记】SimPy 学习（六）：监视","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"SimPy","slug":"notes/SimPy","permalink":"https://cs0522.github.io/categories/notes/SimPy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://cs0522.github.io/tags/Python/"},{"name":"SimPy","slug":"SimPy","permalink":"https://cs0522.github.io/tags/SimPy/"}]},{"title":"【文档小记】Atlantis JMVT 游戏车队交流平台","slug":"d-atlantis-project","date":"2023-10-25T13:19:17.000Z","updated":"2025-01-17T18:57:47.085Z","comments":false,"path":"docs/d-atlantis-project/","link":"","permalink":"https://cs0522.github.io/docs/d-atlantis-project/","excerpt":"记录了这个 Vue + SpringBoot 前后端项目开发的一些知识点以及解决方案","text":"记录了这个 Vue + SpringBoot 前后端项目开发的一些知识点以及解决方案 GitHub 项目地址 基本介绍 SpringBoot SpringBoot 是全新一代的 Spring 框架 开箱即用、预定优于配置、更轻量级 常用的第三方依赖整合（通过 Maven 子父工程的方式），简化 XML 配置，全部采用注解形式，内嵌 Web 应用容器 AOP 编程的支持（AOP 面向切面编程），功能增强，注解形式 IoC（Inversion of Control）控制反转 启动顺序 调用构造函数进行数据初始化 加载配置环境及上下文环境，返回应用配置上下文 vue MVVM 设计模式 V：视图 view ViewModel：一个同步 View 和 Model 的对象，连接 Model 和 View M：模型 model，在其中定义数据修改和操作的业务逻辑 双向数据绑定，通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的，因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上 MVC、MVVM 和三层架构 MVC（设计模式） MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新 MVVM Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步 三层架构（体系架构设计） 高内聚，低耦合 表现层、业务逻辑层、数据访问层（SpringMVC、Spring、MyBatis） 项目介绍 Atlantis Racer JMVT 网站是由游戏爱好者组建的 Atlantis Racer JMVT 车队的网站。该网站项目采用 Vue + SpringBoot 前后端分离技术，从 0 开始开发，90% 的功能或组件自主实现，其他功能或组件采用了第三方方案，引用了 Element-UI, github-markdown-css, mavon-editor, vuex 等。由于第一次接触 Vue 和 SpringBoot 等技术，边学习、边练习、边实践，因此项目中代码有很多地方冗余、复杂或有更为简单的方案实现，还能够继续优化。网站部署地址：http://atlantisracer.tk（挂）。 开发环境： Windows 11 + VSCode (前端、后端) + IDEA (后端) + Edge + Apifox (接口测试) + MySQL Workbench (数据库) + Git 前后端请求路径： 前端访问：localhost:8080 后端请求： localhost:8081/api localhost:8082/api（于 utils/baseUrl.js，controller/*/application.yml 下修改） 文件保存路径和数据库： 保存路径： 项目根目录 /Data/&#123;photos|article_pictures&#125;/（于 com/atlantis/common/ProjectPath.java 下修改） 测试用数据库： TestSamples_DB.sql 实际使用数据库： ForActualUse_DB.sql 实现的功能包括： 数据库表关系 路由关系 总结 这次的项目开发，我们学习到了很多如：前端 Web 语言如 HTML、JavaScript、CSS 等；后端的语言 Java；前端的主流框架 Vue 和后端的主流框架 SpringBoot 相结合进行前后端的分离开发等。这些都是在理论课的基础上，进行知识的拓展和应用，让我们更进一步地了解企业中开发一个项目的大体流程，是宝贵的经验。 项目遇到的问题及解决方案 组件固定于浏览器某一位置： 利用 position: fixed 属性固定。 1234567891011121314151617181920212223.top-bar&#123; /* 设置边框为圆角 */ border-radius: 15px; float: left; text-align: left; /* overflow: hidden; */ height: 150px; width: auto; /* top bar始终处于浏览器顶端 */ position: fixed; /* 设置top bar位置 */ top: 0cm; left: 1cm; right: 1cm; /* border: solid; */ /* 设置top bar背景色 */ background-color: rgba(252, 242, 241, 0.85); /* 设置top bar阴影 */ box-shadow: 5px 15px 15px 5px #888888; /* 设置层级为1000，最大 */ z-index: 1000;&#125; 禁止页面文字被复制： 12345678#box&#123; /* 设置全局文字不能被选中 */ -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125; 设置css作用范围： 12&lt;style scoped src=&quot;@/../public/css/personalpage-style.css&quot;&gt;&lt;/style&gt; （未解决）获取当前路由路径并映射为中文： 路由跳转后，页面不刷新： 给 router-view 设置 :key 属性，路由改变，就会重新渲染。 12345678&lt;template&gt;&lt;div id=&quot;app&quot;&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot; :key=&quot;$route.fullPath&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;/template&gt; 子组件（子路由）向父组件（父路由）传递参数： 通过事件进行绑定，发生某个自定义事件，绑定一个方法，参数通过方法传递。 123456789&lt;div id=&quot;dash-content-box&quot;&gt;&lt;!-- 注意这个地方一定要绑定key！！！以后也是！！！ --&gt;&lt;!-- 子组件传递参数，@绑定方法函数 --&gt;&lt;router-view v-if=&quot;isRouterAlive&quot; :key=&quot;$route.fullPath&quot; @reload=&quot;reload&quot; @show-dialog=&quot;showDialog&quot;&gt;&lt;/router-view&gt;&lt;/div&gt; 12345678doOperation(operation, contentType, objId) &#123; // 修改vuex中的state数据 this.$store.commit(&#x27;setOperation&#x27;, operation); this.$store.commit(&#x27;setContentType&#x27;, contentType); this.$store.commit(&#x27;setObjId&#x27;, objId); // 向父路由emit一个show-dialog事件 this.$emit(&#x27;show-dialog&#x27;, true)&#125; 兄弟组件（兄弟路由）数据通信： 使用 vuex 即可。需要注意 vuex 在页面刷新后数据丢失，因此不要存储登录相关数据。 1234567891011121314151617181920212223242526272829303132333435import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)const store = new Vuex.Store(&#123;// vuex里的store刷新页面后内容会丢失state: &#123; // 用于DashContent子路由和AccountDialog之间的数据通信 operation: &#x27;&#x27;, objId: &#x27;&#x27;, contentType: &#x27;&#x27;, // 保存CRUD操作类型，以及目标item的id // 登录成功后保存用户信息(X! vuex里的刷新后内容丢失) // accountInfo: &#123;&#125;, // isLogin: false, // loginType: &#x27;&#x27;, // admins, users&#125;,mutations: &#123; setOperation(state, newOperation)&#123; state.operation = newOperation; &#125;, setObjId(state, newId) &#123; state.objId = newId; &#125;, setContentType(state, newContentType) &#123; state.contentType = newContentType; &#125;,&#125;,&#125;)export default store 手动刷新子组件（子路由）： 给子组件（子路由）设置 v-if 属性。自刷新可利用 provide, inject 注入函数依赖。刷新函数利用 this.$nextTick(function() &#123;&#125;) 改变绑定 v-if 的boolean变量的值。 1234567&lt;!-- 父组件内 --&gt;&lt;TopBar v-if=&quot;!topBarReload&quot; @reload=&quot;doTopBarReload()&quot;&gt;&lt;/TopBar&gt;&lt;router-view v-if=&quot;isRouterAlive&quot; :key=&quot;$route.fullPath&quot; @reload=&quot;reload&quot; @show-dialog=&quot;showDialog&quot;&gt;&lt;/router-view&gt; 1234567891011121314151617181920212223242526272829303132data() &#123; return &#123; isShow: false, isRouterAlive: true, topBarReload: false, &#125;&#125;,// 刷新路由操作provide() &#123; return &#123; reload: this.reload, doTopBarReload: this.doTopBarReload, &#125; &#125;,// 刷新路由操作reload() &#123; this.isRouterAlive = false; this.$nextTick(function() &#123; this.isRouterAlive = true; &#125;)&#125;,// 刷新topbardoTopBarReload() &#123; this.topBarReload = true; this.$nextTick(function() &#123; this.topBarReload = false; &#125;)&#125;// 子组件内// 刷新路由操作，注入reload依赖inject: [&#x27;reload&#x27;], cors跨域： 后端设置Config类，或者设置过滤器类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// Config class@Configurationpublic class CorsConfig &#123; // 当前跨域请求最大有效时长。1天 private static final long MAX_AGE = 24 * 60 * 60; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.addAllowedOrigin(&quot;*&quot;); // 1 设置访问源地址 // corsConfiguration addAllowedOriginsPattern(&quot;*&quot;); corsConfiguration.addAllowedHeader(&quot;*&quot;); // 2 设置访问源请求头 corsConfiguration.addAllowedMethod(&quot;*&quot;); // 3 设置访问源请求方法 // corsConfiguration.setAllowCredentials(true); // 解决前后的session对象不一致问题 corsConfiguration.setMaxAge(MAX_AGE); source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration); // 4 对接口配置跨域设置 System.out.println(&quot;doing CORS config...&quot;); return new CorsFilter(source); &#125;&#125;// filter class. Need to add &#x27;ServletComponentScan&#x27; at Application class@WebFilter(filterName = &quot;requestFilter&quot;, urlPatterns = &#123;&quot;/*&quot;&#125;)public class RequestFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;doing request filter...&quot;); HttpServletResponse response = (HttpServletResponse) servletResponse; HttpServletRequest request = (HttpServletRequest) servletRequest; // 此处 setHeader、addHeader 方法都可用。但 addHeader时写多个会报错：“...,but only one is allowed” response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // response.addHeader(&quot;Access-Control-Allow-Origin&quot;, request.getHeader(&quot;origin&quot;)); // 解决预请求（发送2次请求），此问题也可在 nginx 中作相似设置解决。 response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with,Cache-Control,Pragma,Content-Type,Token, Content-Type&quot;); response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, PUT, DELETE&quot;); response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;); response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); String method = request.getMethod(); if (method.equalsIgnoreCase(&quot;OPTIONS&quot;)) &#123; servletResponse.getOutputStream().write(&quot;Success&quot;.getBytes(&quot;utf-8&quot;)); &#125; else &#123; filterChain.doFilter(servletRequest, servletResponse); &#125; &#125; @Override public void destroy() &#123; &#125;&#125; cors跨域后session id不一致： http://localhost:8080 或 http://172.16.12.103:8080 只能成功一个。在 application.yml 中配置 Tomcat 监听ip地址。 1234server:port: 8081# 内网ip, 部署后填入外网ipaddress: 172.16.12.103 12345678910111213141516171819202122232425@Configurationpublic class CorsConfig &#123; // 当前跨域请求最大有效时长。1天 private static final long MAX_AGE = 24 * 60 * 60; @Bean public CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration corsConfiguration = new CorsConfiguration(); System.out.println(&quot;doing CORS config...&quot;); // corsConfiguration.addAllowedOrigin(&quot;*&quot;); // 设置访问源地址 // corsConfiguration.addAllowedOriginPattern(&quot;**&quot;); corsConfiguration.addAllowedHeader(&quot;*&quot;); // 设置访问源请求头 corsConfiguration.addAllowedMethod(&quot;*&quot;); // 设置访问源请求方法 // corsConfiguration.setAllowCredentials(true); // 解决前后的session对象不一致问题 corsConfiguration.setMaxAge(MAX_AGE); source.registerCorsConfiguration(&quot;/**&quot;, corsConfiguration); // 对接口配置跨域设置 return new CorsFilter(source); &#125;&#125; 123456const request = axios.create(&#123; baseURL: &#x27;http://172.16.12.103:8081&#x27;, timeout: 5000, // 解决前后session不一致问题 withCredentials: true,&#125;) 模块开发： 利用maven的继承和聚合。建立父工程，只包含 pom.xml，修改打包方式为 pom、声明子工程、统一设置依赖版本号以及子工程版本号。子工程内将 &lt;parent&gt; 设为父工程，&lt;dependency&gt; 中的依赖具有传递性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- 父工程中 --&gt;&lt;!-- 修改打包方式 --&gt;&lt;packaging&gt;pom&lt;/packaging&gt;&lt;!-- 统一设置版本号 --&gt;&lt;properties&gt; &lt;java.version&gt;11&lt;/java.version&gt; &lt;atlantis.version&gt;0.0.1-SNAPSHOT&lt;/atlantis.version&gt; &lt;mybatis.version&gt;2.2.2&lt;/mybatis.version&gt; &lt;mysql.version&gt;8.0.30&lt;/mysql.version&gt; &lt;jackson.version&gt;2.13.4&lt;/jackson.version&gt; &lt;druid.version&gt;1.2.13-SNSAPSHOT&lt;/druid.version&gt;&lt;/properties&gt;&lt;!-- dependency中进行引用 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 声明子工程 --&gt;&lt;modules&gt; &lt;module&gt;controller&lt;/module&gt; &lt;module&gt;mapper&lt;/module&gt; &lt;module&gt;pojo&lt;/module&gt; &lt;module&gt;service&lt;/module&gt; &lt;module&gt;util&lt;/module&gt; &lt;module&gt;exception&lt;/module&gt; &lt;module&gt;common&lt;/module&gt; &lt;module&gt;config&lt;/module&gt; &lt;module&gt;filter&lt;/module&gt;&lt;/modules&gt;&lt;!-- 子工程版本号 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.atlantis&lt;/groupId&gt; &lt;artifactId&gt;mapper&lt;/artifactId&gt; &lt;version&gt;$&#123;atlantis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.atlantis&lt;/groupId&gt; &lt;artifactId&gt;pojo&lt;/artifactId&gt; &lt;version&gt;$&#123;atlantis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 代码重复，进行复用： 这个项目里，Java使用继承和泛型来减少代码重复；vue内主要重复的是axios请求，采用字符串拼接减少重复。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 关系：泛型ServiceImpl类实现泛型接口Service类。接口AdminService类继承泛型泛型接口Service类。AdminServiceImpl类继承泛型ServiceImp类，同时实现接口AdminService类。// BaseService&lt;T&gt;public interface BaseService&lt;T&gt; &#123; public T getById(Integer id); public List&lt;T&gt; getAll(); public boolean insert(T obj); public boolean update(T obj); public boolean updateInfo(T obj); public boolean updatePwd(T obj); public boolean delete(Integer id); public T login(T login);&#125;// BaseServiceImpl&lt;T&gt;public abstract class BaseServiceImpl&lt;T&gt; implements BaseService&lt;T&gt; &#123; @Autowired // 代理对象自动装配，SpringBoot无法识别 // userDao实例可能会报错，修改检查配置 // protected 子类可继承 protected BaseMapper&lt;T&gt; baseMapper; @Override public T getById(Integer id) &#123; return baseMapper.getById(id); &#125; @Override public List&lt;T&gt; getAll() &#123; return new ArrayList&lt;T&gt;(baseMapper.getAll()); &#125; @Override public boolean insert(T obj) &#123; return false; &#125; @Override public boolean update(T obj) &#123; return (baseMapper.update(obj) == 1); &#125; @Override public boolean updateInfo(T obj) &#123; return false; &#125; @Override public boolean updatePwd(T obj) &#123; return false; &#125; @Override public boolean delete(Integer id) &#123; return (baseMapper.delete(id) == 1); &#125; @Override public T login(T login) &#123; return null; &#125;&#125;// AdminServicepublic interface AdminService extends BaseService&lt;Admin&gt; &#123;&#125;// AdminServiceImpl// IoC容器管理对象@Servicepublic class AdminServiceImpl extends BaseServiceImpl&lt;Admin&gt; implements AdminService &#123; @Override public boolean updateInfo(Admin admin) &#123; return (baseMapper.updateInfo(admin) == 1); @Override public boolean updatePwd(Admin admin) &#123; return (baseMapper.updatePwd(admin) == 1); &#125; @Override public boolean insert(Admin admin) &#123; // 查询数据库发现没有同名用户 if (baseMapper.getByUsername(admin.getUsername()) == null) &#123; return (baseMapper.insert(admin) == 1); &#125; else &#123; return false; &#125; &#125; @Override public Admin login(Admin login) &#123; return (baseMapper.getByUsernameAndPassword(login.getUsername(), login.getPassword())); &#125;&#125; 1234567891011121314151617181920212223242526load() &#123; // 拼接字符串，减少代码重复 let typeStr = &#x27;&#x27;; if (this.type === &#x27;admin&#x27;) &#123; typeStr = &#x27;admins&#x27;; &#125; else if (this.type === &#x27;user&#x27;) &#123; typeStr = &#x27;users&#x27;; &#125; if (typeStr === &#x27;&#x27;) &#123; return; &#125; // getAll请求，获取所有 request.get(&quot;/&quot; + typeStr).then(res =&gt; &#123; if (res.code === code.GET_OK) &#123; this.items = res.data; &#125; &#125;).catch(err =&gt; &#123; console.log(err) this.$notify.error(&#123; title: &#x27;获取失败&#x27;, &#125;); &#125;)&#125;, 多个页面共用一个组件： 通过路径的变化，props 进行传参。props 内的参数JavaScript内无法直接获取，可以通过 watch 监听获得。 1234567891011121314151617181920// personal page router&#123; path: &quot;/personal&quot;, redirect: &quot;/personal/profile&quot;, component: Personal, // meta: &#123; // keepAlive: true // 需要缓存 // &#125;, // props: true, children: [ &#123; path: &quot;:type&quot;, component: PersonalContent, props: true &#125; ]&#125;// 组件内props: [&#x27;type&#x27;] setTimeOut() 延迟执行： 1234// 延迟 300ms 刷新子路由 setTimeout(() =&gt; &#123; this.reload(); // 执行方法 &#125;, 300); 用户头像上传下载： 利用 ElementUI 上传控件，并修改样式。 12345678910&lt;!-- 界面 --&gt;&lt;el-upload class = &quot;avatar-uploader&quot; :action = &quot;actionUrl&quot; :show-file-list = &quot;false&quot; :on-success = &quot;handleAvatarSuccess&quot; :before-upload = &quot;beforeAvatarUpload&quot;&gt; &lt;img v-if = &quot;imageUrl&quot; :src = &quot;imageUrl&quot; class = &quot;avatar&quot;&gt; &lt;i v-else class = &quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;/i&gt;&lt;/el-upload&gt; 1234567891011121314151617181920212223242526272829// 用户头像上传handleAvatarSuccess(res, file) &#123; this.imageUrl = &quot;http://localhost:8081/users/download/&quot; + this.userId; this.reload(); this.$notify.success(&#123; title: &#x27;头像更新成功&#x27; &#125;)&#125;,beforeAvatarUpload(file) &#123; if (file) &#123; console.log(&quot;uploading...actionUrl: &quot; + this.actionUrl); const postfix = file.name.split(&#x27;.&#x27;)[1] const isSizeOk = file.size &lt; (2 * 1024 * 1024); if ([&#x27;png&#x27;, &#x27;jpeg&#x27;, &#x27;jpg&#x27;].indexOf(postfix) &lt; 0) &#123; this.$notify.error(&#123; title: &#x27;头像仅支持 .png, .jpg, .jpeg 格式&#x27; &#125;) this.$refs.upload.clearFiles() return false &#125; if (!isSizeOk) &#123; this.$notify.error(&#123; title: &#x27;上传头像大小不能超过 2MB&#x27; &#125;) return false &#125; return file &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// basePath定义在 application.yml 配置文件中// 用户的头像上传@PostMapping(&quot;/upload/&#123;id&#125;&quot;)public Result upload(MultipartFile file, @PathVariable Integer id)&#123; System.out.println(&quot;uploading...&quot;); // 获取的file是临时文件，需要转存 File filePath = new File(basePath); // 若目录不存在，创建 if (!filePath.exists()) &#123; filePath.mkdirs(); &#125; // 获取原始文件名后缀 // String postfix = Objects.requireNonNull( // file.getOriginalFilename()).substring( // (file.getOriginalFilename().lastIndexOf(&quot;.&quot;))); // 根据id重新生成用户名 // 文件上传加入后缀 &#x27;.png&#x27; String fileName = &quot;userId_&quot; + id.toString() + &quot;.png&quot;; // 转存文件 try &#123; file.transferTo(new File(basePath + fileName)); &#125; catch (IOException e) &#123; throw new SystemException(&quot;upload failed&quot;, e, Code.SYS_ERR); &#125; return new Result(Code.UPLOAD_OK, (String)fileName, &quot;upload succeeded&quot;);&#125;// 用户头像下载@GetMapping(&quot;/download/&#123;id&#125;&quot;)public Result download(HttpServletResponse response, @PathVariable Integer id)&#123; try &#123; // 输入流读取文件内容 FileInputStream fis = new FileInputStream(basePath + &quot;userId_&quot; + id.toString() + &quot;.png&quot;); // 输出流写回浏览器 ServletOutputStream sos = response.getOutputStream(); response.setContentType(&quot;image/png&quot;); int len = 0; byte[] bytes = new byte[1024]; while ((len = fis.read(bytes)) != -1) &#123; sos.write(bytes, 0, len); sos.flush(); &#125; //close fis.close(); sos.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); return new Result(Code.DOWNLOAD_ERR, null, &quot;no user photo&quot;); &#125; return new Result(Code.DOWNLOAD_OK, basePath + &quot;userId_&quot; + id.toString() + &quot;.png&quot;, &quot;download succeeded&quot;);&#125; 分页查询： 利用 ElementUI 简化前端分页组件的开发；后端利用 page-helper 进行分页查询的业务层和控制层处理。 前端： 123456789&lt;!-- pagination --&gt;&lt;el-pagination style=&quot;zoom: 220%; margin-bottom: 20px&quot; @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; :current-page.sync=&quot;currentPage&quot; :page-size=&quot;pageSize&quot; layout=&quot;prev, pager, next, jumper&quot; :total=&quot;totalNumber&quot;&gt;&lt;/el-pagination&gt; 123456789101112.el-pager li&#123; background: none !important;&#125;.el-pagination .btn-next, .el-pagination .btn-prev&#123; background: none !important;&#125;.el-pagination button:disabled&#123; background: none !important;&#125; 123456789101112131415161718192021222324252627282930313233343536data() &#123; return &#123; // for pagination // 当前页 currentPage: 1, // 每页条数 pageSize: 10, // 数据总数 totalNumber: 0, &#125;&#125;,methods: &#123; // pagination // 页面条数修改时（没有设置这个功能） handleSizeChange(val) &#123; // console.log(`每页 $&#123;val&#125; 条`); &#125;, handleCurrentChange(val) &#123; console.log(&quot;val: &quot; + val); request.get(&quot;/&quot; + this.typeStr + &quot;/&quot; + this.currentPage + &quot;/&quot; + this.pageSize).then(res =&gt; &#123; if (res.code === code.GET_OK) &#123; // 根据res的返回结果进行赋值 this.items = res.data.list; this.totalNumber = res.data.total; console.log(&quot;currentpage after: &quot; + this.currentPage); console.log(&quot;total number: &quot; + this.totalNumber); &#125; &#125;).catch(err =&gt; &#123; console.log(err) this.$notify.error(&#123; title: &#x27;获取失败&#x27;, &#125;); &#125;) // console.log(`当前页: $&#123;val&#125;`); &#125;,&#125; 后端： 12345678910111213141516171819202122232425262728293031// BaseService interfacepublic interface BaseService&lt;T&gt; &#123; public PageInfo&lt;T&gt; getAllByPage(int pageNum, int pageSize);&#125;// BaseServiceImpl public abstract class BaseServiceImpl&lt;T&gt; implements BaseService&lt;T&gt; &#123; @Override public PageInfo&lt;T&gt; getAllByPage(int pageNum, int pageSize) &#123; PageHelper.startPage(pageNum, pageSize); List&lt;T&gt; baseList = baseMapper.getAll(); return new PageInfo&lt;T&gt;(baseList); &#125;&#125;// BaseControllerpublic abstract class BaseController&lt;T&gt; &#123; @GetMapping(&quot;/&#123;pageNum&#125;/&#123;pageSize&#125;&quot;) public Result getAllByPage(@PathVariable Integer pageNum, @PathVariable Integer pageSize) &#123; try &#123; PageInfo&lt;T&gt; pageInfo = baseService.getAllByPage(pageNum, pageSize); Integer code = pageInfo != null ? Code.GET_OK : Code.GET_ERR; String msg = pageInfo != null ? &quot;get succeeded&quot; : &quot;get failed&quot;; return new Result(code, pageInfo, msg); &#125; catch (SystemException e) &#123; throw new SystemException(&quot;unknown error occurred&quot;, Code.SYS_ERR); &#125; &#125;&#125; 搜索结果实时显示： 使用 watch: 对 &lt;input&gt; 输入值进行监听。 12345678910111213141516171819202122232425262728293031323334// 查询实时显示，watch监听watch: &#123; // 含输入的记得掐空格！！！ searchInput(val) &#123; if (val.trim() === &#x27;&#x27;) &#123; this.load(); return; &#125; // 延迟 0.2s 进行实时显示 setTimeout(() =&gt; &#123; request.get(&quot;/&quot; + this.typeStr + &quot;/&quot; + val.trim() + &quot;/&quot; + this.currentPage + &quot;/&quot; + this.pageSize).then(res =&gt; &#123; if (res.code === code.GET_OK &amp;&amp; res.data.total) &#123; this.items = res.data.list; this.totalNumber = res.data.total; &#125; else &#123; this.items = []; this.totalNumber = 0; this.$notify.error(&#123; title: message.FIND_ERR, &#125;) &#125; &#125;).catch(err =&gt; &#123; this.$notify.error(&#123; title: message.REQUEST_ERR, &#125;) &#125;) &#125;, 200); &#125;&#125;, 浮动元素导致父元素高度塌陷： 添加以下css: 1234567891011121314.father&#123;&#125;.son&#123; float: left;&#125;.father::after &#123;content:&quot;&quot;;/*清除浮动*/clear: both;/*确保该元素是一个块级元素*/display: block;&#125; localStorage过期时间： 封装了localStorage，在存储的同时将时间存进去。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// storage.jslet storage = &#123; /* * set 存储方法 * @ param &#123;String&#125; key 键 * @ param &#123;String&#125; value 值， * @ param &#123;String&#125; expired 过期时间，以毫秒为单位，非必须 */ set(key, val, expired) &#123; let obj = &#123; data: val, time: Date.now(), expired &#125; localStorage.setItem(key, JSON.stringify(obj)); &#125;, /* * get 获取方法 * @ param &#123;String&#125; key 键 */ get(key) &#123; let val = localStorage.getItem(key); if (!val) &#123; return val; &#125; val = JSON.parse(val); if (Date.now() - val.time &gt; val.expired) &#123; localStorage.removeItem(key); return null &#125; return val.data; &#125;, /* * remove 删除方法 * @ param &#123;String&#125; key 键 */ remove(key) &#123; localStorage.removeItem(key); &#125;,&#125;export default storage;// main.js 中使用import storage from &#x27;./utils/storage.js&#x27;Vue.prototype.$storage=storage;// Vue组件中this.$storage.set(&#x27;item&#x27;, item, 24 * 60 * 60); 解析 Markdown 字符串： 使用 vue-markdown 插件，并引入 github-markdown-css 文件。 123npm install vue-loader vue-template-compiler -Dnpm install --save vue-markdownnpm install github-markdown-css 12// main.jsimport &#x27;github-markdown-css/github-markdown.css&#x27; 12345678910111213// vue组件内import VueMarkdown from &#x27;vue-markdown&#x27;export default &#123; components: &#123; VueMarkdown // 注入组件 &#125;, data () &#123; return &#123; value: MarkdownData // value的值是要解析的markdown数据 &#125; &#125;&#125; 1234&lt;!-- vue组件内 --&gt;&lt;div class=&quot;markdown-body&quot;&gt; &lt;VueMarkdown :source=&quot;value&quot;&gt;&lt;/VueMarkdown&gt;&lt;/div&gt; 1234567/* 可以自定义样式 */.markdown-body&#123; color: #2c3e50; font-size: 30px; background-color: rgba(252, 242, 241, 0);&#125; mavon-editor 图片上传、回显： mavon-editor 使用方法：mavon-editor mavon-editor 图片上传：pictures-upload 自定义 imgAdd 事件，后端设置上传接口；回显时设置 URL 磁盘映射，直接通过 URL 访问磁盘文件。 1234567891011121314151617181920212223242526// 前端// 绑定@imgAdd event$imgAdd(pos, $file)&#123; // 第一步. 将图片上传到服务器. var formdata = new FormData(); formdata.append(&#x27;file&#x27;, $file); // request中的请求头是json格式，不方便 this.$axios(&#123; url: this.$store.state.newsArticleImgBaseUrl + &quot;upload&quot;, method: &#x27;post&#x27;, data: formdata, headers: &#123; &#x27;Content-Type&#x27;: &#x27;multipart/form-data&#x27; &#125;, timeout: 5000, // 解决前后session不一致问题 withCredentials: true, &#125;).then((res) =&gt; &#123; // 第二步. 将返回的url替换到文本原位置![...](0) -&gt; ![...](url) let result = JSON.parse(JSON.stringify(res)); // console.log(&quot;result: &quot; + result); if (result.data.code === code.UPLOAD_OK) &#123; this.$refs.md.$img2Url(pos, this.$store.state.newsArticleImgBaseUrl +&quot;download/&quot; + result.data.data); &#125; &#125;)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 后端// 上传，Controller层// 文章内图片上传@PostMapping(&quot;/upload&quot;)public Result upload(MultipartFile file)&#123; System.out.println(&quot;uploading...&quot;); // 获取的file是临时文件，需要转存 File filePath = new File(basePath); // 若目录不存在，创建 if (!filePath.exists()) &#123; filePath.mkdirs(); &#125; // 获取原始文件名后缀 String postfix = Objects.requireNonNull( file.getOriginalFilename()).substring( (file.getOriginalFilename().lastIndexOf(&quot;.&quot;))); // 重新命名 String fileName = GenerateMD5.encrypt(file.getOriginalFilename()) + postfix; // 转存文件 try &#123; file.transferTo(new File(basePath + fileName)); &#125; catch (IOException e) &#123; throw new SystemException(&quot;upload failed&quot;, e, Code.SYS_ERR); &#125; return new Result(Code.UPLOAD_OK, fileName, &quot;upload succeeded&quot;);&#125;// 下载，采用 URL 磁盘映射// WebMvcConfig@Configurationpublic class WebMvcConfig extends WebMvcConfigurerAdapter &#123; // basePath 通过 application.yml 注入，是磁盘上的绝对路径 @Value(&quot;$&#123;atlantis.articlePicturesBasePath&#125;&quot;) private String basePath; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(&quot;/newsArticles/download/**&quot;) .addResourceLocations(&quot;file:&quot; + basePath); &#125;&#125; &lt;div&gt; 元素内超过范围文字显示省略号: 12345678.div &#123; width: 60%; text-align: left; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125;","categories":[{"name":"文档小记","slug":"docs","permalink":"https://cs0522.github.io/categories/docs/"}],"tags":[{"name":"Atlantis JMVT","slug":"Atlantis-JMVT","permalink":"https://cs0522.github.io/tags/Atlantis-JMVT/"},{"name":"Vue","slug":"Vue","permalink":"https://cs0522.github.io/tags/Vue/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://cs0522.github.io/tags/SpringBoot/"},{"name":"WebSite","slug":"WebSite","permalink":"https://cs0522.github.io/tags/WebSite/"},{"name":"前端","slug":"前端","permalink":"https://cs0522.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"后端","permalink":"https://cs0522.github.io/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"【论文随记】230824_ThinRAID","slug":"l-thinraid","date":"2023-10-24T07:42:11.000Z","updated":"2025-01-17T18:57:47.101Z","comments":false,"path":"learnings/盘节能/l-thinraid/","link":"","permalink":"https://cs0522.github.io/learnings/%E7%9B%98%E8%8A%82%E8%83%BD/l-thinraid/","excerpt":"本文针对数据中心的能源消耗问题，根据数据集大小使用部分磁盘建立 RAID 以节省能源","text":"本文针对数据中心的能源消耗问题，根据数据集大小使用部分磁盘建立 RAID 以节省能源 ThinRAID: Thinning Down RAID Array for Energy Conservation DOI: 10.1109/tpds.2014.2360696 TPDS' 2014 简介 一句话总结 本文针对数据中心的能源消耗问题，根据数据集大小，使用部分磁盘建立小型 RAID。其他非必需磁盘被停转以节省能源；当建立的预测模型预测工作负载变高时，通过新提出的 ES 数据迁移算法，将常用数据将迁移到待启动磁盘上以减少数据迁移量，同时平衡活动磁盘的工作负载。 先前的工作 作者提到先前的节能工作包括：关闭 RAID 部分磁盘实现节能、采用多速磁盘进行磁盘减速、优化数据布局以及数据缓存等方案。关闭 RAID 部分磁盘可以实现节能，但关闭多个磁盘会降低 RAID 的磁盘并行性，还会产生新的问题如：不能直接访问条带的部分块，或同一条带的多个块存储在同一磁盘上，从而影响空间局部性，文章称其为：条带退化；还有的方案通过使用 Multi-speed 磁盘节能，因为磁盘在不同旋转速度下功耗不同，但因为会较大改变现有磁盘的磁头结构，在制造上存在困难，没有被广泛部署；EERAID 通过使其中一个磁盘关闭来节省能量，通过对活动磁盘中的块进行 XOR 来处理在休眠磁盘上的请求，当活动磁盘在低功耗模式下发生故障，数据就会不可用，因此 EERAID 会存在大额外开销以及低可靠性的问题；PARAID 可以归为上周讲的 Geared RAIDs 中，关闭一个磁盘就是换一档，通过改变活动磁盘的数量来节能，问题在于会破坏空间局部性（空间局部性 Spatial Locality：在最近的将来将用到的信息很可能与正在使用的信息在空间地址上是临近的；同一个条带的块在同一个磁盘上，访问这两个块将显著增加磁头移动的距离，从而导致条带退化。）以及导致额外的开销（大量数据迁移以及更新奇偶校验）。 创新点 而本文的 ThinRAID 的创新点在于，根据数据集的大小，用 RAID 的部分磁盘建立小型的 RAID，建立了预测模型，预测下一个阶段的工作负载以确定待启动的磁盘数量；然后新提出了一个数据重组算法，优先迁移具有更高热度的数据到待启动磁盘上，以最小化数据迁移的开销。 贡献 文章的贡献包括： 一种新的节能策略，即所有数据都将集中在磁盘的一部分，而其他磁盘则关闭电源以节省能源；高工作负载时，休眠磁盘将启动以服务高负载 固定条带宽度的 RAID 扩展方案，可以减少数据迁移和奇偶校验更新的次数。扩展后，原条带的宽度不变，迁移数据留下的空间用于构建新的条带（条带宽度就是磁盘的个数，横着的一行为一个条带） 一种功率控制策略，它确定了待启动磁盘的最佳数量，以在最低能耗的情况下保持峰值性能；一种高效的小型数据迁移算法（ES 数据迁移），最大限度地减少数据迁移，并确保所有活动磁盘之间的工作负载平衡 在 Linux 内核中实现，实验结果表明，与传统 RAID 相比，ThinRAID 可以节省 15-27% 的能耗；与 PARAID 相比，可以获得 62% 的性能改进 背景 文章的背景是一些对 PARAID 的分析和观察结果，以引出本文的 ThinRAID 的设计思路和目标。 PARAID 的主要思想是针对不同的工作负载级别，使用 RAID 中不同数量的磁盘，组织成不同的档位，以在不同的功率模式下运行，从而满足不同负载水平的需求。此外，活动磁盘上的可用空间用于存储待休眠磁盘的数据副本，从而能够关闭待休眠磁盘以节省能源。作者的观察结果表明，PARAID 性能下降的主要因素不是磁盘并行性降低，而是 RAID 条带退化。图 1 比较了传统架构的 4 磁盘 RAID-5 和 PARAID 在低速档（4 个活动磁盘和 2 个休眠磁盘）下的性能，控制两个 RAID 的磁盘并行性相同，对于两种工作负载，PARAID 的平均响应时间分别比 RAID-5 大 152% 和 120%，因此磁盘并行性不是性能下降因素；图 2 是条带退化影响 PARAID 性能的图示：由于其中一个磁盘将要休眠，因此该休眠磁盘上的数据将迁移到其他活动磁盘的空闲空间中，导致同一条带的数据块存储在了同一个磁盘上，从而产生了条带退化。例如：将 A4 副本迁移到 Disk0 后，同一条带的 A1 和 A4 存储在同一磁盘的不同分区上，因此，访问这两个块将显著增加磁头移动的距离，影响了空间局部性（空间局部性 Spatial Locality：在最近的将来将用到的信息很可能与正在使用的信息在空间地址上是临近的），从而导致条带退化。而 ThinRAID 则从具有固定条带分区的一小部分磁盘开始，当工作负载变大时，将高热度数据（常用数据）迁移到待启动磁盘上，无论在低功耗还是高功耗下，条带的宽度都不会大于活动磁盘个数，因此同一条带的块不会存储在同一块磁盘上，也就是 ThinRAID 通过构建更小的条带来避免条带退化。 于是作者对 ThinRAID 的设计目标包括：在性能方面，避免条带退化，保持峰值性能；在能源效率方面，使多个磁盘休眠，节省能源，同时仍能够满足性能要求；在可靠性方面，能够保留标准 RAID 的可靠性，构建一个随着系统利用率增长而线性扩展的 RAID 架构。 ThinRAID 设计 ThinRAID 可以用于不同的 RAID 编码方案（RAID0、1、10、5、6），本文主要讨论的是 RAID-5。 Capacity-Adaptive ThinRAID ThinRAID 能耗与活动磁盘数量有关，活动磁盘数量基于数据集的大小。每个磁盘容量为 1TB，初始数据集总量为 2.1TB，包括数据块和校验块。传统 RAID 会将所有数据分布到 RAID 每个磁盘中（如图 3a 所示），可能会导致磁盘容量和性能的低效使用。而 ThinRAID 不会过度分配存储资源，而是将所有数据集中在活动磁盘集合上，当负载较低时，其余磁盘可以关闭，从而节省整个存储系统的功耗。图 3b 显示了 ThinRAID 示例，使用三个磁盘构建 RAID。当需要扩展 RAID 架构时（比如添加新磁盘），ThinRAID 将使用下一页将会说明的固定条带宽度扩展方案来扩展磁盘以允许更多的空闲存储空间。如图 3a 所示，当数据集扩展到 3.2TB 时，传统 RAID 仍然将所有数据分布到所有 5 个磁盘上。ThinRAID 将使用 4 个磁盘，如图 3c 所示。扩容后，新旧块均匀分布到所有活动磁盘。 Preserving Peak Performance 图 4 展示了分别具有 6 个磁盘的传统 RAID 和 ThinRAID 的示例。图 4a 中，对于传统 RAID，条带宽度为 6，所有磁盘都处于活动状态。图 4b 中，ThinRAID 将所有数据集中在 4 个磁盘上，并且工作负载也集中在这 4 个磁盘上，条带宽度为 4，关闭其他两个磁盘以节省能源。工作负载变高时，休眠磁盘启动，如图 4c 和 4d，少量高热度数据通过数据迁移算法被迁移到新启动的磁盘上，并平衡工作负载以保证性能，但这些高热度数据仍然在原活动磁盘上留有副本，没有被覆盖（迁移后，块 20 的副本仍然存储在磁盘 D0 上）；工作负载变低时，多个磁盘准备休眠，待休眠磁盘中的高热度数据回传至活动磁盘。因为原活动磁盘中高热度数据的副本没有被覆盖，所以只有修改过的高热度数据才需要重新写回原活动磁盘，这样可以减少数据迁移量。如图 5 所示，块 9 和块 20 没有被修改过，因此不需要将它们重新写回原活动磁盘 D0 和 D1。 Fixed Stripe Width Scaling 用于向 RAID 阵列中添加新磁盘。考虑添加 N 个磁盘到 M 个磁盘的 RAID：RAID 传统扩展方法是在添加磁盘后基于 Round-Robin 来分配数据。但通过这种方式，条带宽度将扩展到 M + N，同时几乎所有的数据块都会被迁移，奇偶校验需要更新，导致开销很大；ThinRAID 的方案则是保持迁移后条带宽度不变，旧数据块留下的空间用于构建新的条带，因此，RAID 扩展后仍然具有M的条带宽度，且不需要更新旧奇偶校验。每个条带的迁移块的数量是有限的，不能超过新添加的磁盘数量。数据只从旧磁盘迁移到新添加磁盘，不可在旧磁盘之间进行数据迁移。图 6 显示了 ThinRAID 中从 4 个扩展到 5 个磁盘的示例。第 1 个条带，块 A1 迁移到新添加磁盘 Disk4；在迁移之后，包括块 A1、A2、A3 和 A4 的旧条带没有奇偶校验更新且仍然具有条带宽度 4，其他的条带也是如此。这些块留下的空间则用来构建新的条带。这个方案可以大幅减少数据迁移的开销，同时，由于迁移是基于特定规则的，因此可以通过规则公式来计算迁移块的地址，不需要额外的映射表。 Power Control Policy 首先使用了 ARMAX 模型来预测工作负载，得到下一个时间间隔内的平均请求到达率为 。 ARMAX 模型简介 AutoRegressive Moving Average with eXplanatory variable 模型是一种时间序列预测模型，用于描述和预测时间序列的特征值。该模型结合了自回归（AR）模型、滑动平均（MA）模型和外生变量（X）的影响。ARMAX 模型可以表示为： 其中， 为时间序列的依赖变量， 和 为 AR 和 MA 的滞后阶数， 表示常数项， 和 表示 AR 和 MA 模型的参数， 为外生变量， 表示外生变量的系数， 为误差项。ARMAX 模型可以用于预测时间序列中的未来值，并且可以考虑到外部变量对时间序列的影响。这使得 ARMAX 模型在许多领域的应用中非常有用，如经济学、金融学、工程等。 之后设计一个粗略的性能模型，假定每个请求访问给定磁盘的概率是 ，那么每个磁盘上的平均请求到达率为 。再根据 M/M/1 理论，计算每个磁盘的平均响应时间 t： 。 M/M/1 理论简介 M/M/1 理论是一种用于描述排队系统的数学模型。它指的是单个单服务器的排队系统，其中到达服务台的顾客遵循泊松到达过程，服务时间遵循指数分布。M/M/1 代表了三个参数：M 表示到达顾客的过程是泊松过程，即到达的顾客间隔时间是指数分布的；M 表示服务时间是指数分布的，即顾客的服务时间是随机的且满足整个服务过程内的完全独立性；表示只有一个服务台（服务器），顾客到达后会立即被服务，不会有其他服务器来帮助服务。 M/M/1 理论可以帮助我们分析排队系统的性能指标，如平均等待时间、系统均衡度等。它对于优化服务台资源的利用、提高系统效率以及预测系统的性能表现都有重要的参考价值。M/M/1理论中的平均逗留时间（Average Residency Time）可以通过以下公式计算： 其中， 是服务速率（即每个顾客的平均服务时间），单位为顾客/单位时间； 是到达速率（即单位时间内到达系统的平均顾客数），单位为顾客/单位时间。 最后将平均响应时 t 与限制的平均响应时间 、 进行比较，并在下一个时间间隔内确定活动磁盘的数量 n。算法 1 说明了功率控制策略。在第 2-5 行，如果预测的响应时间大于 ，意味着当前工作负载较高，则当前磁盘数由 动态添加，直到 t 小于 ；当 t 小于 时，意味着当前工作负载较低，将当前磁盘数减去 ，直到 t 大于 。 Data Reorganization ES 数据迁移算法。迁移的目标是将部分工作负载转移到待启动磁盘上，提高性能，需要满足的条件包括：只有相对少量的数据被移动；需要平衡数据迁移后所有活动磁盘之间的工作负载；不要引入条带退化。为了减少数据迁移量，将优先迁移相对热度更高的数据，因为根据现有研究表明，只有少量数据被频繁访问，而大量数据很少被访问。文中将数据热度定义为：在给定的时间段内访问数据的次数。根据时间局部性，在下一时间段不会发生太大变化。以下公式计算阈值 ，用于平衡工作负载：，其中块 热度 ，磁盘 热度 ， 待启动磁盘数， 当前活动磁盘数。作者构造了一个块热度表（CPT）以及 Rank Array（RA）以选择热度数据。CPT 描述了每个条带每个块的热度，RA 中存储了每个热度等级的块的热度之和。举例说明迁移算法的流程： CPT 表中列了每个条带每个数据块的热度值。K=2，有 2 个待启动磁盘。因此如图 a，首先查找 CPT 表，找到每个条带中热度最高的 2 个块，以绿色标明；然后将这些块以热度为标准进行分级，比如热度为 40，取他的十位数 4，因此归为 RA[4] 中；热度为 10，归为 RA[1] 中，之后计算每个 RA 区间的热度之和，存放在数组中，如图 b；通过上一步的能源控制策略计算阈值 T=288，之后从高阶到低阶查找块，也就是以右上角为原点，建立图 b 这样的坐标系，从右上的高阶往左下找，直到已查找的黄色块的热度之和将要超过阈值 T，而包括下一块的热度之和大于阈值 T；这些块就是需要迁移到待启动磁盘上的数据块，如图 8a，8b。最后需要平衡工作负载，也就是让各个磁盘的热度保持平衡，也就是热度差异不大，如图 8b，下面的 DA 数组保存了各个磁盘的热度，可以发现磁盘 D3 的热度明显小于其他磁盘，因此将其中部分数据块进行替代，也就是对比图 8b，图 9a，将 31 替换为 30，将 37 替换为 36。最终得到的平衡工作负载后的数据迁移结果如图 9b。 ThinRAID 架构 ThinRAID 在 Linux 上实现原型，用多个磁盘构建软件 RAID（软件 RAID，也称为操作系统级 RAID，是一种通过操作系统提供的软件实现的 RAID 技术。它使用操作系统的软件来管理多个磁盘驱动器，将它们组合成一个逻辑存储设备，提供数据的冗余性和性能。软件RAID不依赖于特殊的RAID控制器硬件，而是在操作系统内核中实现RAID的功能），ThinRAID 由运行在 User-level 的用户级监视器、预测器、功率控制器和运行在 Kernel-level 的内核级监视器、数据重组处理器和地址映射 6 个模块组成。blktrace 直接向块层发出请求，用户级监视器记录 blktrace 发出的 I/O 请求，I/O 信息收集并发送给 Predictor；Predictor 从监视器获得的 I/O 信息作为输入，并预测下一个时间间隔的工作负载；Power Controller 根据预测的工作负载和设定的平均响应时间限制 和 确定需要转换的磁盘数，算法策略在之前说明了；内核级监视器收集内核层的所有磁盘工作负载信息，应用程序发出的请求到达 ThinRAID 层，然后监视器收集 I/O 请求；数据重组处理器在磁盘的状态转换开始之前操作，在磁盘之间移动少量数据，以便在磁盘之间实现均衡负载并满足性能目标，采用 ES 数据迁移算法和固定条带宽度扩展方案对数据布局进行优化；最后 Address Mapping 就是对数据迁移后的地址重新映射，转发请求到相应的磁盘。 实验评估 之后是实验部分（首先评估了 ThinRAID 和 RAID-5 的能耗，然后比较了它们之间的性能；为了评估不同的布局及其对节能和性能的影响，我们将 ThinRAID 与 PARAID 进行了比较。最后，评估了迁移算法和预测模块的影响）。 表 1 是实验的硬件参数，使用 6 个磁盘，4 个活动磁盘和 2 个休眠磁盘，4 个活动磁盘是低功耗，6 个活动磁盘是高功耗。设定 为 2（磁盘增减数为 2/次）。图 11 是搭建的用来测量磁盘功率的框架，包括存储服务器、数据收集服务器以及功率分析仪。表 2 总结了实验中采集了 7 种工作负载 traces 以及他们的负载特征，每个工作负载的 trace 周期为 168 小时（1 周）。Benchmark 为 RAID-5、PARAID、Round-Robin、Perfect Traffic Prediction。首先是能源消耗。表 3 展示了 7 个工作负载下的模式切换数据，包括切换次数和低功耗的时间比例。 图 12a 和图 12b 分别是 ThinRAID 和 RAID5 在两种工作负载下的功耗对比图：ThinRAID 可以快速在低功耗和高功耗模式之间切换，低功耗模式时，可以节能约 30%。 图 13 显示了 7 个 traces 下与 RAID-5 功耗的比较。ThinRAID 可以在各种 traces 下提供 15%-27% 的节能，其中 web trace 下节能最少，因为 web 条件下需要处理更多的 I/O，工作负载高，且由表 3 可以看出 web 的模式切换次数最多，低功耗的时间最少。 然后是性能影响。图 14 比较了 ThinRAID 和 RAID-5 两种 traces 下的平均响应时间。ThinRAID 的平均响应时间都比 RAID-5 略高，因为 ThinRAID 在低功耗模式下只将工作负载分布在 4 个磁盘上；有时 ThinRAID 的响应时间比 RAID-5 低，因为迁移到待启动磁盘上的少量数据分布比较靠近且集中，减少了寻道时间，并且高功耗模式下，磁盘并行性与 RAID-5 相同；图 15，对于每个 trace，RAID-5 在响应时间方面略优于 ThinRAID，原因在于功耗模式的切换，低功耗模式下 ThinRAID 的磁盘并行性低于 RAID-5；在 web trace 下差距最大，因为 web 有更多负载峰值，功耗模式切换最频繁，导致 web 预测精度最低，性能下降较大。 之后是数据布局的影响。如图 16a，平均响应时间上 ThinRAID 比 PARAID 性能有大幅提高达 25-62%；如图 16b，ThinRAID 节能效果略好于 PARAID，主要原因是 PARAID 的条带退化增加了磁头的移动距离，且 PARAID 中的奇偶校验更新会产生大量额外开销。 在迁移算法的影响上，评估了三种方案：PARAID 的迁移策略、Round Robin 调度迁移和本文 ES 迁移算法。PARAID 迁移策略，将带关闭磁盘中的所有数据迁移到活动磁盘的空闲空间，然后只有修改过的块才会被写回；对于Round Robin 调度中迁移的块是按照条带数量的递增顺序和磁盘数量的循环顺序选择。例如，如果我们在系统中使用 N 个磁盘，那么我们期望选择的第 i 个区块位于第 i 个条带和第 j 个（j = i mod N）磁盘上。如图 17 所示，与其他两个方案相比，ES 迁移算法迁移的块更少；如图 18，将 ThinRAID 迁移策略分别设置为 ES 迁移算法和 Round-Robin 调度算法，ES 数据迁移算法在大多数 traces 下性能较好，因为在 ES 迁移算法中迁移的数据在待启动磁盘上分布集中且靠近，减少了寻道时间。最后是预测的影响。图 19a 显示了七个工作负载下的预测准确性。大约 90% 的情况下，预测误差小于 1，70% 小于 0.3。结合图 19a 和表 3，预测精度的高低与功耗模式切换次数大致成反比，次数越多，预测精度越低，说明 I/O 请求分布越平稳，预测精度越高。预测误差对性能的影响如图 19b，说明了预测精度对性能下降的影响不大，其中 web 负载影响最大，原因在于存在很多负载峰值，切换功耗模式频繁，导致预测不准确。 总结 本文工作是针对数据中心的能源消耗问题，根据数据集大小使用部分磁盘建立 RAID 以节省能源，核心思路是建立模型对工作负载进行预测确定待启动磁盘个数，优先迁移高热度数据至待启动磁盘减少迁移开销，最后替换部分数据块以平衡活动磁盘工作负载。未提及的点我认为有 Power Control Policy 中的粗略性能模型条件设置为理想情况，未考虑影响因素（比如到达率大于等于服务率，则不能计算）；未给出限制平均响应时间 ， 的设定条件和设定值；平衡活动磁盘工作负载时如何选择替换数据块的方法不明确；如果刚开始时是全部磁盘启动，也就是高功耗模式，如何优化 RAID 活动磁盘的缩减避免条带退化等。本文启发是在初始分配资源时，根据数据大小分配资源，不过度分配导致浪费；还可以考虑利用时间局部性和空间局部性原理进行针对性优化。","categories":[{"name":"论文随记","slug":"learnings","permalink":"https://cs0522.github.io/categories/learnings/"},{"name":"盘节能","slug":"learnings/盘节能","permalink":"https://cs0522.github.io/categories/learnings/%E7%9B%98%E8%8A%82%E8%83%BD/"}],"tags":[{"name":"论文","slug":"论文","permalink":"https://cs0522.github.io/tags/%E8%AE%BA%E6%96%87/"},{"name":"盘节能","slug":"盘节能","permalink":"https://cs0522.github.io/tags/%E7%9B%98%E8%8A%82%E8%83%BD/"},{"name":"RAID","slug":"RAID","permalink":"https://cs0522.github.io/tags/RAID/"},{"name":"数据迁移","slug":"数据迁移","permalink":"https://cs0522.github.io/tags/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/"}]},{"title":"【论文随记】230817_SRCMap","slug":"l-srcmap","date":"2023-10-24T06:42:00.000Z","updated":"2025-01-17T18:57:47.089Z","comments":false,"path":"learnings/盘节能/l-srcmap/","link":"","permalink":"https://cs0522.github.io/learnings/%E7%9B%98%E8%8A%82%E8%83%BD/l-srcmap/","excerpt":"本文针对数据中心的能源消耗问题，通过设计存储虚拟化层实现一个能源比例存储系统","text":"本文针对数据中心的能源消耗问题，通过设计存储虚拟化层实现一个能源比例存储系统 SRCMap: Energy Proportional Storage using Dynamic Consolidations DOI: 10.5555/1855511.1855531 FAST' 2010 简介 一句话总结 本文针对数据中心的能源消耗问题，通过动态的存储合并和设计存储虚拟化层实现一个能源比例存储系统。SRCMap中SRC分别表示Sample（采样），Replicate（复制）以及Consolidate（整合），也就是对每个卷进行采样，确定其工作集，然后复制这些工作集到其他卷，并在低负载时将I/O工作负载按比例整合到相对较少的活跃卷上。 设计目标 存储系统的设计目标包括：细粒度能源比例、低空间开销、可靠性、工作负载转换适应以及异构性支持等。 细粒度能源比例具有多级 performance-power 水平，它满足这个式子：当工作负载为 的时候，功耗为 ，则当工作负载为 时，功耗为 的 ，也就是成比例的。 需要尽量减少空间开销。 可靠性则需要确保在磁盘的预期寿命期间产生的磁盘启动循环次数明显小于制造商指定的最大启动循环数，也就是要保证磁盘寿命。 工作负载转换适应则是指，活跃数据会随着时间的推移而发生变化，需要确保系统也能够随着活跃数据的变化而发生变化，并保持能源比例的特性。 异构性支持则指的是数据中心通常由几个基本不同的存储系统组成（例如，具有不同数量和类型的驱动器）。理想的能量比例存储系统应考虑其性能功率比的差异，以在每个主机级别提供最佳性能。 先前工作 先前的工作包括：单个冗余、Geared RAIDs、Caching Systems 以及 Write Offloading 等。 单个冗余方案的核心思想是在低 I/O 负载期间关闭具有冗余数据的磁盘，但是这种方案的局限性在于无法实现能源成比例的问题；Geared RAIDs 基于奇偶校验的 RAID 的换档机制（每关闭一个磁盘代表一个换档）。要在存储 X 的 N 磁盘阵列中实现 N−1 档，需要 O(X log N) 空间，即使我们忽略了存储奇偶校验信息所需的空间，但是问题在于会产生较大的空间开销，并且它们不能处理由具有不同 I/O 工作负载强度的多个卷组成的异构存储系统；Caching Systems 的主要思想是将活跃数据缓存在额外的存储（额外磁盘，闪存等）上，以关闭主驱动器，问题在于不能提供细粒度能源比例，且只有在 I/O 负载较低并且缓存能够提供服务时才能够节省能源，且没有考虑频繁的磁盘启动关闭可能对可靠性产生影响；Write Offloading 则是将写操作进行重定向卸载到不同的磁盘以增加空闲时间，但磁盘的频繁启动会潜在影响可靠性，且没有明确指明哪个活跃 disk 是非活跃 disk 的卸载目标，而 SRCMap 解决了这个问题。表中可以看出大部分方案只能满足其中几个设计目标，并且都无法完全满足能源成比例的目标，而 SRCMap 则能够实现这 5 个目标。 创新点 SRCMap 的创新点在于，作者考虑到服务器的虚拟化整合方案（利用异构性在任何时间选择最节能的服务器；利用低开销的实时虚拟机迁移来根据工作负载变化改变活跃服务器的数量；通过允许活跃服务器的数量一次增加或减少一个来提供对功耗的细粒度控制），它通过把工作负载集中在一部分物理卷上，使存储系统的能源消耗与 I/O 工作负载强度成比例。SRCMap 通过对每个卷进行采样得到工作集，并将工作集在其他物理卷上进行复制来实现。在给定的合并间隔内（SRCMap 系统进行一次合并操作的时间间隔。这个间隔通常被设置为 2 小时，目的是限制磁盘驱动器的最坏情况启动次数），SRCMap 仅激活最少量的物理卷来处理工作负载，同时让其他卷休眠，并把它们的工作负载重定向到活跃卷上的活跃副本。SRCMap 能够在 N 个卷上实现接近 N 级功耗-性能水平，实现存储能源消耗与 I/O 工作负载强度成比例。 存储工作负载特性 接下来作者使用了 3 个生产系统来观察 I/O 工作负载的性质，包括一个 email 服务器（mail 工作负载）和一个运行两个 Web 服务器（web-vm 工作负载）和一个文件服务器（home 工作负载）的虚拟机。作者进行了为期 3 周的观察，得到 4 个观察结果。（1）作者在每个系统中收集了 I/O 跟踪数据，得到了平均每周的统计数据，其中每周工作集（一周内 unique accesses）是总体积大小（1.5 - 6.5%）的小部分，并且这种趋势在所有卷中一致，因此可以得到第 1 个观察结果：活跃数据集通常是总使用存储的一小部分；（2）之后作者用图 1 分别展示了三个工作负载的负载强度，可以发现在最低工作负载和最高工作负载强度级别之间可以高达 5-6 个数量级，因此第 2 个观察结果为：磁盘 I/O 工作负载强度存在显着差异，并且可以反应存储系统可以按能源比例进行节能的潜力；（3）之后作者对数据使用情况进行了研究，作者提出了一个假设：通过在具有多余带宽的其他卷上复制小型活跃工作集，可以关闭利用率明显不高的物理卷。作者通过研究卷的工作集稳定性来验证这一假设。研究使用了三种不同的工作集定义（在第一个场景中，根据近期访问历史计算经典工作集；在第二个场景中，假设可以卸载写操作，并将所有写操作标记为命中；在第三个场景中，进一步扩展了工作集，包括最近的写操作和过去错过的读操作），并计算了命中率。观察结果显示，数据使用表现出高度的时间局部性，并且包含最近访问的工作集相对稳定，因此得出第3个观察结果：超过 99% 的工作集，由一些“非常活跃”数据和“最近访问”数据组成；（4）最后，研究了一种更简单的写卸载技术对构建能源比例存储系统的适用性。作者发现写卸载可以使卷的空闲时间占比大约为 79%，但却会导致需要频繁地开启和关闭磁盘驱动器，从而降低了可靠性，因此需要开发新的技术来显著增加平均读空闲时间持续时间。（图3展示了三个工作负载的读空闲时间分布情况。观察结果显示，home 和 mail 工作负载的空闲时间持续时间都小于等于 2 分钟，而 web-vm 工作负载则大部分小于等于 5 分钟但全部小于 30 分钟）。 观察结果 1 活跃数据集通常是总使用存储的一小部分 观察结果 2 存储卷的 I/O 工作负载强度存在显著差异 观察结果 3 超过 99% 的工作集，由一些“非常活跃”数据和“最近访问”数据组成 观察结果 4 I/O 工作负载的读取空闲时间分布主要由小持续时间（通常小于5 min）主导 SRCMap 设计决策 SRCMap 运行在 torage Virtualization Manager 上，存储虚拟化管理器可以通过在数据中心中提供不同存储资源的统一视图来简化存储管理，虚拟磁盘称为 vdisks，物理磁盘成为 mdisks，且对只查看逻辑 vdisk 卷的主机来说完全透明，虚拟化层的一个特性是能够完全灵活地将 mdisk 扩展分配给 vdisk。SRCMap 使用存储虚拟化层作为 I/O 重定向机制，提供了一种实际可行的能源比例解决方案，并且因为在虚拟化层，它不会改变底层物理卷（如 RAID）控制器的基本属性。以下是 SRCMap 的几个设计决策。 设计决策 1 - 多重复制目标 细粒度能源比例性能需要能够一次一个地增加或减少活跃物理卷数量的灵活性，在 SRCMap 中，作者为每个 vdisk 创建一个主 mdisk，并在多个辅助 mdisks 上仅复制每个 vdisk 的工作集。这确保了每个 vdisk 都可以被转移到多个目标 mdisks 中的一个上，并且每个目标 mdisk 可以为多个 vdisks 提供 I/O 工作负载。高负载期间，每个 vdisk 将映射到它的主 mdisk，所有 mdisks 都处于活跃状态；低负载期间，SRCMap 会按比例选择一小部分 mdisks，这些子集可以支持所有 vdisks 的聚合 I/O 工作负载。 设计决策 2 - 采样 创建多个 vdisks 的完整副本是不可行的，因为空间开销很大。根据观察结果1（活跃数据集通常是总使用存储的一小部分），SRCMap 通过仅对每个 vdisk 的工作集进行采样并复制工作集，来大大减少维护多个副本的空间开销。由于工作集通常不大，因此空间开销很低。 设计决策 3 - 有序副本放置 虽然“采样”有助于减少副本大小，但为每个样本创建多个副本仍然会导致较大空间开销。作者观察到并非所有的副本价值都是一致的：例如，复制轻负载卷比复制重负载卷更有利，因为重负载卷可能经常处于活跃状态（那么复制重负载卷的益处不大）；大工作集需要更多空间开销，因此 SRCMap 会选择创建更少副本并尽可能保持其活跃状态。因此按照某种属性来排序副本有助于最小化活跃磁盘数量，实现细粒度能源比例。 设计决策 4 - 动态源到目标映射和双数据同步 根据观察结果 2，工作负载可能在一段时间内有很大的变化。因此，无法事先确定哪些卷需要处于活跃状态，磁盘关闭时用于任何卷的目标副本选择必须是动态的决策。SRCMap 使用两种机制来更新副本：对于活跃副本，在读取失败的情况下立即进行同步，确保活跃副本不断适应工作负载的变化；对于辅助副本，在主副本和活跃 mdisks 上的任何辅助副本之间使用延迟、增量的后台数据同步。这确保了在副本之间切换只需要最少的数据复制，并且能够很快执行。 设计决策 5 - 粗粒度电源循环 它指的是 SRCMap 实现粗粒度的整合间隔（以2小时为间隔单位），在此期间，SRCMap 选择的活跃 mdisks 不会改变。与现有的大多数依赖细粒度磁盘电源模式切换的方案相比，确保了正常的磁盘寿命，提高了可靠性。 SRCMap 架构 组件 Load Monitor 负载监视器 它记录在虚拟化层 vdisk 上的数据访问，并提供两个接口，分别是由复制放置控制器调用的长期工作负载数据接口和由活跃磁盘管理器调用的预测短期工作负载数据接口。 Replica Placement Controller 副本放置控制器 副本放置控制器控制采样和在一个或多个目标磁盘上复制的过程，并在 Replica Disk Map（RDM）中存放工作集与 mdisks 映射关系。 Active Disk Manager 活跃磁盘管理器 在 SRCMap 中管理 Consolidation 步骤。该模块将每个 vdisk 的工作负载强度作为输入，并确定是否可以通过将工作负载重定向到承载其副本的辅助 mdisk 之一来关闭主 mdisk。确定了活跃 mdisks 和活跃副本后，活跃磁盘管理器就会同步已确定的活跃主副本或活跃辅助副本，并更新存储虚拟化管理器的虚拟到物理映射，以便可以重定向 I/O 请求。之后活跃磁盘管理器使用一致性管理器进行同步操作。 Consistency Manager 一致性管理器 它确保主 mdisk 和副本之间的一致性。在关闭一个 mdisk 并激活一个新副本之前，将新的活跃副本与前一个副本保持一致。为了确保重新同步期间的开销最小，活跃数据（主mdisk或活跃副本之一）与相同数据的所有其他副本之间维护增量关系，定期在他们之间执行同步操作，这样当关闭或激活一个 mdisk 时，能够使需要同步的数据量很小。 Replica Manager 副本管理器 复制副本管理器确保 vdisk 的复制副本数据集能够 vdisk 的工作集变化而变化。如果读取了 vdisk 的活跃副本上不可用的块，导致 Replica Miss，则复制副本管理器会将该块复制到分配给活跃副本的 Replica space，并相应地将该块添加到副本元数据中。最后，在分配给副本的 Replica space 已满的情况下，副本管理器使用最近最少使用（LRU）策略来收回较旧的块；如果活跃数据集发生剧烈变化，则可能会出现大量复制副本未命中。所有这些 Replica Miss 都可以通过主 mdisk 的一次启动来处理。获得新工作集中的所有数据后，主 mdisk 就可以关闭，因为活跃副本现在是最新的。副本元数据的持续更新使 SRCMap 能够满足工作负载转换适应的目标，而无需重新进行的副本生成流程（流程 A）。只有在发生中断性更改时（如向卷添加新工作负载、新卷或新磁盘），复制副本生成流程才需要重新运行。 控制流 the replica generation flow（A） 副本生成流（流 A）采样每个 vdisk 的工作集，并将其复制到多个 mdisks 上。此流程由副本放置控制器控制，当 SRCMap 初始化以及配置更改（例如，添加新工作负载或新磁盘）发生时会触发一次。副本放置控制器会从负载监视器获取历史工作负载跟踪，并计算每个 vdisk 工作集和长期工作负载强度。然后将工作集复制到一个或多个 mdisks 上。工作集和目标 mdisks 的映射关系保存在 RDM 中。 the active disk identification flow（B） 活跃磁盘标识流（流 B）在时间段 T 内标识活跃 mdisks 和每个非活跃 mdisk 的活跃副本。该流在合并间隔 T 开始时触发（例如，每 2 小时），并由 Active Disk Manager 管理。Active Disk Manager 向负载监视器查询周期 T 中每个 vdisk 的预期工作负载强度，然后标识活跃 mdisk 和每个非活跃 mdisk 的活跃副本，通过一致性管理器维护一致性，并更新虚拟到物理映射，以将工作负载重定向到适当的 mdisk。 the I/O redirection flow（C） I/O 重定向流（流 C）用于将 I/O 请求重定向到主副本或活跃副本。确保每个 vdisk 的工作集保持最新，并能够处理 Replica Miss 等情况。 算法 之前提到作者认为所有创建的副本都有不同成本和效益，如果 vdisk 工作集较小的话，则创建副本的空间成本较低；如果 vdisk 工作集稳定且平均负载较小，则可以很容易在目标 mdisk 上找到空闲带宽。因此，两个算法的目标都是确保为具有更高成本效益比的 vdisks 创建更多副本。 Replica Placement Alogorithm Replica Placement Alogorithm 副本放置算法的目标是如果活动磁盘管理器决定关闭 vdisk 的主 mdisk，则它需要能够找到至少一个承载其副本的活动目标 mdisk，并且保持顺序性 Ordering Property。顺序性指的是对于任意两个 vdisk 和 ，在 Active Disk Identification 的任意时间点 t，如果 更需要一个目标副本，那么在同一时间点 t， 比 更有可能在活跃磁盘中找到一个目标副本。副本放置算法包含以下几个步骤。首先是“初始 vdisk 排序”，基于它们的成本-收益权衡在 vdisks 之间创建一个排序的顺序。对于每个磁盘 ，计算它的主磁盘 被关闭的概率 ： 其中 是可调权重， 是 的工作集大小， 是 的主 mdisk 的性能-功率比（峰值 I/O 带宽与峰值功率之间的比率）， 是 的平均长期 I/O 工作强度（以 IOPS 为单位）， 是 的工作集中 read miss 的次数，由其主 mdisk 的主轴数归一化（常见的磁盘主轴数有单盘面和双盘面）。而 指的是所有 vdisks 上的最小值。这个概率公式的基本思想是，较小的工作负载更容易找到目标 mdisk，并且关闭耗电量较高的 mdisk 可以节省更多功耗； 第 2 步是“二部图创建”，创建一个二部图 G(V → M)，每个 vdisk 作为源节点 ，其主 mdisk 作为目标节点 ，边缘权重 e(, ) 表示将 的副本放置在 上的成本效益权衡，如图 5。二部图中的节点使用 进行排序（$P_i$ 较大的磁盘位于顶部），初始化每个边缘（, ）（源-目标对）的边缘权重 。刚开始阶段不对目标 mdisk 进行副本分配。之后副本放置算法迭代执行之后的两个步骤，直到目标 mdisk 上的所有可用 Replica space 都已分配，且在每次迭代中，只分配一个目标 mdisk 的 Replica space；第 3 步是“源-目标映射”，算法选取 Replica space 尚未分配的最顶层目标 mdisk ，并选择一组最高权重的边，该组边中源节点的组合副本大小填充 中可用的 Replica space（例如， 和 的工作集在图 5 中 的副本空间中复制）。目标 mdisk 上的 Replica space 被填满后，目标 mdisk 标记为已分配。该过程总是优先考虑具有较大 的源节点，当 mdisk 得到一个副本，它需要另一个副本的可能性就会降低，因此之后需要“重新调整边缘权重”，假设 vdisk 的工作集已经被复制到一组目标 mdisks 中，＝（$M_{least}$ 是 $T_i$ 中 $P_i$ 最小的 mdisk）。如果一组目标 mdisks 中的某个 mdisk 停止运行，那么有可能需要分配一个新的目标 mdisk。在活跃磁盘识别期间， 需要一个新目标 mdisk 的概率等于 和 都关闭的概率，为了保留排序性 Ordering Property，因此有以下式子：（k 应该指的是新的目标 mdisk，而 j 指的是停止运行的目标 mdisk） 重新计算了权重后，从源-目标映射步骤再开始迭代，直到所有副本都分配给了目标 mdisks。 Active Disk Identification 目标是识别出活跃 mdisks 和活跃副本。首先是“活跃 mdisk 选择”，使用前一个间隔期（指两次磁盘调度之间的时间间隔）内 vdisk 的工作负载作为下一个间隔期内 vdisk 的预测工作负载。并将所有 vdisks 的预测工作负载之和作为预期聚合负载，使用此预期聚合负载来识别最小的一组 mdisks（按照 的逆序排列），且这些 mdisks 的聚合带宽超过预期聚合负载； 第 2 步是“活跃副本识别”，为每个非活跃 mdisk 在一个活跃 mdisk 上标识一个副本，以处理从非活跃 mdisk 重定向的工作负载，并且使具有较大 的主 mdisks 处于关闭，并将其工作负载重定向到具有较小概率 的少量 mdisks，因此为每个非活跃主 mdisk 在其中一个活跃 mdisk 上，识别一个活跃副本。Replica Placement 过程为可能被停转概率更大的 vdisk 创建的副本，且具有较大概率 的主 mdisk 可能会在较长时间内处于关闭状态，因此首先让较小概率 的非活跃主 mdisk 寻找一个活跃副本，之后较大概率 的非活跃主 mdisk 的副本则位于具有较小概率 的活跃 mdisks 上。如图 6 中，vdisk 有第一选择承载其 replica 的活跃mdisk ，具有较大概率 的非活跃 mdisk 被映射到具有较小概率 的活跃 mdisk上（ 被映射到 ）。由于具有最小概率 的 mdisk 很可能一直保持活动状态，所以非活跃 mdisk 几乎不需要频繁切换活跃副本； 最后就是进行“迭代”，若成功找到所有非活跃 mdisks 的活跃副本，则算法终止；否则，活跃 mdisk 数量加 1，算法重复执行活跃副本识别步骤。 实验评估 作者使用了两组实验进行评估，一个使用基于 SRCMap 的存储虚拟化管理器原型，另一个使用植入原型的能量模拟器。使用的工作负载包括对8个独立数据卷的 I/O 请求，每个数据卷映射到一个独立的磁盘驱动器（如表 3，包括平均工作负载能力和最大工作负载能力）。Testbed 是一个单机 Intel Pentium 4 HT 3GHz，内存 1 G，通过 SATA-II A 和 B 连接 8 个磁盘（如图 8，展示了整个实验设置）；测试的 Baseline 包括：（Prototype 下）没有进行任何合并操作且所有磁盘一直处于活动状态；（Simulator 下）是 Caching-1、Caching-2、Replication 这三个对比方案。所有实验的配置参数包括：Consolidation 间隔设置为 2h，以保证磁盘可靠性；非活跃磁盘，使用了 2min 超时时间，超过 2min 会被关闭；在一个 Consolidation 间隔内，活跃 mdisk 保持持续活动；工作集和副本是基于三周的工作负载数据创建，因此为了简洁，作者报告了随后 24 小时的持续时间结果。作者使用 5 个 IOPS 估算等级（L0 到 L4），以模拟不同负载因子下的 Testbeds ，表 4（a）中提供每个卷在不同登记下的可持续 IOPS，活跃 mdisk 数量不同时存储系统功耗在表 4（b）中呈现。原型测试根据真实的存储系统运行评估 SRCMap，通过 Reporting 模块实现对功耗和 I/O 性能的影响的实际测量；模拟器测试能够在模拟时间内进行较长时间的实验，可以模拟各类型 storage testbeds 以研究在各种负载条件下的性能。 Prototype结果 图 9 是 SRCMap 的能耗节省情况。使用 L0 级 IOPS，平均每次能将 4 个左右 mdisks 停转，可以节能约 35%；使用 L3 级 IOPS，能将 7 个 mdisks 停转，节能约 60%。功耗的波动与计划和非计划（由于读取未命中）的 mdisks 激活有关，这些情况很少发生。 图 10 是 Consolidation 带来的损失情况，描述了三种不同配置（baseline-on， L0，L3）的响应时间的累积概率密度函数。为了减少同步 I/O 的干扰，将同步 I/O 限制为每 10 毫秒一个。上图中，对于大于 1ms 响应时间，baseline 性能优于 L0 和 L3；小于 1ms 响应时间 L0 和 L3 性能优于 baseline。由于 L0 相比 L3 有更多的 mdisk 可用，响应时间比 L3 稍微更好。之后作者进行 2 次附加实验研究同步 I/O 的影响。第 1 次禁用了所有同步 I/O，第 2 次禁用了所有前台 I/O，只有同步 I/O。图中可以说明同步读取导致了 L0 和 L3 响应时间的增加。没有同步 I/O 的 CDF与 baseline 更接近，请求延迟大于 1 毫秒的个数减少了约 10%。 Simulator 结果 首先是能耗的对比实验。实验组是 SRCMap 的 L0 级 IOPS 和三个备选方案（Caching-1、Caching-2 和 Replication）。其中，Caching-1 是使用 1 个额外的物理卷作为缓存，如果观察到的总负载小于缓存的 IOPS，则将工作负载重定向到缓存，否则使用原始 mdisk；Caching-2 使用 2 个缓存；Replication 则是创建副本对，其中一卷上的所有数据在另一卷上进行复制。如果总负载低于其中一个卷的 IOPS，则只保持一卷处于活跃状态，否则两个都保持活跃状态。图 11 是能耗对比。SRCMap 如果发生读取不命中，会产生瞬时功耗峰值，需要激活额外的 mdisk。每个方案在不同整合间隔上表现出不同程度的能源比例。SRCMap（L0）在所有间隔上均消耗了最少的功耗，且其功耗与负载成比例。Replication 也展示出较好的能源比例性，但平均功耗较高。Caching-1，2 的能源比例最低，只有两个有效的能源水平可供使用。在每个整合间隔中，SRCMap 重新映射（即更改活跃副本）的 mdisks 数量最少。作者还测试了 Caching-1、Caching-2 和 Replication 分别使用了额外的存储空间 12.5%、25% 和 100%，结合图 13 的空间开销情况，SRCMap 只需额外的 10% 存储空间就能实现几乎所有的节能。图 12 是 SRCMap 在 L3 级 IOPS 下的功耗统计，SRCMap 将工作负载整合在 D2 和 D3 上，可以看出各个 disk 的启动次数都不超过 6 次，因此不会牺牲磁盘的可靠性。图 14 是作者针对 5 个 IOPS 估计水平 L0 到 L4 级，在每个 2 小时的整合间隔内评估了能耗情况。负载因子（负载因子是观察到的平均 IOPS 负载与所有卷的预估 IOPS（负载估计水平）之间的百分比关系）是一个连续变量，但是 SRCMap 的能耗是离散的。SRCMap 每次只能改变一个 disk，因此 SRCMa p中不同的功耗水平之间的差异大约是一个物理卷的差异。因此 SRCMap 在具有 N 个 mdisks 的系统中能够实现接近 N 级的能源比例。 总结 作者针对数据中心的能源消耗问题，通过设计存储虚拟化层实现一个能源比例存储系统。通过采样工作集，使 workload 集中在少数活跃 mdisks 上，从而让能源消耗与 I/O 工作负载强度成比例，并且能够满足细粒度能量比例、低空间开销、可靠性、工作负载转换适应和异构支持的所有期望设计目标。后续的研究方向可以朝着以下方向发展：优化 consolidation 性能的新模型、调查 consolidation 期间逻辑卷之间工作负载相关性、优化副本同步的调度以最小化对前台 I/O 的影响等等。","categories":[{"name":"论文随记","slug":"learnings","permalink":"https://cs0522.github.io/categories/learnings/"},{"name":"盘节能","slug":"learnings/盘节能","permalink":"https://cs0522.github.io/categories/learnings/%E7%9B%98%E8%8A%82%E8%83%BD/"}],"tags":[{"name":"论文","slug":"论文","permalink":"https://cs0522.github.io/tags/%E8%AE%BA%E6%96%87/"},{"name":"盘节能","slug":"盘节能","permalink":"https://cs0522.github.io/tags/%E7%9B%98%E8%8A%82%E8%83%BD/"},{"name":"能源比例","slug":"能源比例","permalink":"https://cs0522.github.io/tags/%E8%83%BD%E6%BA%90%E6%AF%94%E4%BE%8B/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://cs0522.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"}]},{"title":"【学习笔记】SimPy 学习（二）：进程交互","slug":"n-simpy-02","date":"2023-10-24T00:13:23.000Z","updated":"2025-01-17T18:57:47.133Z","comments":false,"path":"notes/SimPy/n-simpy-02/","link":"","permalink":"https://cs0522.github.io/notes/SimPy/n-simpy-02/","excerpt":"SimPy 的 Environment、Events、进程交互等","text":"SimPy 的 Environment、Events、进程交互等 Environment 决定仿真的起点和终点，管理仿真元素之间的关联。 APIs 添加仿真进程：simpy.Environment.process() 创建事件： simpy.Environment.event() 提供延时事件：simpy.Environment.timeout() 仿真结束的条件：until=xxx 进程也是事件： 12proc = env.process(my_proc(env))env.run(until=proc) 仿真启动：simpy.Environment.run() 现在的时间：simpy.Environment.now 逐个执行仿真事件： 返回下一个计划事件的时间：simpy.Environment.peek() 处理下一个计划的事件：simpy.Environment.step() 123until = 10while env.peek() &lt; until: env.step() 当前活动进程：simpy.Environment.active_process Example 2.1 定义一个进程，仿真的简单代码结构 123456789101112131415161718import simpy# 定义一个汽车进程def car(env): while True: print(&#x27;Start parking at %d&#x27; % env.now) parking_duration = 5 # 进程延时 5s yield env.timeout(parking_duration) print(&#x27;Start driving at %d&#x27; % env.now) trip_duration = 2 # 延时 2s yield env.timeout(trip_duration) # 仿真启动env = simpy.Environment() # 实例化环境env.process(car(env)) # 添加汽车进程env.run(until = 15) # 设定仿真结束条件, 这里是 15s 后停止 Example 2.2 理解整个进程交互执行的流程。 描述一个汽车驾驶一段时间后停车充电， 汽车驾驶进程和电池充电进程通过事件的激活来相互影响 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import simpyfrom random import seed, randintseed(23)class ENV: def __init__(self, env): self.env = env self.drive_proc = env.process(self.drive(env)) self.bat_ctrl_proc = env.process(self.bat_ctrl(env)) print(&quot;执行了 2 个 process&quot;) self.bat_ctrl_reactivate = env.event() self.bat_ctrl_sleep = env.event() print(&quot;创建了 2 个事件&quot;) # 驾驶进程 def drive(self, env): while True: # drive 20~40 minutes print(&quot;Start driving at: &quot;, env.now) print(&quot;drive() 抛出了 timeout&quot;) yield env.timeout(randint(20, 40)) print(&quot;drive() 恢复了&quot;) print(&quot;End driving at: &quot;, env.now) # parking 1~6 hours print(&quot;Start parking at: &quot;, env.now) # activate battery charging # 这段代码应该是指触发事件并成功 print(&quot;drive() 触发了 reactivate 并成功&quot;) self.bat_ctrl_reactivate.succeed() self.bat_ctrl_reactivate = env.event() # 继续执行 # 超时并挂起，等待 bat_ctrl_sleep 事件发生 print(&quot;drive() 抛出了 timeout 和 sleep&quot;) yield env.timeout(randint(60, 360)) &amp; self.bat_ctrl_sleep print(&quot;drive() 恢复了&quot;) print(&quot;End parking at: &quot;, env.now) # 电池充电进程 def bat_ctrl(self, env): while True: print(&quot;Charge sleep at: &quot;, env.now) # 挂起。接收到 drive() 中的事件发生后恢复 print(&quot;bat_ctrl() 抛出了 reactivate&quot;) yield self.bat_ctrl_reactivate print(&quot;bat_ctrl() 恢复了&quot;) print(&quot;Charge activate at: &quot;, env.now) print(&quot;bat_ctrl() 抛出了 timeout&quot;) yield env.timeout(randint(30, 90)) print(&quot;bat_ctrl() 恢复了&quot;) print(&quot;Charge end at:&quot;, env.now) # 这段代码应该是指触发事件并成功 print(&quot;bat_ctrl() 触发了 sleep 并成功&quot;) self.bat_ctrl_sleep.succeed() self.bat_ctrl_sleep = env.event()if __name__ == &quot;__main__&quot;: env = simpy.Environment() # 下面这一步执行了 init() ENV(env) print(&quot;env 开始模拟...&quot;) env.run(until=300) 汽车的进程需要引用环境（env）来创建新的事件。汽车的行为被描述成一个无限循环。记住，这个函数是一个生成器。尽管它永远不会终止，但一旦到达 yield 语句，它会将控制流传回仿真程序。触发生成的事件后（事件发生），模拟将在此语句中恢复该函数。 可以看到，首先进行了 env 的初始化，进程并没有执行；env.run() 后，进程开始执行，个人感觉在 env 环境内进程是同时的，代码是按加入 process 的顺序执行的。 查看运行结果 12345678910111213141516171819202122232425262728293031323334353637执行了 2 个 process创建了 2 个事件env 开始模拟...Start driving at: 0drive() 抛出了 timeoutCharge sleep at: 0bat_ctrl() 抛出了 reactivatedrive() 恢复了End driving at: 29Start parking at: 29drive() 触发了 reactivate 并成功drive() 抛出了 timeout 和 sleepbat_ctrl() 恢复了Charge activate at: 29bat_ctrl() 抛出了 timeoutbat_ctrl() 恢复了Charge end at: 60bat_ctrl() 触发了 sleep 并成功Charge sleep at: 60bat_ctrl() 抛出了 reactivatedrive() 恢复了End parking at: 131Start driving at: 131drive() 抛出了 timeoutdrive() 恢复了End driving at: 169Start parking at: 169drive() 触发了 reactivate 并成功drive() 抛出了 timeout 和 sleepbat_ctrl() 恢复了Charge activate at: 169bat_ctrl() 抛出了 timeoutbat_ctrl() 恢复了Charge end at: 226bat_ctrl() 触发了 sleep 并成功Charge sleep at: 226bat_ctrl() 抛出了 reactivate Example 2.3 进程的中断。 在电动汽车还在充电过程中，接到一个紧急通知，需要中断充电进程马上出门 1234567891011121314151617181920212223242526272829303132333435363738394041from random import seed, randint import simpyseed(23) class EV: def __init__(self, env): self.env = env self.drive_proc = env.process(self.drive(env)) def drive(self, env): while True: # 行驶20-40分钟 yield env.timeout(randint(20, 40)) # 停车1小时 print(&#x27;开始停车时间&#x27;, env.now) charging = env.process(self.bat_ctrl(env)) print(&quot;设置了 timeout&quot;) parking = env.timeout(60) print(&quot;抛出了事件&quot;) yield charging | parking if not charging.triggered: # 中断充电 charging.interrupt(&#x27;该出发了！&#x27;) print(&#x27;结束停车时间：&#x27;, env.now) def bat_ctrl(self, env): print(&#x27;充电器启动时间：&#x27;, env.now) try: yield env.timeout(randint(60, 90)) print(&#x27;充电器完成时间：&#x27;, env.now) except simpy.Interrupt as i: # 充电被中断 print(&#x27;充电器中断时间：&#x27;, env.now, &#x27;, msg:&#x27;, i.cause) env = simpy.Environment()ev = EV(env)env.run(until=100) 中断另一个进程。可以对进程调用 process.interrupt(xxx)。这将在该进程中引发中断异常，并立即恢复。 simpy.Interrupt.cause 获取 xxx 信息。 查看结果 123456开始停车时间 29设置了 timeout抛出了事件充电器启动时间： 29结束停车时间： 89充电器中断时间： 89 , msg: 该出发了！ Events SimPy 包含一组用于各种目的的事件类型。它们都继承 simpy.events.Event。 事件的层次结构： events.Event events.Timeout events.Initialize events.Process events.Condition events.AllOf events.AnyOf APIs Event.trigged Event.processed 触发事件并成功：event.succeed(value=) 触发事件并失败：event.fail(exception) event.trigger(event) 事件基础知识 事件可以处于以下状态之一： 可能发生（未触发，不在 event 队列中） 会发生（触发，在时间 t 调度并插入 event 队列中） 已经发生（处理，从 event 队列中移除） 它们按这个顺序经历这些状态一次。时间推动事件的状态改变。 最初事件没有被触发，它只是内存中的对象 如果事件被触发，它将在给定的时间被调度并插入 SimPy 的事件队列中。属性 Event.trigged 变为 True 只要不处理事件，就可以向事件添加回调。回调接受事件作为参数，储在 event.Callbacks 列表中 当 SimPy 将事件从事件队列中弹出并调用其所有回调时，该事件将被处理。现在已无法添加回调。属性 Event.processed 变为 True。 事件也有值。可以在事件触发之前或触发时设置该值，并可以通过 event.value 检索该值，或者在进程中通过生成事件（value=yield event）进行检索。 进程也是事件 触发事件 当事件被触发时，要么成功要么失败。 要触发事件并将其标记为成功，可以使用 event.succeed(value=None)，可以选择向它传递一个值（例如，计算结果） 要触发事件并将其标记为失败，调用 event.fail(exception) 并将异常实例传递给它（例如，在计算失败期间捕获的异常） 触发事件的通用方法：event.trigger(event)。这将获取传递给它的事件的值和结果（成功或失败）。 这三个方法都返回它们绑定到的事件实例。这允许执行如 Event(env).succeed() 之类的操作。 同时等待多个事件 SimPy 提供 AnyOf 和 AllOf 事件，这两个事件都是条件事件。两者都将事件列表作为参数，并在触发任何（至少一个）或所有事件时触发。 作为 AllOf 和 AnyOf 的简写，可以使用逻辑运算符 &amp;（and）和 |（or）。 12345678910111213141516def test_condition(env): t1, t2 = env.timeout(1, value=&#x27;spam&#x27;), env.timeout(2, value=&#x27;eggs&#x27;) ret = yield t1 | t2 assert ret == &#123;t1: &#x27;spam&#x27;&#125; t1, t2 = env.timeout(1, value=&#x27;spam&#x27;), env.timeout(2, value=&#x27;eggs&#x27;) ret = yield t1 &amp; t2 assert ret == &#123;t1: &#x27;spam&#x27;, t2: &#x27;eggs&#x27;&#125; # You can also concatenate &amp; and | e1, e2, e3 = [env.timeout(i) for i in range(3)] yield (e1 | e2) &amp; e3 assert all(e.processed for e in [e1, e2, e3]) proc = env.process(test_condition(env))env.run() SimPy 学习 【学习笔记】SimPy 学习（一）：基础 【学习笔记】SimPy 学习（二）：进程交互 【学习笔记】SimPy 学习（三）：资源共享 【学习笔记】SimPy 学习（四）：实时模拟与时间调度 【学习笔记】SimPy 学习（五）：SimPy 版本迁移 【学习笔记】SimPy 学习（六）：监视","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"SimPy","slug":"notes/SimPy","permalink":"https://cs0522.github.io/categories/notes/SimPy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://cs0522.github.io/tags/Python/"},{"name":"SimPy","slug":"SimPy","permalink":"https://cs0522.github.io/tags/SimPy/"}]},{"title":"【学习笔记】SimPy 学习（一）：基础","slug":"n-simpy-01","date":"2023-10-23T13:00:52.000Z","updated":"2025-01-17T18:57:47.133Z","comments":false,"path":"notes/SimPy/n-simpy-01/","link":"","permalink":"https://cs0522.github.io/notes/SimPy/n-simpy-01/","excerpt":"Python 仿真库 SimPy，安装、结构和基本概念","text":"Python 仿真库 SimPy，安装、结构和基本概念 学习笔记参考SimPy 文档 SimPy 简介 &quot;SimPy 是基于过程的离散事件的标准 Python 模拟框架&quot; SimPy 文档 SimPy 安装 1pip install simpy SimPy 基本概念 SimPy 是离散事件驱动的仿真库。所有活动部件，例如车辆、顾客，即便是信息，都可以用 process 来模拟。这些 process 存放在 environment 中。所有 process 之间，以及与 environment 之间的互动，通过 event 来进行。 SimPy 可以看作一个异步事件分发器，生成一些事件并在给定的仿真时间安排它们。事件按优先级、仿真时间和递增的事件id排序。事件还具有回调列表，这些回调在事件触发和处理时执行。事件也可能有返回值。 涉及的组件是编写的环境（Envirement）、事件（events）和进程（process）函数。 环境（Environment） 环境（Environment）将这些事件（events）存储在其事件列表中，并跟踪当前仿真时间 进程（process） 进程（process）函数实现仿真模型，即定义仿真行为。它们可以看作是挂起事件实例的普通的 Python 生成器函数。进程在生命周期中可以创造并挂起（yield）事件（Events），等待事件的触发 当进程生成事件时，该进程将被挂起。当事件发生时（事件已触发），SimPy 恢复进程。多个进程可以等待同一事件。SimPy 按照生成事件的统一顺序进行恢复 启动进程涉及两步： 必须调用 Process 函数才能创建生成器对象。（这不会执行该函数的任何代码。见 Python yield 关键字） 然后创建进程实例，并将环境和生成器对象传递给它。这将在当前仿真时间安排一个初始化事件，启动进程函数的执行。进程实例也是进程函数返回时触发的事件。 默认情况下，只要事件列表中有事件，它就会运行，但您也可以通过提供until参数让它提前停止（请参见仿真控件）。 事件（events） 其中一类重要的事件是 Timeout，这类事件允许一段时间后再被激活，用来表达一个进程休眠或者保持当前的状态持续指定的一段时间。这类事件通过 Environment.timeout 来调用 Python yield 关键字 看作 return。举例说明。 Example 1.1 123456789def foo(): print(&quot;starting...&quot;) while True: res = yield 4 print(&quot;res:&quot;,res)g = foo()print(next(g))print(&quot;*&quot;*20)print(next(g)) 12345starting...4********************res: None4 运行过程： 程序开始执行以后，因为 foo() 中有 yield 关键字，所以 foo() 并不会真的执行，而是先得到一个生成器 g（相当于一个对象）； 调用 next(g)，foo() 正式开始执行，先执行 print(&quot;starting...&quot;)，然后进入 while； 程序遇到 yield 关键字，把yield 想成 return。return 了一个 4 之后，程序停止，并没有执行赋值给 res 操作，此时 next(g) 执行完成，所以输出的前两行第一个是 while 上面 print 的结果,第二个是return出的结果； 程序执行 print(&quot;*&quot;20)； 又开始执行下面的 print(next(g))，从刚才那个next程序停止的地方开始执行，也就是要执行 res 的赋值操作，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候 res 赋值是 None，所以接着下面的输出就是 res:None； 程序会继续在 while 里执行，又一次碰到yield，这个时候同样 return 出 4，然后程序停止，print 函数输出的 4 就是这次 return 出的 4。 Example 1.2 12345678910def foo(): print(&quot;starting...&quot;) while True: res = yield 4 print(&quot;res:&quot;,res)g = foo()print(next(g))print(&quot;*&quot;*20)###print(g.send(7)) 12345starting...4********************res: 74 运行过程： 程序执行 g.send(7)，程序会从 yield关键字那一行继续向下运行，send 会把 7 这个值赋值给 res 变量； 由于 send 方法中包含 next() 方法，所以程序会继续向下运行执行 print，然后再次进入 while； 程序执行再次遇到 yield 关键字，yield 会返回后面的值后，程序再次暂停，直到再次调用 next方法或 send 方法。 Python 生成器 使用了 yield 的函数被称为生成器函数。生成器函数可以在迭代过程中逐步产生值，而不是一次性返回所有结果。生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。 当在生成器函数中使用 yield 语句时，函数的执行将会暂停，并将 yield 后面的表达式作为当前迭代的值返回；然后，每次调用生成器的 next() 方法或使用 for 循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到 yield 语句。这样，生成器函数可以逐步产生值，而不需要一次性计算并返回所有结果。 生成器函数的优势是它们可以按需生成值，避免一次性生成大量数据并占用大量内存。 调用一个生成器函数，返回的是一个迭代器对象。 Example 1.3 生成器函数实现费波拉契数列 12345678910111213141516171819import sys def fibonacci(n): # 生成器函数 a, b, counter = 0, 1, 0 while True: if (counter &gt; n): return yield a a, b = b, a + b counter += 1f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: # end=&quot; &quot; 意思是每输出一个数，以&quot; &quot;结尾，而不是换行 print (next(f), end=&quot; &quot;) except StopIteration: sys.exit() 运行结果 10 1 1 2 3 5 8 13 21 34 55 SimPy 学习 【学习笔记】SimPy 学习（一）：基础 【学习笔记】SimPy 学习（二）：进程交互 【学习笔记】SimPy 学习（三）：资源共享 【学习笔记】SimPy 学习（四）：实时模拟与时间调度 【学习笔记】SimPy 学习（五）：SimPy 版本迁移 【学习笔记】SimPy 学习（六）：监视","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"SimPy","slug":"notes/SimPy","permalink":"https://cs0522.github.io/categories/notes/SimPy/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://cs0522.github.io/tags/Python/"},{"name":"SimPy","slug":"SimPy","permalink":"https://cs0522.github.io/tags/SimPy/"}]},{"title":"【学习笔记】DiskSim 学习（一）：安装","slug":"n-disksim-01","date":"2023-10-23T12:17:11.000Z","updated":"2025-01-17T18:57:47.125Z","comments":false,"path":"notes/DiskSim/n-disksim-01/","link":"","permalink":"https://cs0522.github.io/notes/DiskSim/n-disksim-01/","excerpt":"老东西 DiskSim 环境的配置","text":"老东西 DiskSim 环境的配置 环境 系统环境 Ubuntu14.04 x64 以下 测试通过：Ubuntu14.04 x64，Ubuntu10.04 x86 老版本需要更换官方源 1# Ubuntu10.04 换源 gcc 等工具 gcc 版本要在 gcc-4.8 以下，越老越好 直接安装 1sudo apt-get install gcc g++ build-essential make flex-old bison 安装 DiskSim 1. 下载源码包 DiskSim ssd-add-on 2. 解压 123tar xfz disksim-4.0-with-dixtrac.tar.gzcd disksim-4.0unzip ../ssd-add-on.zip 3. 下载修改补丁、x64 兼容补丁 modify-patch 64bit-patch 4. 打上补丁 123456# disksim-4.0/patch -p1 &lt; ssdmodel/ssd-patchpatch -p1 &lt; modify-patchpatch -p1 &lt; 64bit-patch 编译与验证 Make 12# disksim-4.0/make 验证 1234567cd valid./runvalid# 验证 ssdmodelchmod a+x ./ssdmodel/valid/runvalidcd ./ssdmodel/valid./runvalid","categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"DiskSim","slug":"notes/DiskSim","permalink":"https://cs0522.github.io/categories/notes/DiskSim/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cs0522.github.io/tags/Linux/"},{"name":"DiskSim","slug":"DiskSim","permalink":"https://cs0522.github.io/tags/DiskSim/"}]},{"title":"【文档小记】SSH 使用方法","slug":"d-ssh-instruction","date":"2023-10-22T10:01:53.000Z","updated":"2025-01-17T18:57:47.089Z","comments":false,"path":"docs/d-ssh-instruction/","link":"","permalink":"https://cs0522.github.io/docs/d-ssh-instruction/","excerpt":"记录 SSH 一些使用方法","text":"记录 SSH 一些使用方法 记录如何使用 SSH RSA 私钥登录服务器，包括 Windows、Linux 客户端操作以及 Linux 服务端操作。 Client 端 Windows 安装 OpenSSH Client 和 OpenSSH Server Powershell（管理员）中输入： 1Start-Service sshd 命令行中输入： 1ssh Frank@localhost 测试连接成功，但需要输入密码。 通过 RSA 私钥登录： 1ssh-keygen -t rsa 在 ~/.ssh 目录下得到 id_rsa.pub 公钥和 id_rsa 私钥。 将 id_rsa.pub 中的内容复制到 Server 端的 ~/.ssh/authorized_keys 文件中。提供一个可行的方法： 12345# 1. 直接通过 SSH 连接 Server 端ssh &lt;user&gt;@&lt;hostname&gt;# 2. echo 的方式加入到 ~/.ssh/authorized_keys 文件中echo &lt;content_of_id_rsa_pub&gt; &gt;&gt; ~/.ssh/authorized_keys 在 .ssh/ 目录下新建文本文件 config，内容如下： 12345Host &lt;host&gt;HostName &lt;hostname&gt; # ip address or domainUser &lt;user&gt;PreferredAuthentications publickeyIdentityFile &lt;.ssh/id_rsa&gt; 验证连接： 1ssh &lt;host&gt; 当所有操作正确完成后，连接成功。 Linux 所有操作与 Windows 几乎相同，在复制 id_rsa.pub 公钥的时候，还可以通过以下方式： 1ssh-copy-id -i &lt;~/.ssh/id_rsa.pub&gt; &lt;user&gt;@&lt;hostname&gt; Server 端 要注意的是 .ssh/ 目录下的文件权限，通过 chmod 命令修改。 安装 openSSH： 1sudo apt install openssh-server 启动： 1/etc/init.d/ssh start 使用 vim 打开 /etc/ssh/sshd_config，添加以下内容： 123AuthorizedKeysFile .ssh/authorized_keys PubkeyAuthentication yes 通过 ssh-keygen 工具生成 .ssh 目录。 如果 .ssh 目录下没有 authorized_keys 文件，创建一个： 1touch ~/.ssh/authorized_keys 将 服务器自己的公钥 和 远程登录机器对应的公钥 复制到 authorized_keys 文件中： 1cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 修改目录权限： 1234567# ～: 750 # ~/.ssh: 700 # ~/.ssh/*: 600 # ~/.ssh/config: 700chmod 700 ~/.sshchmod 600 .ssh/authorized_keys 理论上可以运行成功。 管理会话 —— screen 管理会话，SSH 时断开连接也不中断正在运行的进程，重新连接 SSH 后可以恢复。 123456789101112131415161718192021# 安装 screensudo apt install screen# 新建 screenscreen -S &lt;name&gt;# 进入 screenscreen -r &lt;name&gt;# 退出当前 screen# 在当前 screen 下Ctrl+A，Ctrl+D # 显示 screen list​​​​​​​screen -ls# 删除指定 screen# 在当前 screen 下Ctrl+D# 不在当前 screen 下​​​​​​​screen -S &lt;name&gt; -X quit","categories":[{"name":"文档小记","slug":"docs","permalink":"https://cs0522.github.io/categories/docs/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cs0522.github.io/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"https://cs0522.github.io/tags/SSH/"}]},{"title":"【文档小记】Node & Vue 使用方法","slug":"d-node-vue-instruction","date":"2023-10-22T10:01:43.000Z","updated":"2025-01-17T18:57:47.089Z","comments":false,"path":"docs/d-node-vue-instruction/","link":"","permalink":"https://cs0522.github.io/docs/d-node-vue-instruction/","excerpt":"记录 Node 和 Vue 一些使用方法","text":"记录 Node 和 Vue 一些使用方法 安装 Node 安装 nvm 工具 1curl https:# raw.githubusercontent.com/creationix/nvm/master/install.sh | bash 通过 nvm 安装 Node, npm 12345nvm install 16.15.0nvm lsnvm use &lt;node-version&gt; 搭建 Vue 安装 vue-cli 脚手架 1234567npm install -g @vue/clivue create &lt;project-name&gt;npm run servenpm run dev 安装 vue-router 1npm install -g vue-router@3 1234// main.jsimport Vue from &#x27;vue&#x27;; import VueRouter from &#x27;vue-router&#x27;; Vue.use(VueRouter) 安装 axios 1npm install -g axios 12import axios from &#x27;axios&#x27;// 可以将 axios 请求封装成 bash 工具文件 删除 node_modules 1npm install -g remove-node-modules 安装 Vuex 1npm install -g vuex@3 配置 Vuex 单独创建一个 states.js，编辑 vuex 相关的配置 1234567891011121314151617// states.jsimport Vue from &#x27;vue&#x27; import Vuex from &#x27;vuex&#x27; Vue.use(Vuex) export default new Vuex.Store(&#123; state:&#123; &#125;, mutations:&#123; &#125;, actions:&#123; &#125;&#125;) main.js 中导入第一步的配置文件，并在 vue 实例中声明一下 123456789import store from &quot;./states.js&quot; new Vue(&#123; // 使用 router router,// 使用 vuexstore, render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 使用 Vuex state 的使用 (当成组件中的data) 12345678state: &#123; products: [ &#123;name: &#x27;鼠标&#x27;, price: 20&#125;, &#123;name: &#x27;键盘&#x27;, price: 40&#125;, &#123;name: &#x27;耳机&#x27;, price: 60&#125;, &#123;name: &#x27;显示屏&#x27;, price: 80&#125; ]&#125; getters 相当于之前实例中讲过的 computed 计算属性 123456789101112getters:&#123; // 获取数据的方法，类似于计算属性 saleProducts: (state) =&gt; &#123; let saleProducts = state.products.map((product) =&gt; &#123; return &#123; name: product.name, price: product.price / 2 &#125; &#125;) return saleProducts; &#125;&#125; mutations 相当于 methods，提供修改数据的方法 12345678mutations: &#123; minusPrice(state, payload) &#123; let newPrice = state.products.forEach(product =&gt; &#123; // 将数据的price价钱，减payload product.price -= payload &#125;) &#125;&#125; actions 相当于异步的 methods，支持一步操作，注意 actions 还是要通过 mutations 修改数据 123456789actions: &#123; minusPriceAsync(context, payload ) &#123; // setTimeout定时，延迟2000毫秒，回调第一个参数的函数 setTimeout(() =&gt; &#123; // context提交，调用mutations中的minusPrice函数 context.commit( &#x27;minusPrice&#x27;, payload ); &#125;, 2000) &#125; &#125; 搭建 Electron-Vue 安装 electron-vue 脚手架模板 12345678910111213npm install -g @vue/clinpm install -g electronnpm install -g @vue/cli-init# python-shell 模块，非必须npm install -g python-shell# 创建 projectvue init simulatedgreg/electron-vue &lt;project-name&gt;npm run dev 解决出现的报错 libgconf 问题 1sudo apt-get install libgconf-2-4 控制台 Object.formEntries 问题 1npm i -g polyfill-object.fromentries 12// dev-client.jsimport &#x27;polyfill-object.fromentries&#x27;; 404 not found 问题 123// dev-runner.js// 69th row，解开注释app.use(hotMiddleuse)","categories":[{"name":"文档小记","slug":"docs","permalink":"https://cs0522.github.io/categories/docs/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://cs0522.github.io/tags/Vue/"},{"name":"Node.js","slug":"Node-js","permalink":"https://cs0522.github.io/tags/Node-js/"},{"name":"npm","slug":"npm","permalink":"https://cs0522.github.io/tags/npm/"},{"name":"nvm","slug":"nvm","permalink":"https://cs0522.github.io/tags/nvm/"}]},{"title":"【文档小记】Linux 使用方法","slug":"d-linux-instruction","date":"2023-10-22T10:01:26.000Z","updated":"2025-01-17T18:57:47.089Z","comments":false,"path":"docs/d-linux-instruction/","link":"","permalink":"https://cs0522.github.io/docs/d-linux-instruction/","excerpt":"记录 Linux (Ubuntu) 一些使用方法","text":"记录 Linux (Ubuntu) 一些使用方法 Ubuntu 环境配置 Ubuntu 备份与恢复 VSCode 创建启动器 C++ 环境安装配置 1sudo apt install g++ gdb make build-essential ninja-build zip vim screen Java、maven3 环境配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# ----- Java -----# Ubuntusudo apt install openjdk-16-jdk# CentOSsudo yum install java-1.8.0-openjdk* -yjava -versionjavac -version# 查看 java 安装位置which javals -lrt /usr/bin/javals -lrt /etc/alternatives/java# JAVA_HOME 变量配置sudo vim /etc/profile# 添加：# jdk 1.8export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.362.b08-3.el8.x86_64export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH# jdk 16export JAVA_HOME=/usr/lib/jvm/java-16.0.1-openjdk-amd64export PATH=$JAVA_HOME/bin:$PATHsource /etc/profile# ----- maven3 -----# Ubuntusudo apt-get install maven# CentOSwget https://dlcdn.apache.org/maven/maven-3/3.9.9/binaries/apache-maven-3.9.9-bin.tar.gztar zxf apache-maven-3.9.9-bin.tar.gzmv apache-maven-3.9.9 maven3# 当前路径为 /home/frank# maven3 路径为 /home/frank/maven3# 编辑 maven3/conf/settings.xml# 指定源&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt;# 指定版本&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt;# 配置 maven 环境变量sudo vim /etc/profileexport MAVEN_HOME=/home/frank/maven3export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/binsource /etc/profile 配置 root 密码 1sudo passwd 中文包 12sudo apt install language-pack-zh-hanssudo update-locale LANG=zh_CN.UTF-8 删除桌面回收站、用户文件图标 12gsettings set org.gnome.shell.extensions.desktop-icons show-trash falsegsettings set org.gnome.shell.extensions.desktop-icons show-home false 添加监视器 system monitor 12sudo add-apt-repository ppa:fossfreedom/indicator-sysmonitorsudo apt-get install -y indicator-sysmonitor sudo 不输入密码 1234sudo vim /etc/sudoers# 文末添加下句: frank ALL=(ALL:ALL) NOPASSWD: ALL 软件安装 数据库 点击查看 12345678910111213141516171819sudo apt install mysql-serversudo apt install mysql-clientsudo apt install libmysqlclient-devsudo vim /etc/mysql/debian.cnfmysql -u debian-sys-maint -pflush privileges;alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with caching_sha2_password by &#x27;123456frank&#x27;flush privilegesquitservice mysql restart 安装 deb 软件包 12# deb packagesudo dpkg -i *.deb vim 12# vimsudo apt install gedit vim 主菜单编辑软件 12# 主菜单编辑软件sudo apt install alacarte gnome-tweak-tool 12# gnome-tweak-toolsudo apt install gnome-tweak-tool copyQ 1234# copyQsudo add-apt-repository ppa:hluk/copyqsudo apt updatesudo apt install copyq indicator &amp; stickynotes 1234# indicator stickynotessudo add-apt-repository ppa:umang/indicator-stickynotessudo apt-get updatesudo apt-get install indicator-stickynotes jetbrains IDE 123# jetbrains (idea &amp; clion)sudo snap install intellij-idea-ultimate --classicsudo snap install clion --classic systemback 12345# systembacksudo sh -c &#x27;echo &quot;deb [arch=amd64] http://mirrors.bwbot.org/ stable main&quot; &gt; /etc/apt/sources.list.d/systemback. list&#x27;sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key 50B2C005A67B264Fsudo apt-get updatesudo apt-get install systemback timeshift 1sudo apt install timeshift nvm, node 123# 通过 nvm 安装 nodejs npmcurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bashnvm install node conda 123456# anaconda3wget -P /tmp https://repo.anaconda.com/archive/Anaconda3-2020.02-Linux-x86_64.shsudo gedit ~/.bashrc# .bashrcexport PATH=&quot;/home/用户名/anaconda3/bin:$PATH&quot;source ~/.bashrc screen 管理会话，SSH 时断开连接也不中断进程 123456789101112131415161718192021# 安装 screensudo apt install screen# 新建 screenscreen -S &lt;name&gt;# 进入 screenscreen -r &lt;name&gt;# 退出当前 screen# 在当前 screen 下Ctrl+A，Ctrl+D # 显示 screen list​​​​​​​screen -ls# 删除指定 screen# 在当前 screen 下Ctrl+D# 不在当前 screen 下​​​​​​​screen -S &lt;name&gt; -X quit VirtualBox 12sudo apt install virtualboxsudo apt install virtualbox-ext-pack EasyConnect EasyConnect 在 Ubuntu 20.04 以上因为依赖问题无法正常打开。 12345678910111213141516171819202122232425# 安装软件sudo dpkg -i ./EasyConnect.deb# 查看安装路径dpkg -L easyconnect# /usr/share/sangfor/EasyConnect# cd cd /usr/share/sangfor/EasyConnectsudo su# 查看依赖ldd ./EasyConnect | grep pango# 下载缺失依赖文件# http://kr.archive.ubuntu.com/ubuntu/pool/main/p/pango1.0/# libpangocairo-1.0-0_1.40.14-1_amd64.deb# libpangoft2-1.0-0_1.40.14-1_amd64.deb# libpango-1.0-0_1.40.14-1_amd64.deb# 对这三个文件进行解压缩，提取出 data.tra.xz -&gt; usr -&gt; lib -&gt; x86_64-linux-gnu 下面的所有文件# 将得到的 6 个文件全部复制到安装目录下cp ./* /usr/share/sangfor/EasyConnect# 启动 EasyConnect 安装 VMware 17.5.2 虚拟机 1234567891011121314sudo dpkg -i ./*.bundle# 编译 vmmon、vmnet 模块sudo apt install gcc-12# clone 补充模块git clone https://github.com/mkubecek/vmware-host-modulesgit checkout -t origin/workstation-17.5.1sudo makesudo make install sudo /etc/init.d/vmware start 常用命令 / 解决方案 显示内存 123freefree -mfree -h screen 管理会话，SSH 时断开连接也不中断进程 1234567891011121314151617181920212223# 安装 screensudo apt install screen# 新建 screenscreen -S &lt;name&gt;# 进入 screenscreen -r &lt;name&gt;# 状态显示 Attached，但无法进入screen -D -r &lt;session-id&gt;# 退出当前 screen# 在当前 screen 下Ctrl+A，Ctrl+D # 显示 screen list​​​​​​​screen -ls# 删除指定 screen# 在当前 screen 下Ctrl+D# 不在当前 screen 下​​​​​​​screen -S &lt;name&gt; -X quit 增加虚拟内存交换空间 未开启交换空间： 123456789101112131415161718sudo su# 查看内存使用情况free -h# 创建 swap 文件# 单位 bs 为 G，大小 count 为 20，创建 20G 交换空间dd if=/dev/zero of=/swapfile bs=1G count=20# 激活 swap 文件chmod 600 swapfilemkswap swapfile# 开启 swapswapon swapfilefree -h# 查看已开启的交换空间swapon --show 已开启交换空间，重新修改 swap 大小： 123456789101112# 查看内存使用情况free -h# 关闭指定 swapswapoff /swapfile# 重新分配fallocate -l 30G /swapfilechmod 600 swapfilemkswap swapfileswapon swapfile 动态库无法链接 cannot open shared object file 1234567sudo vim /etc/ld.so.conf# 在 ld.so.conf 中加入 *.so 的绝对路径，如# /usr/local/lib# 对配置文件 /etc/ld.so.conf 中定义的路径下的程序库重新建立必要的链接sudo ldconfig 挂载、卸载 img 镜像 使用 mount、umount 命令。挂载 nsg_server.img 文件为例子。 123456789101112131415161718192021# NSG_SERVER.img# 1. 查看 NSG_SERVER.img 的分区情况，是为了看需要挂载哪个分区fdisk ./NSG_SERVER.img# result: # Disk NSG_SERVER.img：20 GiB，21474836480 字节，41943040 个扇区# 单元：扇区 / 1 * 512 = 512 字节# 扇区大小(逻辑/物理)：512 字节 / 512 字节# I/O 大小(最小/最佳)：512 字节 / 512 字节# 磁盘标签类型：gpt# 磁盘标识符：D85F133D-8179-4557-86F6-6DF45C769770# 设备 起点 末尾 扇区 大小 类型# NSG_SERVER.img1 2048 4095 2048 1M BIOS 启动# NSG_SERVER.img2 4096 41940991 41936896 20G Linux 文件系统# 2. 挂载 .img2 分区到本机 /mnt/nsg_server# 注意其中 offset = 4096 * 512，因为扇区大小为 512 字节mkdir /mnt/nsg_serversudo mount -o loop,offset=2097152 NSG_SERVER.img /mnt/nsg_server# 3. 卸载 .img2 分区sudo umount /mnt/nsg_server VirtualBox 挂载共享文件夹 在本地中创建共享的文件夹，我的共享文件夹为：/mnt/nsg_server/home/icecream，想要挂载到虚拟机中的 /mnt/nsg_server 中。 本地电脑中设置共享文件夹路径（如上）以及共享文件夹名称 icecream，注意不要勾选自动挂载，会出现权限问题； 虚拟机中： 12345678910111213# 创建挂载点sudo mkdir /mnt/nsg_server# 挂载命令# mount -t vboxsf &lt;共享文件夹名称&gt; &lt;挂载目录&gt;sudo mount -t vboxsf icecream /mnt/nsg_server/# 开机自动挂载sudo gedit /etc/sftab# 文末添加# &lt;共享文件夹名称&gt; &lt; 挂载目录&gt; vboxsf defaults 0 0icecream /mnt/nsg_server/ vboxsf defaults 0 0 vim 操作 123456789# 显示行号:set number # 删除单行dd:&lt;num&gt;d# 删除多行:&lt;begin&gt;&lt;end&gt;d img、vdi 格式转换 通过 VirtualBox 的 VBoxChange 工具进行转换 12345# vdi to imgVBoxManage clonehd test.vdi test.img --format raw# img to vdi VBoxManage convertfromraw test.img test.vdi --format vdi 彻底删除 Snap 1234567891011121314151617181920212223# 1. 删掉所有的已经安装的 Snap 软件for p in $(snap list | awk &#x27;&#123;print $1&#125;&#x27;); do sudo snap remove $pdone# 直到出现：No snaps are installed yet. Try &#x27;snap install hello-world&#x27;.# 2. 删除 Snap 的 Core 文件sudo systemctl stop snapdsudo systemctl disable --now snapd.socketfor m in /snap/core/*; do sudo umount $mdone# 3. 删除 Snap 的管理工具sudo apt autoremove --purge snapd# 4. 删除 Snap 的目录rm -rf ~/snapsudo rm -rf /snapsudo rm -rf /var/snapsudo rm -rf /var/lib/snapdsudo rm -rf /var/cache/snapd 关闭 systemd-resolved 自启动且会占用 53 端口。 1234567891011121314151617181920212223242526# 停用 systemd-resolved 并取消开机自动启动sudo systemctl disable systemd-resolvedsudo systemctl stop systemd-resolved# 修改 NetworkManager 配置，让它能自动获取 dnssudo vim /etc/NetworkManager/NetworkManager.conf# 添加一行 dns=defaultdns=default# [main]# plugins=ifupdown,keyfile# dns=default# [ifupdown]# managed=false# [device]# wifi.scan-rand-mac-address=no# 删除 /etc/resolv.confsudo unlink /etc/resolv.confsudo touch /etc/resolv.conf# 重启 NetworkManagersudo systemctl restart NetworkManager# 查看 /etc/resolv.conf 中新的 dnscat /etc/resolv.conf 重装网卡 重装网卡后还需要修改 DNS。 123456# 查看网卡名ifconfig -a# ens3sudo dhclient &lt;nic_name&gt;sudo ifconfig &lt;nic_name&gt; 设置 DNS 12345678910# 1. 修改 /etc/systemd/resolved.confsudo vim /etc/systemd/resolved.conf# 修改：DNS=114.114.114.114 8.8.8.8# 2. 重启 systemd-resolvedsystemctl restart systemd-resolvedsystemctl enable systemd-resolved mv /etc/resolv.conf /etc/resolv.conf.bakln -s /run/systemd/resolve/resolv.conf /etc/resolv.conf 网卡消失 问题： 1234sudo lshw -c network# output:# -network DISABLED 解决方案： 12345sudo service NetworkManager stopsudo rm /var/lib/NetworkManager/NetworkManager.statesudo vi /etc/NetworkManager/NetworkManager.conf # 打开 .conf 文件后，将 managed=false 改为 managed=truesudo service NetworkManager start ip link show 命令可以查看所有网卡。 文件分割 sh 脚本 已知文件大小，利用 dd 命令 123456789101112# Create split_file.sh: # 获取文件大小size=$(stat -c%s &quot;/dataset/bigann/bigann_learn.bvecs&quot;)# 计算一半的大小half=$((size / 2))# 提取前半部分dd if=filename of=part1.bvecs bs=1 count=$half# 提取后半部分dd if=filename of=part2.bvecs bs=1 skip=$half sftp 大文件断点续传 1234567891011# sftp user@hostnamesftp root@hust-server# cd 到指定目录sftp&gt; cd /root.....# -a 表示使用增量续传的方式sftp&gt; get -a nsg_100G.img# 上传sftp&gt; put -a nsg_100G.img 将命令放至后台 &amp; 放后台 1sleep 10s &amp; nohup 命令 1nohup sleep 10s &amp; &amp;&gt;/dev/null &amp; 重定向 输出重定向、完全挂后台 1./build/bin/nvmf_tgt &amp;&gt;/dev/null &amp;","categories":[{"name":"文档小记","slug":"docs","permalink":"https://cs0522.github.io/categories/docs/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://cs0522.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://cs0522.github.io/tags/Ubuntu/"}]},{"title":"【文档小记】Git 使用方法","slug":"d-git-instruction","date":"2023-10-22T10:01:13.000Z","updated":"2025-01-17T18:57:47.089Z","comments":false,"path":"docs/d-git-instruction/","link":"","permalink":"https://cs0522.github.io/docs/d-git-instruction/","excerpt":"记录 Git &amp; GitHub 一些使用方法","text":"记录 Git &amp; GitHub 一些使用方法 Git 基本操作 SSH key 创建 SSH key 1ssh-keygen -t rsa -C &quot;812359326@qq.com&quot; 复制 key 到 Github SSH 设置中 验证连接 1ssh -T git@github.com 配置用户名、email、默认文本编辑器 123git config --global user.name &quot;Frank&quot; git config --global user.email &quot;812359326@qq.com&quot;git config --global core.editor gedit Check config 1git config --list 工作区、暂存库、版本库 Git工作区暂存库 进入仓库、初始化 1git init 克隆仓库 1git clone git://github.com/CS0522/GitTest.git ./ideaTest Git基本操作命令 Git工作区暂存库 Git工作区暂存库 提出更改，添加到暂存区 1234git add ./src/ git add ./out/ git add ./ideaTest.iml git add * 查看仓库当前的状态，显示有变更的文件 1git status 比较文件的暂存区和工作区的差异 1git diff 改动提交到 HEAD 版本库, 但还没到远端仓库 1git commit -m &quot;test&quot; 回退版本，可以指定退回某一次提交的版本 12git reset [--soft | --hard | --mixed] [HEAD]git reset --hard HEAD~3 --soft 参数用于回退到某个版本, 只进行对commit操作的回退，不影响工作区 --hard 参数撤销工作区中所有未提交，将暂存区与工作区都回到上一版本 --mixed 为默认，可以不用带该参数，重置暂存区与上一次的commit保持一致，工作区文件内容保持不变 删除文件 1git rm [-- cached] [-f | -r] [file] 不带参数时，将文件从暂存区和*工作区中删除 -- cached 文件仅从暂存区域移除，工作目录保留 查看历史提交记录 1git log 添加远程仓库 12git remote add [alias] [url | server]git remote add origin https://github.com/CS0522/GitTest.git 删除远程仓库、重命名远程仓库 12git remote rm [name] git remote rename [old_name] [new_name] 查看当前配置的远程仓库 1git remote -v 把远程仓库master分支下载到本地并存为temp分支 1git fetch origin master:temp 合并本地的temp分支和master分支 1git merge temp 拉取远程代码并合并 123git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; git pull origin master:brantest git pull origin master 推送代码至远程并合并 123git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; git push origin master:mastergit push origin master Git分支管理 Git分支 Git分支 创建分支 123456789git branch [branchname]``` * 不带[branchname]时，列出所有分支### 删除分支 ```bashgit branch -d [branchname] 切换分支 1git checkout [-b] [branchname] -b 表示创建新的分支并切换到该分支下 切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容，所以多分支不需要多个目录 切换远程分支 列出远程所有分支： 1git branch -r 拉取所有信息： 1git fetch -a 切换到远程分支： 1git checkout -t origin/&lt;branch_name&gt; 将temp分支和本地的master分支合并 1git merge temp [--allow-unrelated-histories] --allow-unrelated-histories 参数会允许合并无关历史，当远程版本远高于本地版本时，可能需要 Fork后本地项目同步他人更新 123456789101112### 添加上游仓库git remote add upstream git@github.com:Chtho1ly/WADG_ANN.git### 拉取最新更改git fetch upstream### 切换分支并合并git checkout mastergit merge upstream/master### 推送到自己的远程仓库git push -u origin master Git可能会出现的问题 鉴权失败 用户名和密码的登录方式失效，需要到 Dev Settings 设置 Token. 每次 pull/push 都要鉴权 1git config --global credential.helper store 无法合并 本地版本太老，先远程下载分支，然后本地合并: 12git fetch origin master:temp git merge temp --allow-unrelated-histories 想要忽略某个文件(文件夹) 使用 .gitignore 文件 12345# 忽略 Holiday Homework Holiday Homework/ # 忽略 *.class *.class 已经上传至版本库后，想要忽略某个文件(文件夹) git清除本地缓存（改变成未track状态），然后再提交 1234git rm -r --cached .git add .git commit -m &#x27;update .gitignore&#x27;git push origin master","categories":[{"name":"文档小记","slug":"docs","permalink":"https://cs0522.github.io/categories/docs/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://cs0522.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://cs0522.github.io/tags/GitHub/"}]},{"title":"【文档小记】Anaconda3 使用方法","slug":"d-anaconda-instruction","date":"2023-10-22T10:00:54.000Z","updated":"2025-01-17T18:57:47.085Z","comments":false,"path":"docs/d-anaconda-instruction/","link":"","permalink":"https://cs0522.github.io/docs/d-anaconda-instruction/","excerpt":"记录 Anaconda3 的使用方法","text":"记录 Anaconda3 的使用方法 Install 1234567wget -P /tmp https://repo.anaconda.com/archive/Anaconda3-2020.02-Linux-x86_64.shsudo gedit ~/.bashrc# .bashrcexport PATH=&quot;/home/&lt;username&gt;/anaconda3/bin:$PATH&quot;source ~/.bashrc Use 1234567891011121314151617181920212223242526272829303132333435363738394041# set no auto activateconda config --set auto_activate_base false# create a new envconda create -n &lt;env_name&gt;# check all envsconda info --envs# activate the envconda activate &lt;env_name&gt;# deactivate envconda deactivate &lt;env_name&gt;# install packageconda install &lt;package_name&gt;# list packagesconda list# remove envconda remove -n &lt;env_name&gt; --all# set one env&#x27;s python versionconda install python==3.8 -n &quot;&lt;env_name&gt;&quot;# if pip failed# Linuxsudo mkdir ~/.pipsudo touch ~/.pip/pip.confsudo vim ~/.pip/pip.conf# in pip.conf[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com","categories":[{"name":"文档小记","slug":"docs","permalink":"https://cs0522.github.io/categories/docs/"}],"tags":[{"name":"anaconda","slug":"anaconda","permalink":"https://cs0522.github.io/tags/anaconda/"}]},{"title":"【文档小记】搭建本博客","slug":"d-build-my-blog","date":"2023-10-21T16:00:00.000Z","updated":"2025-01-24T07:54:47.380Z","comments":false,"path":"docs/d-build-my-blog/","link":"","permalink":"https://cs0522.github.io/docs/d-build-my-blog/","excerpt":"记录搭建本博客的过程，以及遇到的一些问题及解决方案","text":"记录搭建本博客的过程，以及遇到的一些问题及解决方案 Based on Hexo &amp; Volantis 详细说明参考文档 Hexo &amp; Volantis 搭建环境 安装 Hexo 准备环境： nvm（参考 Node &amp; Vue 文档） node.js（参考 Node &amp; Vue 文档，版本 &gt; 16.15.0） git npm 安装 Hexo： 1npm install -g hexo-cli 建立项目 在指定文件夹中新建项目 123hexo init MyBlogcd MyBlognpm install _config.yml 主要配置文件，配置网站参数 scaffolds 模板文件，填写头部 front-matter 内容 source 源文件，包括 about、category 页面、images/ 等资源文件 图片资源引用：/images/XXX 部署到远程仓库 安装模块 1npm install hexo-deployer-git --save 修改 _config.yml 1234deploy: type: git repository: git@github.com:CS0522/CS0522.github.io.git branch: master 推送 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 配置网站 仅列出我修改的地方 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 修改图标favicon: /images/cicon.ico# 网站标题title: 诚实同学的博客subtitle: &#x27;&#x27;description: &#x27;Blog, Computer Science, Learning, Life&#x27;keywords: # 作者author: Chen Shilanguage: - zh-CN - en - ja-JP# 时区timezone: &#x27;Asia/Shanghai&#x27;# 文章链接格式permalink: :category/:title/permalink_defaults: lang: zh-CN category: notes# 文章内图片# 直接用 ./XXX 相对路径引用post_asset_folder: truemarked: enable: true prependRoot: true postAsset: true# Category &amp; Tagdefault_category: notes# 学习笔记 - notes，论文随记 - learnings，文档小记 - docscategory_map: 学习笔记: notes 论文随记: learnings 文档小记: docstag_map:# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repository: git@github.com:CS0522/CS0522.github.io.git branch: master 常用命令 建立 123hexo init &lt;pro_name&gt;cd &lt;pro_name&gt;npm install 新建文章 12hexo new [page/post/docs] [-p about/me] &quot;&lt;file_name&gt;&quot;# hexo new page about/me &quot;About Me&quot; 生成、预览 123hexo cleanhexo ghexo s 部署推送 1hexo d 网站主题 安装 Volantis 修改主题 _config.yml 1theme: volantis 安装 Volantis 1npm install hexo-theme-volantis --save 配置主题 原主题配置文件位于 ./node_modules/hexo-theme-volantis/_config.yml 下 项目根目录创建 _config.volantis.yml 以自定义主题。其中的内容可以直接复制 1 中的文件内容，再按需修改 以下仅列出我修改的地方 导航栏 点击查看 123456789101112131415161718192021222324252627282930313233########## 导航栏 ########## &gt; startnavbar: visiable: auto # always, auto logo: # choose [img] or [icon + title] img: &#x27;&#x27; # volantis-static/media/org.volantis/blog/Logo-NavBar@3x.png icon: title: &#x27;诚实同学&lt;sup style=&quot;color:#ff9800&quot;&gt;Blog&lt;/sup&gt;&#x27; menu: - name: 首页 icon: fa-solid fa-house url: / - name: 分类 icon: fa-solid fa-folder-open url: categories/ - name: 标签 icon: fa-solid fa-tags url: tags/ - name: 归档 icon: fa-solid fa-archive url: archives/ # - name: 友链 # icon: fa-solid fa-link # url: friends/ - name: 关于我 icon: fa-solid fa-info-circle url: about/ - name: 暗黑模式 icon: fa-solid fa-moon toggle: darkmode # - name: 背景音乐 # icon: fa-solid fa-compact-disc search: 随便逛逛... # Search bar placeholder########## 导航栏 ########## &gt; end 封面 点击查看 123456789101112131415161718192021222324252627282930########## 封面 ########## &gt; startcover: height_scheme: full # full, half layout_scheme: search # blank (留白), search (搜索), dock (坞), featured (精选), focus (焦点) title: &#x27;欢迎来到诚实同学的博客&#x27; subtitle: &#x27;&quot;Patience is key in life.&quot;&#x27; # 修改背景（静态，无视差滚动） background: /images/91.jpg features: - name: 首页 # img: volantis-static/media/twemoji/assets/svg/1f4f0.svg icon: fa-solid fa-home url: / - name: 分类 # img: volantis-static/media/twemoji/assets/svg/1f516.svg icon: fa-solid fa-folder-open url: categories/ - name: 标签 # img: volantis-static/media/twemoji/assets/svg/1f4af.svg icon: fa-solid fa-tags url: tags/ - name: 归档 # img: volantis-static/media/twemoji/assets/svg/1f5c3.svg icon: fa-solid fa-archive url: archives/ - name: 关于我 # img: volantis-static/media/twemoji/assets/svg/1f9ec.svg icon: fa-solid fa-info-circle url: about/########## 封面 ########## &gt; end 文章 点击查看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162########## 文章 ########## &gt; startarticle: preview: scheme: landscape # landscape # pin icon for post pin_icon: # volantis-static/media/twemoji/assets/svg/1f4cc.svg # auto generate title if not exist auto_title: true # false, true auto_excerpt: true # false, true # hide excerpt hide_excerpt: false # show split line or not line_style: solid # hidden, solid, dashed, dotted # show author author: false # true, false # show readmore button readmore: auto # auto, always body: top_meta: [author, category, date, wordcount] bottom_meta: [updated, tags, counter, share] meta_library: author: # 个人头像 avatar: /images/userphoto02.png # volantis-static/media/org.volantis/blog/favicon/apple-touch-icon.png name: Chen Shi url: https://github.com/CS0522/ date: icon: fa-solid fa-calendar-alt title: &#x27;发布于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ updated: icon: fa-solid fa-edit title: &#x27;最后更新于：&#x27; format: &#x27;ll&#x27; # 日期格式 http://momentjs.com/docs/ # 文章分类 category: icon: fa-solid fa-folder-open # 文章浏览计数 counter: icon: fa-solid fa-eye unit: &#x27;次浏览&#x27; # 文章字数和阅读时长 wordcount: icon_wordcount: fa-solid fa-keyboard icon_duration: fa-solid fa-hourglass-half # 文章标签 tags: icon: fa-solid fa-hashtag # 分享 share: - id: qq img: volantis-static/media/org.volantis/logo/128/qq.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qq.png - id: qzone img: volantis-static/media/org.volantis/logo/128/qzone.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/qzone.png - id: weibo img: volantis-static/media/org.volantis/logo/128/weibo.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/weibo.png - id: # qrcode # 当id为qrcode时需要安装插件 npm i hexo-helper-qrcode img: # volantis-static/media/org.volantis/logo/128/wechat.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/wechat.png - id: # telegram img: # volantis-static/media/org.volantis/logo/128/telegram.png # https://cdn.jsdelivr.net/gh/volantis-x/cdn-org/logo/128/telegram.png########## 文章 ########## &gt; end 侧边栏 点击查看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104########## 侧边栏 ########## &gt; startsidebar: for_page: [blogger, category, guide, tagcloud, webinfo] for_post: [toc, guide, tagcloud, webinfo] widget_library: toc: class: toc display: [desktop, mobile] # [desktop, mobile] header: icon: fa-solid fa-list title: 本文目录 list_number: true min_depth: 2 max_depth: 5 # 功能导航 guide: class: grid display: [desktop, mobile] # [desktop, mobile] header: icon: fa-solid fa-map-signs title: 功能导航 fixed: true # 固定宽度 rows: - name: 标签 icon: fa-solid fa-tags url: tags/ - name: 归档 icon: fa-solid fa-archive url: archives/ - name: 关于我 icon: fa-solid fa-info-circle url: about/ blogger: class: blogger display: [desktop, mobile] # [desktop, mobile] # 个人头像 avatar: /images/userphoto02_scaled.png # https://gcore.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png title: Chen Shi subtitle: &lt;p&gt;DLUT DRISE&lt;/p&gt;&lt;p&gt;2024届本科生&lt;/p&gt; jinrishici: false # Poetry Today. You can set a string, and it will be displayed when loading fails. social: - icon: fa-solid fa-envelope url: mailto:chenshi020522@outlook.com - icon: fa-brands fa-github url: https://github.com/CS0522/ - icon: fa-brands fa-weixin url: /images/weixin.png - icon: fa-brands fa-qq url: /images/qq.jpg - icon: fa-brands fa-bilibili url: https://space.bilibili.com/37047123/ # tagcloud widget tagcloud: class: tagcloud display: [desktop, mobile] # [desktop, mobile] header: icon: fa-solid fa-tags title: 标签 url: tags/ min_font: 14 max_font: 24 color: true start_color: &#x27;#999&#x27; end_color: &#x27;#555&#x27; # webinfo widget webinfo: class: webinfo display: [desktop, mobile] header: icon: fa-solid fa-award title: 站点信息 type: article: enable: true text: &#x27;文章数目：&#x27; unit: &#x27;篇&#x27; runtime: enable: true data: &#x27;2023/11/01&#x27; # 填写建站日期 text: &#x27;已运行时间：&#x27; unit: &#x27;天&#x27; wordcount: enable: true text: &#x27;本站总字数：&#x27; # 需要启用 wordcount unit: &#x27;字&#x27; visitcounter: siteuv: enable: true text: &#x27;本站访客数：&#x27; unit: &#x27;人&#x27; sitepv: enable: true text: &#x27;本站总访问量：&#x27; unit: &#x27;次&#x27; lastupd: enable: true friendlyShow: true # 更友好的时间显示 text: &#x27;最后活动时间：&#x27; unit: &#x27;日&#x27;########## 侧边栏 ########## &gt; end 底部 点击查看 123456789101112131415161718########### 底部 ########## &gt; startsite_footer: layout: [social, source, analytics, copyright] copyright: &#x27;Copyright © Since 2023 诚实同学&#x27; # 个人社交 social: - icon: fa-solid fa-envelope url: mailto:chenshi020522@outlook.com - icon: fa-brands fa-github url: https://github.com/CS0522/ - icon: fa-brands fa-weixin url: /images/weixin.png - icon: fa-brands fa-qq url: /images/qq.jpg - icon: fa-brands fa-bilibili url: https://space.bilibili.com/37047123/########### 底部 ########## &gt; end 网站字体 点击查看 12345678910111213141516171819fontfamily: logofont: fontfamily: &#x27;UbuntuMono, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &#x27;UbuntuMono&#x27; url: volantis-static/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf # volantis-static/media/fonts/Dosis/Dosis-Medium.ttf weight: normal style: normal bodyfont: fontfamily: &#x27;UbuntuMono, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &#x27;UbuntuMono&#x27; url: volantis-static/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf # volantis-static/media/fonts/Dosis/Dosis-Medium.ttf weight: normal style: normal codefont: fontfamily: &#x27;UbuntuMono, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, Helvetica, Arial&#x27; name: &#x27;UbuntuMono&#x27; url: volantis-static/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf # volantis-static/media/fonts/Monaco/Monaco.ttf # https://cdn.jsdelivr.net/gh/volantis-x/cdn-fonts/Monaco/Monaco.ttf weight: normal style: normal 插件 我装的插件： * hexo-deployer-git hexo-generator-json-content hexo-wordcount hexo-renderer-pandoc hexo-filter-mathjax 记得在配置文件中启用插件 点击查看 1234567891011121314151617181920212223242526272829303132333435363738########### 插件 ########## &gt; startplugins: # 修改背景 # 视差滚动效果 Slide Background parallax: enable: true position: cover # cover: sticky on the cover. fixed: Fixed as background for the site. shuffle: true # shuffle playlist duration: 60000 # Duration (ms) fade: 500 # fade duration (ms) (Not more than 1500) images: # For personal use only. At your own risk if used for commercial purposes !!! - /images/covers/cover01.jpg - /images/covers/cover02.jpg - /images/covers/cover03.jpg - /images/covers/cover04.jpg - /images/covers/cover05.jpg - /images/covers/cover06.jpg - /images/covers/cover07.jpg - /images/covers/cover08.jpg - /images/covers/cover09.jpg - /images/covers/cover10.jpg # 计数功能 wordcount: enable: true # math expressions render mathjax: enable: true per_page: false cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML # 搜索功能 search: enable: true service: hexo darkmode: enable: true########### 插件 ########## &gt; end 网站页面 归档页面 自动生成 关于页面 source/about/index.md 12345678910---layout: docsseo_title: 关于bottom_meta: falsesidebar: []twikoo: placeholder: 有什么想对我说的呢？---下面写关于自己的内容 分类页面 source/categories/index.md 12345---layout: categoryindex: truetitle: 所有分类--- 标签页面 source/tags/index.md 12345---layout: tagindex: truetitle: 所有标签--- 列表页面 source/mylist/index.md 12345---layout: listgroup: mylistindex: true--- 404页面 source/404.md 123456789101112131415---cover: truerobots: noindex,nofollowsitemap: falseseo_title: 404 Not Foundbottom_meta: falsesidebar: []twikoo: path: /404.html placeholder: 请留言告诉我您要访问哪个页面找不到了---&#123;% p logo center huge, 404 %&#125;&#123;% p center bold, 很抱歉，您访问的页面不存在 %&#125;&#123;% p center small, 可能是输入地址有误或该地址已被删除 %&#125; 问题与解答 1. 站内文章跳转？ 参考官方文档 12&#123;% post_path filename %&#125;&#123;% post_link filename [title] [escape] %&#125; escape 用于防止特殊字符转义 例子： 链接使用文章的标题 1&#123;% post_link hexo-3-8-released %&#125; Hexo 3.8.0 Released 链接使用自定义文字 1&#123;% post_link hexo-3-8-released &#x27;通往文章的链接&#x27; %&#125; 通往文章的链接 对标题的特殊字符进行转义 1&#123;% post_link hexo-4-released &#x27;How to use &lt;b&gt; tag in title&#x27; %&#125; How to use &lt;b&gt; tag in title 禁止对标题的特殊字符进行转义 1&#123;% post_link hexo-4-released &#x27;&lt;b&gt;bold&lt;/b&gt; custom title&#x27; false %&#125; bold custom title 2. 数学公式渲染？ 更换渲染引擎 123456789npm uninstall hexo-renderer-markednpm uninstall hexo-math# pandocnpm install hexo-renderer-pandoc# 这个插件必须要npm install hexo-filter-mathjaxsudo apt install pandoc 3. 网站页脚文字修改？ 进入 ./node_modules/hexo-theme-volantis/layout/_partial/footer.ejs 123456// 删除相关 if/else 语句// custom footer 部分写入 &lt;p&gt; 标签&lt;!-- Custom Files footer begin--&gt; &lt;%- volantis_inject(&#x27;footer&#x27;) %&gt; &lt;p style=&quot;font-size: .8125rem&quot;&gt;本站采用 &lt;a href=&quot;https://volantis.js.org/&quot; target=&quot;_blank&quot;&gt;Volantis&lt;/a&gt; 主题设计&lt;/p&gt;&lt;!-- Custom Files footer end--&gt; 4. CDN 加速？ 使用 jsdelivr CDN 加速访问 创建存放静态资源的仓库（CSBlog） 创建 Release 引用链接修改为 1234https://cdn.jsdelivr.net/gh/&lt;Username&gt;/&lt;Repo&gt;/&lt;文件路径&gt;# 例子https://cdn.jsdelivr.net/gh/CS0522/CSBlog/source/_posts/l-srcmap/fig02.png 5. 百度、谷歌、Bing 网站收录？ 参考：Hexo - SEO、Gitee Pages 百度收录 百度收录网址：https://ziyuan.baidu.com/site/index#/ Bing 收录网址：https://www.bing.com/webmasters 谷歌收录网址：https://search.google.com/search-console","categories":[{"name":"文档小记","slug":"docs","permalink":"https://cs0522.github.io/categories/docs/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://cs0522.github.io/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://cs0522.github.io/tags/Volantis/"},{"name":"Blog","slug":"Blog","permalink":"https://cs0522.github.io/tags/Blog/"}]}],"categories":[{"name":"学习笔记","slug":"notes","permalink":"https://cs0522.github.io/categories/notes/"},{"name":"设计模式","slug":"notes/设计模式","permalink":"https://cs0522.github.io/categories/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"存储","slug":"notes/存储","permalink":"https://cs0522.github.io/categories/notes/%E5%AD%98%E5%82%A8/"},{"name":"刷题日记","slug":"practices","permalink":"https://cs0522.github.io/categories/practices/"},{"name":"二叉树","slug":"practices/二叉树","permalink":"https://cs0522.github.io/categories/practices/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"C++","slug":"notes/C","permalink":"https://cs0522.github.io/categories/notes/C/"},{"name":"Shell","slug":"notes/Shell","permalink":"https://cs0522.github.io/categories/notes/Shell/"},{"name":"栈和队列","slug":"practices/栈和队列","permalink":"https://cs0522.github.io/categories/practices/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"name":"字符串","slug":"practices/字符串","permalink":"https://cs0522.github.io/categories/practices/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"哈希表","slug":"practices/哈希表","permalink":"https://cs0522.github.io/categories/practices/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"链表","slug":"practices/链表","permalink":"https://cs0522.github.io/categories/practices/%E9%93%BE%E8%A1%A8/"},{"name":"数组 - 螺旋矩阵","slug":"practices/数组-螺旋矩阵","permalink":"https://cs0522.github.io/categories/practices/%E6%95%B0%E7%BB%84-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"},{"name":"数组 - 滑动窗口","slug":"practices/数组-滑动窗口","permalink":"https://cs0522.github.io/categories/practices/%E6%95%B0%E7%BB%84-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"数组 - 双指针","slug":"practices/数组-双指针","permalink":"https://cs0522.github.io/categories/practices/%E6%95%B0%E7%BB%84-%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"论文随记","slug":"learnings","permalink":"https://cs0522.github.io/categories/learnings/"},{"name":"ANN","slug":"learnings/ANN","permalink":"https://cs0522.github.io/categories/learnings/ANN/"},{"name":"文档小记","slug":"docs","permalink":"https://cs0522.github.io/categories/docs/"},{"name":"数组 - 二分查找","slug":"practices/数组-二分查找","permalink":"https://cs0522.github.io/categories/practices/%E6%95%B0%E7%BB%84-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"DiskSim","slug":"notes/DiskSim","permalink":"https://cs0522.github.io/categories/notes/DiskSim/"},{"name":"SimPy","slug":"notes/SimPy","permalink":"https://cs0522.github.io/categories/notes/SimPy/"},{"name":"盘节能","slug":"learnings/盘节能","permalink":"https://cs0522.github.io/categories/learnings/%E7%9B%98%E8%8A%82%E8%83%BD/"}],"tags":[{"name":"存储","slug":"存储","permalink":"https://cs0522.github.io/tags/%E5%AD%98%E5%82%A8/"},{"name":"RPC","slug":"RPC","permalink":"https://cs0522.github.io/tags/RPC/"},{"name":"C++","slug":"C","permalink":"https://cs0522.github.io/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"https://cs0522.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"刷题","slug":"刷题","permalink":"https://cs0522.github.io/tags/%E5%88%B7%E9%A2%98/"},{"name":"二叉树","slug":"二叉树","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"Linux","slug":"Linux","permalink":"https://cs0522.github.io/tags/Linux/"},{"name":"CMake","slug":"CMake","permalink":"https://cs0522.github.io/tags/CMake/"},{"name":"SPDK","slug":"SPDK","permalink":"https://cs0522.github.io/tags/SPDK/"},{"name":"Shell","slug":"Shell","permalink":"https://cs0522.github.io/tags/Shell/"},{"name":"NVMe","slug":"NVMe","permalink":"https://cs0522.github.io/tags/NVMe/"},{"name":"栈和队列","slug":"栈和队列","permalink":"https://cs0522.github.io/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"name":"字符串","slug":"字符串","permalink":"https://cs0522.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"哈希表","slug":"哈希表","permalink":"https://cs0522.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"链表","slug":"链表","permalink":"https://cs0522.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"mmap","slug":"mmap","permalink":"https://cs0522.github.io/tags/mmap/"},{"name":"虚拟内存","slug":"虚拟内存","permalink":"https://cs0522.github.io/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"},{"name":"数组","slug":"数组","permalink":"https://cs0522.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"螺旋矩阵","slug":"螺旋矩阵","permalink":"https://cs0522.github.io/tags/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://cs0522.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"双指针","slug":"双指针","permalink":"https://cs0522.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"论文","slug":"论文","permalink":"https://cs0522.github.io/tags/%E8%AE%BA%E6%96%87/"},{"name":"HNSW","slug":"HNSW","permalink":"https://cs0522.github.io/tags/HNSW/"},{"name":"ANN","slug":"ANN","permalink":"https://cs0522.github.io/tags/ANN/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://cs0522.github.io/tags/Ubuntu/"},{"name":"VSCode","slug":"VSCode","permalink":"https://cs0522.github.io/tags/VSCode/"},{"name":"二分查找","slug":"二分查找","permalink":"https://cs0522.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"Python","slug":"Python","permalink":"https://cs0522.github.io/tags/Python/"},{"name":"DiskSim","slug":"DiskSim","permalink":"https://cs0522.github.io/tags/DiskSim/"},{"name":"SimPy","slug":"SimPy","permalink":"https://cs0522.github.io/tags/SimPy/"},{"name":"Atlantis JMVT","slug":"Atlantis-JMVT","permalink":"https://cs0522.github.io/tags/Atlantis-JMVT/"},{"name":"Vue","slug":"Vue","permalink":"https://cs0522.github.io/tags/Vue/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://cs0522.github.io/tags/SpringBoot/"},{"name":"WebSite","slug":"WebSite","permalink":"https://cs0522.github.io/tags/WebSite/"},{"name":"前端","slug":"前端","permalink":"https://cs0522.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"后端","slug":"后端","permalink":"https://cs0522.github.io/tags/%E5%90%8E%E7%AB%AF/"},{"name":"盘节能","slug":"盘节能","permalink":"https://cs0522.github.io/tags/%E7%9B%98%E8%8A%82%E8%83%BD/"},{"name":"RAID","slug":"RAID","permalink":"https://cs0522.github.io/tags/RAID/"},{"name":"数据迁移","slug":"数据迁移","permalink":"https://cs0522.github.io/tags/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/"},{"name":"能源比例","slug":"能源比例","permalink":"https://cs0522.github.io/tags/%E8%83%BD%E6%BA%90%E6%AF%94%E4%BE%8B/"},{"name":"虚拟化","slug":"虚拟化","permalink":"https://cs0522.github.io/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"SSH","slug":"SSH","permalink":"https://cs0522.github.io/tags/SSH/"},{"name":"Node.js","slug":"Node-js","permalink":"https://cs0522.github.io/tags/Node-js/"},{"name":"npm","slug":"npm","permalink":"https://cs0522.github.io/tags/npm/"},{"name":"nvm","slug":"nvm","permalink":"https://cs0522.github.io/tags/nvm/"},{"name":"Git","slug":"Git","permalink":"https://cs0522.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://cs0522.github.io/tags/GitHub/"},{"name":"anaconda","slug":"anaconda","permalink":"https://cs0522.github.io/tags/anaconda/"},{"name":"Hexo","slug":"Hexo","permalink":"https://cs0522.github.io/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://cs0522.github.io/tags/Volantis/"},{"name":"Blog","slug":"Blog","permalink":"https://cs0522.github.io/tags/Blog/"}]}